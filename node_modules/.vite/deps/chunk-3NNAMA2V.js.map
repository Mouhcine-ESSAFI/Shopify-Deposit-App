{
  "version": 3,
  "sources": ["../../@shopify/shopify-app-remix/node_modules/runtime/platform/runtime-string.ts", "../../@shopify/shopify-app-remix/node_modules/runtime/crypto/types.ts", "../../@shopify/shopify-app-remix/node_modules/runtime/http/index.ts", "../../@shopify/shopify-app-remix/node_modules/lib/error.ts", "../../@shopify/shopify-app-remix/node_modules/runtime/crypto/utils.ts", "../../@shopify/shopify-app-remix/node_modules/runtime/http/utils.ts", "../../@shopify/shopify-app-remix/node_modules/runtime/http/headers.ts", "../../@shopify/shopify-app-remix/node_modules/runtime/http/cookies.ts", "../../@shopify/src/server/authenticate/const.ts", "../../@shopify/src/server/authenticate/helpers/app-bridge-url.ts", "../../@shopify/src/server/types.ts"],
  "sourcesContent": ["import {AbstractRuntimeStringFunc} from './types';\n\n// eslint-disable-next-line import/no-mutable-exports\nexport let abstractRuntimeString: AbstractRuntimeStringFunc = () => {\n  throw new Error(\n    \"Missing adapter implementation for 'abstractRuntimeString' - make sure to import the appropriate adapter for your platform\",\n  );\n};\nexport function setAbstractRuntimeString(func: AbstractRuntimeStringFunc) {\n  abstractRuntimeString = func;\n}\n", "export enum HashFormat {\n  Base64 = 'base64',\n  Hex = 'hex',\n}\n", "import type {\n  AbstractFetchFunc,\n  AbstractConvertRequestFunc,\n  AbstractConvertIncomingResponseFunc,\n  AbstractConvertResponseFunc,\n  NormalizedResponse,\n  AbstractConvertHeadersFunc,\n} from './types';\n\nexport * from './cookies';\nexport * from './headers';\nexport * from './utils';\n\nexport * from './types';\n\nexport function isOK(resp: NormalizedResponse) {\n  // https://fetch.spec.whatwg.org/#ok-status\n  return resp.statusCode >= 200 && resp.statusCode <= 299;\n}\n\n// We ignore mutable export linting errors because we explicitly want these abstract functions to be overwritten.\n\n// eslint-disable-next-line import/no-mutable-exports\nexport let abstractFetch: AbstractFetchFunc = () => {\n  throw new Error(\n    \"Missing adapter implementation for 'abstractFetch' - make sure to import the appropriate adapter for your platform\",\n  );\n};\nexport function setAbstractFetchFunc(func: AbstractFetchFunc) {\n  abstractFetch = func;\n}\n\n// eslint-disable-next-line import/no-mutable-exports\nexport let abstractConvertRequest: AbstractConvertRequestFunc = () => {\n  throw new Error(\n    \"Missing adapter implementation for 'abstractConvertRequest' - make sure to import the appropriate adapter for your platform\",\n  );\n};\nexport function setAbstractConvertRequestFunc(\n  func: AbstractConvertRequestFunc,\n) {\n  abstractConvertRequest = func;\n}\n\n// By default we just return an empty NormalizedResponse because not all adapters will need to convert an incoming response\n// eslint-disable-next-line import/no-mutable-exports\nexport let abstractConvertIncomingResponse: AbstractConvertIncomingResponseFunc =\n  () => Promise.resolve({} as NormalizedResponse);\nexport function setAbstractConvertIncomingResponseFunc(\n  func: AbstractConvertIncomingResponseFunc,\n) {\n  abstractConvertIncomingResponse = func;\n}\n\n// eslint-disable-next-line import/no-mutable-exports\nexport let abstractConvertResponse: AbstractConvertResponseFunc = () => {\n  throw new Error(\n    \"Missing adapter implementation for 'abstractConvertResponse' - make sure to import the appropriate adapter for your platform\",\n  );\n};\nexport function setAbstractConvertResponseFunc(\n  func: AbstractConvertResponseFunc,\n) {\n  abstractConvertResponse = func;\n}\n\n// eslint-disable-next-line import/no-mutable-exports\nexport let abstractConvertHeaders: AbstractConvertHeadersFunc = () => {\n  throw new Error(\n    \"Missing adapter implementation for 'abstractConvertHeaders' - make sure to import the appropriate adapter for your platform\",\n  );\n};\nexport function setAbstractConvertHeadersFunc(\n  func: AbstractConvertHeadersFunc,\n) {\n  abstractConvertHeaders = func;\n}\n", "import {AdapterResponse} from '../runtime/http/types';\n\nexport class ShopifyError extends Error {\n  constructor(message?: string) {\n    super(message);\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n}\n\nexport class InvalidHmacError extends ShopifyError {}\nexport class InvalidShopError extends ShopifyError {}\nexport class InvalidHostError extends ShopifyError {}\nexport class InvalidJwtError extends ShopifyError {}\nexport class MissingJwtTokenError extends ShopifyError {}\nexport class InvalidDeliveryMethodError extends ShopifyError {}\n\nexport class SafeCompareError extends ShopifyError {}\nexport class PrivateAppError extends ShopifyError {}\n\nexport class HttpRequestError extends ShopifyError {}\nexport class HttpMaxRetriesError extends ShopifyError {}\n\ninterface HttpResponseData {\n  code: number;\n  statusText: string;\n  body?: Record<string, unknown>;\n  headers?: Record<string, unknown>;\n}\n\ninterface HttpResponseErrorParams extends HttpResponseData {\n  message: string;\n}\nexport class HttpResponseError<\n  ResponseType extends HttpResponseData = HttpResponseData,\n> extends ShopifyError {\n  readonly response: ResponseType;\n\n  constructor({\n    message,\n    code,\n    statusText,\n    body,\n    headers,\n  }: HttpResponseErrorParams) {\n    super(message);\n    this.response = {\n      code,\n      statusText,\n      body,\n      headers,\n    } as ResponseType;\n  }\n}\nexport class HttpRetriableError<\n  ResponseType extends HttpResponseData = HttpResponseData,\n> extends HttpResponseError<ResponseType> {}\nexport class HttpInternalError extends HttpRetriableError {}\n\ninterface HttpThrottlingErrorData extends HttpResponseData {\n  retryAfter?: number;\n}\ninterface HttpThrottlingErrorParams extends HttpThrottlingErrorData {\n  message: string;\n}\nexport class HttpThrottlingError extends HttpRetriableError<HttpThrottlingErrorData> {\n  constructor({retryAfter, ...params}: HttpThrottlingErrorParams) {\n    super(params);\n    this.response.retryAfter = retryAfter;\n  }\n}\n\nexport class RestResourceError extends ShopifyError {}\n\ninterface GraphqlQueryErrorParams {\n  message: string;\n  response: Record<string, unknown>;\n  headers?: Record<string, unknown>;\n  body?: Record<string, any>;\n}\n\nexport class GraphqlQueryError extends ShopifyError {\n  readonly response: Record<string, unknown>;\n  readonly headers?: Record<string, unknown>;\n  readonly body?: Record<string, any>;\n\n  constructor({message, response, headers, body}: GraphqlQueryErrorParams) {\n    super(message);\n    this.response = response;\n    this.headers = headers;\n    this.body = body;\n  }\n}\n\nexport class InvalidOAuthError extends ShopifyError {}\nexport class BotActivityDetected extends ShopifyError {}\nexport class CookieNotFound extends ShopifyError {}\nexport class InvalidSession extends ShopifyError {}\n\ninterface InvalidWebhookParams {\n  message: string;\n  response: AdapterResponse;\n}\nexport class InvalidWebhookError extends ShopifyError {\n  readonly response: AdapterResponse;\n\n  constructor({message, response}: InvalidWebhookParams) {\n    super(message);\n    this.response = response;\n  }\n}\nexport class MissingWebhookCallbackError extends InvalidWebhookError {}\nexport class SessionStorageError extends ShopifyError {}\nexport class MissingRequiredArgument extends ShopifyError {}\nexport class UnsupportedClientType extends ShopifyError {}\nexport class InvalidRequestError extends ShopifyError {}\ninterface BillingErrorParams {\n  message: string;\n  errorData: any;\n}\nexport class BillingError extends ShopifyError {\n  readonly errorData: any;\n\n  constructor({message, errorData}: BillingErrorParams) {\n    super(message);\n    this.errorData = errorData;\n  }\n}\nexport class FeatureDeprecatedError extends ShopifyError {}\n", "import {ShopifyError} from '../../lib/error';\n\nimport {HashFormat} from './types';\n\nexport async function createSHA256HMAC(\n  secret: string,\n  payload: string,\n  returnFormat: HashFormat = HashFormat.Base64,\n): Promise<string> {\n  const cryptoLib =\n    typeof (crypto as any)?.webcrypto === 'undefined'\n      ? crypto\n      : (crypto as any).webcrypto;\n\n  const enc = new TextEncoder();\n  const key = await cryptoLib.subtle.importKey(\n    'raw',\n    enc.encode(secret),\n    {\n      name: 'HMAC',\n      hash: {name: 'SHA-256'},\n    },\n    false,\n    ['sign'],\n  );\n\n  const signature = await cryptoLib.subtle.sign(\n    'HMAC',\n    key,\n    enc.encode(payload),\n  );\n  return returnFormat === HashFormat.Base64\n    ? asBase64(signature)\n    : asHex(signature);\n}\n\nexport function asHex(buffer: ArrayBuffer): string {\n  return [...new Uint8Array(buffer)]\n    .map((byte) => byte.toString(16).padStart(2, '0'))\n    .join('');\n}\n\nconst LookupTable =\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nexport function asBase64(buffer: ArrayBuffer): string {\n  let output = '';\n\n  const input = new Uint8Array(buffer);\n  for (let i = 0; i < input.length; ) {\n    const byte1 = input[i++];\n    const byte2 = input[i++];\n    const byte3 = input[i++];\n\n    const enc1 = byte1 >> 2;\n    const enc2 = ((byte1 & 0b00000011) << 4) | (byte2 >> 4);\n    let enc3 = ((byte2 & 0b00001111) << 2) | (byte3 >> 6);\n    let enc4 = byte3 & 0b00111111;\n\n    if (isNaN(byte2)) {\n      enc3 = 64;\n    }\n    if (isNaN(byte3)) {\n      enc4 = 64;\n    }\n\n    output +=\n      LookupTable[enc1] +\n      LookupTable[enc2] +\n      LookupTable[enc3] +\n      LookupTable[enc4];\n  }\n  return output;\n}\n\nexport function hashString(str: string, returnFormat: HashFormat): string {\n  const buffer = new TextEncoder().encode(str);\n\n  switch (returnFormat) {\n    case HashFormat.Base64:\n      return asBase64(buffer);\n    case HashFormat.Hex:\n      return asHex(buffer);\n    default:\n      throw new ShopifyError(`Unrecognized hash format '${returnFormat}'`);\n  }\n}\n", "export function splitN(\n  str: string,\n  sep: string,\n  maxNumParts: number,\n): string[] {\n  const parts = str.split(sep);\n  const maxParts = Math.min(Math.abs(maxNumParts), parts.length);\n\n  return [...parts.slice(0, maxParts - 1), parts.slice(maxParts - 1).join(sep)];\n}\n", "import type {Headers} from './types';\n\n/**\n * Canonicalizes a header name by capitalizing each segment and ensuring consistent hyphenation.\n *\n * @param hdr - The header name to canonicalize.\n * @returns The canonicalized header name.\n */\nexport function canonicalizeHeaderName(hdr: string): string {\n  return hdr.replace(\n    /(^|-)(\\w+)/g,\n    (_fullMatch, start, letters) =>\n      start +\n      letters.slice(0, 1).toUpperCase() +\n      letters.slice(1).toLowerCase(),\n  );\n}\n\n/**\n * Retrieves all values associated with a canonicalized header name from the headers object.\n *\n * @param headers - The headers object or undefined.\n * @param needle_ - The header name to search for.\n * @returns An array of header values associated with the canonicalized header name.\n */\nexport function getHeaders(\n  headers: Headers | undefined,\n  needle_: string,\n): string[] {\n  const result: string[] = [];\n  if (!headers) return result;\n  const needle = canonicalizeHeaderName(needle_);\n  for (const [key, values] of Object.entries(headers)) {\n    if (canonicalizeHeaderName(key) !== needle) continue;\n    if (Array.isArray(values)) {\n      result.push(...values);\n    } else {\n      result.push(values);\n    }\n  }\n  return result;\n}\n\n/**\n * Retrieves the first value associated with a canonicalized header name from the headers object.\n *\n * @param headers - The headers object or undefined.\n * @param needle - The header name to search for.\n * @returns The first value associated with the canonicalized header name, or undefined if not found.\n */\nexport function getHeader(\n  headers: Headers | undefined,\n  needle: string,\n): string | undefined {\n  if (!headers) return undefined;\n  return getHeaders(headers, needle)?.[0];\n}\n/**\n * Sets a header to a single value, canonicalizing the header name.\n *\n * @param headers - The headers object.\n * @param key - The header name to set.\n * @param value - The value to assign to the header.\n */\nexport function setHeader(headers: Headers, key: string, value: string) {\n  canonicalizeHeaders(headers);\n  headers[canonicalizeHeaderName(key)] = [value];\n}\n/**\n * Adds a value to an existing header, creating a new array if necessary, and canonicalizing the header name.\n *\n * @param headers - The headers object.\n * @param key - The header name to add to.\n * @param value - The value to add.\n */\nexport function addHeader(headers: Headers, key: string, value: string) {\n  canonicalizeHeaders(headers);\n  const canonKey = canonicalizeHeaderName(key);\n  let list = headers[canonKey];\n  if (!list) {\n    list = [];\n  } else if (!Array.isArray(list)) {\n    list = [list];\n  }\n  headers[canonKey] = list;\n  list.push(value);\n}\n\n/**\n * Canonicalizes a header value, converting numbers to strings.\n *\n * @param value - The value to canonicalize.\n * @returns The canonicalized value as a string.\n */\nfunction canonicalizeValue(value: any): any {\n  if (typeof value === 'number') return value.toString();\n  return value;\n}\n\n/**\n * Canonicalizes all headers in the headers object by ensuring consistent header names and values.\n *\n * @param hdr - The headers object to canonicalize.\n * @returns The headers object with canonicalized header names and values.\n */\nexport function canonicalizeHeaders(hdr: Headers): Headers {\n  for (const [key, values] of Object.entries(hdr)) {\n    const canonKey = canonicalizeHeaderName(key);\n    if (!hdr[canonKey]) hdr[canonKey] = [];\n    if (!Array.isArray(hdr[canonKey]))\n      hdr[canonKey] = [canonicalizeValue(hdr[canonKey])];\n    if (key === canonKey) continue;\n    delete hdr[key];\n    (hdr[canonKey] as any).push(\n      ...[values].flat().map((value) => canonicalizeValue(value)),\n    );\n  }\n  return hdr;\n}\n\n/**\n * Removes a header from the headers object.\n *\n * @param headers - The headers object.\n * @param needle - The header name to remove.\n */\nexport function removeHeader(headers: Headers, needle: string) {\n  canonicalizeHeaders(headers);\n  const canonKey = canonicalizeHeaderName(needle);\n  delete headers[canonKey];\n}\n\n/**\n * Converts a headers object into an array of tuples, where each tuple represents a header name and value.\n *\n * @param {Object|string[][]} headers - The headers object or undefined/null.\n * @returns {string[][]} An array of tuples where each tuple contains a header name and its corresponding value.\n *\n * @example\n * // Example headers object\n * const headers = {\n *   'Set-Cookie': 'a=b',\n *   'Set-Cookie': 'x=y'\n * };\n *\n * // Converted to an array of tuples\n * const result = convertHeadersToTuples(headers);\n * console.log(result);\n * // Output: [\n * //   [\"Set-Cookie\", \"a=b\"],\n * //   [\"Set-Cookie\", \"x=y\"]\n * // ]\n */\nexport function flatHeaders(\n  headers: Headers | undefined | null,\n): [string, string][] {\n  if (!headers) return [];\n\n  return Object.entries(headers).flatMap(([header, values]) =>\n    Array.isArray(values)\n      ? values.map((value): [string, string] => [header, value])\n      : [[header, values]],\n  );\n}\n", "// import type {Headers} from \"./headers\";\nimport {createSHA256HMAC} from '../crypto/utils';\n\nimport {splitN} from './utils';\nimport {getHeader, getHeaders, removeHeader, addHeader} from './headers';\n\nimport type {NormalizedRequest, NormalizedResponse} from '.';\n\nexport interface CookieData {\n  name: string;\n  value: string;\n  /**\n   * a number representing the milliseconds from Date.now() for expiry\n   */\n  maxAge?: number;\n  /**\n   * a Date object indicating the cookie's expiration\n   * date (expires at the end of session by default).\n   */\n  expires?: Date;\n  /**\n   * a string indicating the path of the cookie (/ by default).\n   */\n  path?: string;\n  /**\n   * a string indicating the domain of the cookie (no default).\n   */\n  domain?: string;\n  /**\n   * a boolean indicating whether the cookie is only to be sent\n   * over HTTPS (false by default for HTTP, true by default for HTTPS).\n   */\n  secure?: boolean;\n  /**\n   * a boolean indicating whether the cookie is only to be sent over HTTP(S),\n   * and not made available to client JavaScript (true by default).\n   */\n  httpOnly?: boolean;\n  /**\n   * a boolean or string indicating whether the cookie is a \"same site\" cookie (false by default).\n   * This can be set to 'strict', 'lax', or true (which maps to 'strict').\n   */\n  sameSite?: 'strict' | 'lax' | 'none';\n}\n\nexport type CookieJar = Record<string, CookieData>;\ninterface CookiesOptions {\n  keys: string[];\n  // Ignored. Only for type-compatibility with the node package for now.\n  secure: boolean;\n}\nexport class Cookies {\n  static parseCookies(hdrs: string[]): CookieJar {\n    const entries = hdrs\n      .filter((hdr) => hdr.trim().length > 0)\n      .map((cookieDef) => {\n        const [keyval, ...opts] = cookieDef.split(';');\n        const [name, value] = splitN(keyval, '=', 2).map((value) =>\n          value.trim(),\n        );\n        return [\n          name,\n          {\n            name,\n            value,\n            ...Object.fromEntries(\n              opts.map((opt) =>\n                splitN(opt, '=', 2).map((value) => value.trim()),\n              ),\n            ),\n          },\n        ];\n      });\n    const jar = Object.fromEntries(entries) as CookieJar;\n    for (const cookie of Object.values(jar)) {\n      if (typeof cookie.expires === 'string') {\n        cookie.expires = new Date(cookie.expires);\n      }\n    }\n    return jar;\n  }\n\n  static encodeCookie(data: CookieData): string {\n    let result = '';\n    result += `${data.name}=${data.value};`;\n    result += Object.entries(data)\n      .filter(([key]) => !['name', 'value', 'expires'].includes(key))\n      .map(([key, value]) => `${key}=${value}`)\n      .join('; ');\n    if (data.expires) {\n      result += ';';\n      result += `expires=${data.expires.toUTCString()}`;\n    }\n    return result;\n  }\n\n  receivedCookieJar: CookieJar = {};\n  outgoingCookieJar: CookieJar = {};\n  private keys: string[] = [];\n\n  constructor(\n    request: NormalizedRequest,\n    public response: NormalizedResponse,\n    {keys = []}: Partial<CookiesOptions> = {},\n  ) {\n    if (keys) this.keys = keys;\n\n    const cookieReqHdr = getHeader(request.headers, 'Cookie') ?? '';\n    this.receivedCookieJar = Cookies.parseCookies(cookieReqHdr.split(';'));\n    const cookieResHdr = getHeaders(response.headers, 'Set-Cookie') ?? [];\n    this.outgoingCookieJar = Cookies.parseCookies(cookieResHdr);\n  }\n\n  toHeaders(): string[] {\n    return Object.values(this.outgoingCookieJar).map((cookie) =>\n      Cookies.encodeCookie(cookie),\n    );\n  }\n\n  updateHeader() {\n    if (!this.response.headers) {\n      this.response.headers = {};\n    }\n    removeHeader(this.response.headers, 'Set-Cookie');\n    this.toHeaders().map((hdr) =>\n      addHeader(this.response.headers!, 'Set-Cookie', hdr),\n    );\n  }\n\n  get(name: string): string | undefined {\n    return this.receivedCookieJar[name]?.value;\n  }\n\n  deleteCookie(name: string) {\n    this.set(name, '', {\n      path: '/',\n      expires: new Date(0),\n    });\n  }\n\n  async getAndVerify(name: string): Promise<string | undefined> {\n    const value = this.get(name);\n    if (!value) return undefined;\n    if (!(await this.isSignedCookieValid(name))) {\n      return undefined;\n    }\n    return value;\n  }\n\n  private get canSign() {\n    return this.keys?.length > 0;\n  }\n\n  set(name: string, value: string, opts: Partial<CookieData> = {}): void {\n    this.outgoingCookieJar[name] = {\n      ...opts,\n      name,\n      value,\n    };\n    this.updateHeader();\n  }\n\n  async setAndSign(\n    name: string,\n    value: string,\n    opts: Partial<CookieData> = {},\n  ): Promise<void> {\n    if (!this.canSign) {\n      throw Error('No keys provided for signing.');\n    }\n    this.set(name, value, opts);\n    const sigName = `${name}.sig`;\n    const signature = await createSHA256HMAC(this.keys[0], value);\n    this.set(sigName, signature, opts);\n    this.updateHeader();\n  }\n\n  async isSignedCookieValid(cookieName: string): Promise<boolean> {\n    const signedCookieName = `${cookieName}.sig`;\n    if (\n      !this.cookieExists(cookieName) ||\n      !this.cookieExists(signedCookieName)\n    ) {\n      this.deleteInvalidCookies(cookieName, signedCookieName);\n      return false;\n    }\n    const cookieValue = this.get(cookieName);\n    const signature = this.get(signedCookieName);\n\n    if (!cookieValue || !signature) {\n      this.deleteInvalidCookies(cookieName, signedCookieName);\n      return false;\n    }\n\n    const allCheckSignatures = await Promise.all(\n      this.keys.map((key) => createSHA256HMAC(key, cookieValue)),\n    );\n\n    if (!allCheckSignatures.includes(signature)) {\n      this.deleteInvalidCookies(cookieName, signedCookieName);\n      return false;\n    }\n\n    return true;\n  }\n\n  private cookieExists(cookieName: string) {\n    return Boolean(this.get(cookieName));\n  }\n\n  private deleteInvalidCookies(...cookieNames: string[]): void {\n    cookieNames.forEach((cookieName) => this.deleteCookie(cookieName));\n  }\n}\n", "export const APP_BRIDGE_URL =\n  'https://cdn.shopify.com/shopifycloud/app-bridge.js';\n\nexport const REAUTH_URL_HEADER =\n  'X-Shopify-API-Request-Failure-Reauthorize-Url';\n\nexport const RETRY_INVALID_SESSION_HEADER = {\n  'X-Shopify-Retry-Invalid-Session-Request': '1',\n};\n\nexport const CORS_HEADERS = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Headers': 'Authorization',\n  'Access-Control-Expose-Headers': REAUTH_URL_HEADER,\n};\n", "import {APP_BRIDGE_URL} from '../const';\n\nlet appBridgeUrlOverride: string | undefined;\nexport function setAppBridgeUrlOverride(url: string) {\n  appBridgeUrlOverride = url;\n}\n\nexport function appBridgeUrl() {\n  return appBridgeUrlOverride || APP_BRIDGE_URL;\n}\n", "import {RegisterReturn, Shopify} from '@shopify/shopify-api';\nimport {SessionStorage} from '@shopify/shopify-app-session-storage';\n\nimport type {AuthenticateAdmin} from './authenticate/admin/types';\nimport type {AuthenticateFlow} from './authenticate/flow/types';\nimport {AuthenticateFulfillmentService} from './authenticate/fulfillment-service/types';\nimport type {AuthenticatePublic} from './authenticate/public/types';\nimport type {\n  AuthenticateWebhook,\n  RegisterWebhooksOptions,\n} from './authenticate/webhooks/types';\nimport type {AppConfig, AppConfigArg} from './config-types';\nimport type {\n  ApiConfigWithFutureFlags,\n  ApiFutureFlags,\n  FutureFlagOptions,\n} from './future/flags';\nimport type {Unauthenticated} from './unauthenticated/types';\n\nexport interface BasicParams<\n  Future extends FutureFlagOptions = FutureFlagOptions,\n> {\n  api: Shopify<ApiConfigWithFutureFlags<Future>, ApiFutureFlags<Future>>;\n  config: AppConfig;\n  logger: Shopify['logger'];\n}\n\n// eslint-disable-next-line no-warning-comments\n// TODO: Use this enum to replace the isCustomStoreApp config option in shopify-api-js\nexport enum AppDistribution {\n  AppStore = 'app_store',\n  SingleMerchant = 'single_merchant',\n  ShopifyAdmin = 'shopify_admin',\n}\n\ntype RegisterWebhooks = (\n  options: RegisterWebhooksOptions,\n) => Promise<RegisterReturn | void>;\n\nexport enum LoginErrorType {\n  MissingShop = 'MISSING_SHOP',\n  InvalidShop = 'INVALID_SHOP',\n}\n\nexport interface LoginError {\n  shop?: LoginErrorType;\n}\n\ntype Login = (request: Request) => Promise<LoginError | never>;\n\ntype AddDocumentResponseHeaders = (request: Request, headers: Headers) => void;\n\ntype SessionStorageType<Config extends AppConfigArg> =\n  Config['sessionStorage'] extends SessionStorage\n    ? Config['sessionStorage']\n    : SessionStorage;\n\ninterface Authenticate<Config extends AppConfigArg> {\n  /**\n   * Authenticate an admin Request and get back an authenticated admin context.  Use the authenticated admin context to interact with Shopify.\n   *\n   * Examples of when to use this are requests from your app's UI, or requests from admin extensions.\n   *\n   * If there is no session for the Request, this will redirect the merchant to correct auth flows.\n   *\n   * @example\n   * <caption>Authenticating a request for an embedded app.</caption>\n   * ```ts\n   * // /app/routes/**\\/*.jsx\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../../shopify.server\";\n   *\n   * export async function loader({ request }: LoaderFunctionArgs) {\n   *   const {admin, session, sessionToken, billing} = authenticate.admin(request);\n   *   const response = await admin.graphql(`{ shop { name } }`)\n   *\n   *   return json(await response.json());\n   * }\n   * ```\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { ApiVersion, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  admin: AuthenticateAdmin<Config>;\n\n  /**\n   * Authenticate a Flow extension Request and get back an authenticated context, containing an admin context to access\n   * the API, and the payload of the request.\n   *\n   * If there is no session for the Request, this will return an HTTP 400 error.\n   *\n   * Note that this will always be a POST request.\n   *\n   * @example\n   * <caption>Authenticating a Flow extension request.</caption>\n   * ```ts\n   * // /app/routes/**\\/*.jsx\n   * import { ActionFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../../shopify.server\";\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *   const {admin, session, payload} = authenticate.flow(request);\n   *\n   *   // Perform flow extension logic\n   *\n   *   // Return a 200 response\n   *   return null;\n   * }\n   * ```\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { ApiVersion, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  flow: AuthenticateFlow;\n\n  /**\n   * Authenticate a request from a fulfillment service and get back an authenticated context.\n   *\n   * @example\n   * <caption>Shopify session for the fulfillment service request.</caption>\n   * <description>Use the session associated with this request to use the Admin GraphQL API </description>\n   * ```ts\n   * // /app/routes/fulfillment_order_notification.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *   const { admin, session } = await authenticate.fulfillmentService(request);\n   *\n   *   console.log(session.id)\n   *\n   *   return new Response();\n   * }\n   * ```\n   * */\n  fulfillmentService: AuthenticateFulfillmentService;\n\n  /**\n   * Authenticate a public request and get back a session token.\n   *\n   * @example\n   * <caption>Authenticating a request from a checkout extension</caption>\n   *\n   * ```ts\n   * // /app/routes/api/checkout.jsx\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../../shopify.server\";\n   * import { getWidgets } from \"~/db/widgets\";\n   *\n   * export async function loader({ request }: LoaderFunctionArgs) {\n   *   const {sessionToken} = authenticate.public.checkout(request);\n   *\n   *   return json(await getWidgets(sessionToken));\n   * }\n   * ```\n   */\n  public: AuthenticatePublic;\n\n  /**\n   * Authenticate a Shopify webhook request, get back an authenticated admin context and details on the webhook request\n   * \n   * @example\n   * <caption>Authenticating a webhook request</caption>\n   *\n   * ```ts\n   * // app/routes/webhooks.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   * import db from \"../db.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { topic, shop, session, payload } = await authenticate.webhook(request);\n   * \n   *   // Webhook requests can trigger after an app is uninstalled\n   *   // If the app is already uninstalled, the session may be undefined.\n   *   if (!session) {\n   *     throw new Response();\n   *   }\n   * \n   *   // Handle the webhook\n   *   console.log(`${TOPIC} webhook received with payload:`, JSON.stringify(payload))\n   *\n   *   throw new Response();\n   * };\n   * ```\n   * \n   * @example\n   * <caption>Registering app-specific webhooks (Recommended)</caption>\n   * ```toml\n   * # shopify.app.toml\n   * [webhooks]\n   * api_version = \"2024-07\"\n\n   *   [[webhooks.subscriptions]]\n   *   topics = [\"products/create\"]\n   *   uri = \"/webhooks/products/create\"\n   * \n   * ```\n   * \n   * @example\n   * <caption>Registering shop-specific webhooks.</caption>\n   * <description>In many cases you won't need this. Please see: [https://shopify.dev/docs/apps/build/webhooks/subscribe#app-specific-vs-shop-specific-subscriptions](https://shopify.dev/docs/apps/build/webhooks/subscribe#app-specific-vs-shop-specific-subscriptions)\n   * </description>\n   * ```ts\n   * // app/shopify.server.ts\n   * import { DeliveryMethod, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   webhooks: {\n   *     PRODUCTS_CREATE: {\n   *       deliveryMethod: DeliveryMethod.Http,\n   *       callbackUrl: \"/webhooks/products/create\",\n   *     },\n   *   },\n   *   hooks: {\n   *     afterAuth: async ({ session }) => {\n   *       // Register webhooks for the shop\n   *       // In this example, every shop will have these webhooks\n   *       // You could wrap this in some custom shop specific conditional logic if needed\n   *       shopify.registerWebhooks({ session });\n   *     },\n   *   },\n   *   // ...etc\n   * });\n   * ```\n   */\n  webhook: AuthenticateWebhook<string>;\n}\n\nexport interface ShopifyAppBase<Config extends AppConfigArg> {\n  /**\n   * The `SessionStorage` instance you passed in as a config option.\n   *\n   * @example\n   * <caption>Storing sessions with Prisma.</caption>\n   * <description>Import the `@shopify/shopify-app-session-storage-prisma` package to store sessions in your Prisma database.</description>\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { PrismaSessionStorage } from \"@shopify/shopify-app-session-storage-prisma\";\n   * import prisma from \"~/db.server\";\n   *\n   * const shopify = shopifyApp({\n   *   sessionStorage: new PrismaSessionStorage(prisma),\n   *   // ...etc\n   * })\n   *\n   * // shopify.sessionStorage is an instance of PrismaSessionStorage\n   * ```\n   */\n  sessionStorage?: SessionStorageType<Config>;\n\n  /**\n   * Adds the required Content Security Policy headers for Shopify apps to the given Headers object.\n   *\n   * {@link https://shopify.dev/docs/apps/store/security/iframe-protection}\n   *\n   * @example\n   * <caption>Return headers on all requests.</caption>\n   * <description>Add headers to all HTML requests by calling `shopify.addDocumentResponseHeaders` in `entry.server.tsx`.</description>\n   *\n   * ```\n   * // ~/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const addDocumentResponseheaders = shopify.addDocumentResponseheaders;\n   * ```\n   *\n   * ```ts\n   * // entry.server.tsx\n   * import { addDocumentResponseHeaders } from \"~/shopify.server\";\n   *\n   * export default function handleRequest(\n   *   request: Request,\n   *   responseStatusCode: number,\n   *   responseHeaders: Headers,\n   *   remixContext: EntryContext\n   * ) {\n   *   const markup = renderToString(\n   *     <RemixServer context={remixContext} url={request.url} />\n   *   );\n   *\n   *   responseHeaders.set(\"Content-Type\", \"text/html\");\n   *   addDocumentResponseHeaders(request, responseHeaders);\n   *\n   *   return new Response(\"<!DOCTYPE html>\" + markup, {\n   *     status: responseStatusCode,\n   *     headers: responseHeaders,\n   *   });\n   * }\n   * ```\n   */\n  addDocumentResponseHeaders: AddDocumentResponseHeaders;\n\n  /**\n   * Register shop-specific webhook subscriptions using the Admin GraphQL API.\n   *\n   * In many cases defining app-specific webhooks in the `shopify.app.toml` will be sufficient and easier to manage.  Please see:\n   *\n   * {@link https://shopify.dev/docs/apps/build/webhooks/subscribe#app-specific-vs-shop-specific-subscriptions}\n   *\n   * You should only use this if you need shop-specific webhooks.\n   *\n   * @example\n   * <caption>Registering shop-specific webhooks after install</caption>\n   * <description>Trigger the registration to create the shop-specific webhook subscriptions after a merchant installs your app using the `afterAuth` hook. Learn more about [subscribing to webhooks.](https://shopify.dev/docs/api/shopify-app-remix/v3/guide-webhooks)</description>\n   * ```ts\n   * // app/shopify.server.ts\n   * import { DeliveryMethod, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   webhooks: {\n   *     PRODUCTS_CREATE: {\n   *       deliveryMethod: DeliveryMethod.Http,\n   *       callbackUrl: \"/webhooks/products/create\",\n   *     },\n   *   },\n   *   hooks: {\n   *     afterAuth: async ({ session }) => {\n   *       // Register webhooks for the shop\n   *       // In this example, every shop will have these webhooks\n   *       // You could wrap this in some custom shop specific conditional logic if needed\n   *       shopify.registerWebhooks({ session });\n   *     },\n   *   },\n   *   // ...etc\n   * });\n   * ```\n   */\n  registerWebhooks: RegisterWebhooks;\n\n  /**\n   * Ways to authenticate requests from different surfaces across Shopify.\n   *\n   * @example\n   * <caption>Authenticate Shopify requests.</caption>\n   * <description>Use the functions in `authenticate` to validate requests coming from Shopify.</description>\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { ApiVersion, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   * });\n   * export default shopify;\n   * ```\n   * ```ts\n   * // /app/routes/**\\/*.jsx\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import shopify from \"../../shopify.server\";\n   *\n   * export async function loader({ request }: LoaderFunctionArgs) {\n   *   const {admin, session, sessionToken, billing} = shopify.authenticate.admin(request);\n   *   const response = admin.graphql(`{ shop { name } }`)\n   *\n   *   return json(await response.json());\n   * }\n   * ```\n   */\n  authenticate: Authenticate<Config>;\n\n  /**\n   * Ways to get Contexts from requests that do not originate from Shopify.\n   *\n   * @example\n   * <caption>Using unauthenticated contexts.</caption>\n   * <description>Create contexts for requests that don't come from Shopify.</description>\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { ApiVersion, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   * });\n   * export default shopify;\n   * ```\n   * ```ts\n   * // /app/routes/**\\/*.jsx\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticateExternal } from \"~/helpers/authenticate\"\n   * import shopify from \"../../shopify.server\";\n   *\n   * export async function loader({ request }: LoaderFunctionArgs) {\n   *   const shop = await authenticateExternal(request)\n   *   const {admin} = await shopify.unauthenticated.admin(shop);\n   *   const response = admin.graphql(`{ shop { currencyCode } }`)\n   *\n   *   return json(await response.json());\n   * }\n   * ```\n   */\n  unauthenticated: Unauthenticated;\n}\n\nexport interface ShopifyAppLogin {\n  /**\n   * Log a merchant in, and redirect them to the app root. Will redirect the merchant to authentication if a shop is\n   * present in the URL search parameters or form data.\n   *\n   * This function won't be present when the `distribution` config option is set to `AppDistribution.ShopifyAdmin`,\n   * because Admin apps aren't allowed to show a login page.\n   *\n   * @example\n   * <caption>Creating a login page.</caption>\n   * <description>Use `shopify.login` to create a login form, in a route that can handle GET and POST requests.</description>\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { ApiVersion, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   * });\n   * export default shopify;\n   * ```\n   * ```ts\n   * // /app/routes/auth/login.tsx\n   * import shopify from \"../../shopify.server\";\n   *\n   * export async function loader({ request }: LoaderFunctionArgs) {\n   *   const errors = shopify.login(request);\n   *\n   *   return json(errors);\n   * }\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *   const errors = shopify.login(request);\n   *\n   *   return json(errors);\n   * }\n   *\n   * export default function Auth() {\n   *   const actionData = useActionData<typeof action>();\n   *   const [shop, setShop] = useState(\"\");\n   *\n   *   return (\n   *     <Page>\n   *       <Card>\n   *         <Form method=\"post\">\n   *           <FormLayout>\n   *             <Text variant=\"headingMd\" as=\"h2\">\n   *               Login\n   *             </Text>\n   *             <TextField\n   *               type=\"text\"\n   *               name=\"shop\"\n   *               label=\"Shop domain\"\n   *               helpText=\"e.g: my-shop-domain.myshopify.com\"\n   *               value={shop}\n   *               onChange={setShop}\n   *               autoComplete=\"on\"\n   *               error={actionData?.errors.shop}\n   *             />\n   *             <Button submit primary>\n   *               Submit\n   *             </Button>\n   *           </FormLayout>\n   *         </Form>\n   *       </Card>\n   *     </Page>\n   *   );\n   * }\n   * ```\n   */\n  login: Login;\n}\n\nexport type AdminApp<Config extends AppConfigArg> = ShopifyAppBase<Config>;\nexport type SingleMerchantApp<Config extends AppConfigArg> =\n  ShopifyAppBase<Config> & ShopifyAppLogin;\nexport type AppStoreApp<Config extends AppConfigArg> = ShopifyAppBase<Config> &\n  ShopifyAppLogin;\n\ntype EnforceSessionStorage<Config extends AppConfigArg, Base> = Base & {\n  sessionStorage: SessionStorageType<Config>;\n};\n\n/**\n * An object your app can use to interact with Shopify.\n *\n * By default, the app's distribution is `AppStore`.\n */\nexport type ShopifyApp<Config extends AppConfigArg> =\n  Config['distribution'] extends AppDistribution.ShopifyAdmin\n    ? AdminApp<Config>\n    : Config['distribution'] extends AppDistribution.SingleMerchant\n      ? EnforceSessionStorage<Config, SingleMerchantApp<Config>>\n      : Config['distribution'] extends AppDistribution.AppStore\n        ? EnforceSessionStorage<Config, AppStoreApp<Config>>\n        : EnforceSessionStorage<Config, AppStoreApp<Config>>;\n"],
  "mappings": "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",
  "names": ["HashFormat", "value", "AppDistribution", "LoginErrorType"]
}
