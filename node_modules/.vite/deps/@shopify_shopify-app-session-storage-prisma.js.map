{
  "version": 3,
  "sources": ["../../lib/auth/scopes/index.ts", "../../lib/utils/types.ts", "../../uuid/dist/esm-browser/regex.js", "../../uuid/dist/esm-browser/validate.js", "../../uuid/dist/esm-browser/parse.js", "../../uuid/dist/esm-browser/stringify.js", "../../uuid/dist/esm-browser/rng.js", "../../uuid/dist/esm-browser/md5.js", "../../uuid/dist/esm-browser/v35.js", "../../uuid/dist/esm-browser/v3.js", "../../uuid/dist/esm-browser/native.js", "../../uuid/dist/esm-browser/sha1.js", "../../uuid/dist/esm-browser/v5.js", "../../lib/session/session.ts", "../../lib/auth/oauth/token-exchange.ts", "../../lib/webhooks/types.ts", "../../lib/webhooks/validate.ts", "../../lib/webhooks/process.ts", "../../lib/billing/types.ts", "../../lib/billing/check.ts", "../../lib/billing/request.ts", "../../lib/billing/cancel.ts", "../../lib/billing/subscriptions.ts", "../../lib/billing/update-usage-subscription-capped-amount.ts", "../../@shopify/src/prisma.ts"],
  "sourcesContent": ["/**\n * A class that represents a set of access token scopes.\n */\nclass AuthScopes {\n  public static SCOPE_DELIMITER = ',';\n\n  private compressedScopes: Set<string>;\n  private expandedScopes: Set<string>;\n  private originalScopes: Set<string>;\n\n  constructor(scopes: string | string[] | AuthScopes | undefined) {\n    let scopesArray: string[] = [];\n    if (typeof scopes === 'string') {\n      scopesArray = scopes.split(\n        new RegExp(`${AuthScopes.SCOPE_DELIMITER}\\\\s*`),\n      );\n    } else if (Array.isArray(scopes)) {\n      scopesArray = scopes;\n    } else if (scopes) {\n      scopesArray = Array.from(scopes.expandedScopes);\n    }\n\n    scopesArray = scopesArray\n      .map((scope) => scope.trim())\n      .filter((scope) => scope.length);\n\n    const impliedScopes = this.getImpliedScopes(scopesArray);\n\n    const scopeSet = new Set(scopesArray);\n    const impliedSet = new Set(impliedScopes);\n\n    this.compressedScopes = new Set(\n      [...scopeSet].filter((x) => !impliedSet.has(x)),\n    );\n    this.expandedScopes = new Set([...scopeSet, ...impliedSet]);\n    this.originalScopes = scopeSet;\n  }\n\n  /**\n   * Checks whether the current set of scopes includes the given one.\n   */\n  public has(scope: string | string[] | AuthScopes | undefined) {\n    let other: AuthScopes;\n\n    if (scope instanceof AuthScopes) {\n      other = scope;\n    } else {\n      other = new AuthScopes(scope);\n    }\n\n    return (\n      other.toArray().filter((x) => !this.expandedScopes.has(x)).length === 0\n    );\n  }\n\n  /**\n   * Checks whether the current set of scopes equals the given one.\n   */\n  public equals(otherScopes: string | string[] | AuthScopes | undefined) {\n    let other: AuthScopes;\n\n    if (otherScopes instanceof AuthScopes) {\n      other = otherScopes;\n    } else {\n      other = new AuthScopes(otherScopes);\n    }\n\n    return (\n      this.compressedScopes.size === other.compressedScopes.size &&\n      this.toArray().filter((x) => !other.has(x)).length === 0\n    );\n  }\n\n  /**\n   * Returns a comma-separated string with the current set of scopes.\n   */\n  public toString() {\n    return this.toArray().join(AuthScopes.SCOPE_DELIMITER);\n  }\n\n  /**\n   * Returns an array with the current set of scopes.\n   */\n  public toArray(returnOriginalScopes = false) {\n    return returnOriginalScopes\n      ? [...this.originalScopes]\n      : [...this.compressedScopes];\n  }\n\n  private getImpliedScopes(scopesArray: string[]): string[] {\n    return scopesArray.reduce((array: string[], current: string) => {\n      const matches = current.match(/^(unauthenticated_)?write_(.*)$/);\n      if (matches) {\n        array.push(`${matches[1] ? matches[1] : ''}read_${matches[2]}`);\n      }\n\n      return array;\n    }, []);\n  }\n}\n\nexport {AuthScopes};\n", "import {AdapterArgs} from '../../runtime/types';\n\nexport enum HmacValidationType {\n  Flow = 'flow',\n  Webhook = 'webhook',\n  FulfillmentService = 'fulfillment_service',\n}\n\nexport interface ValidateParams extends AdapterArgs {\n  /**\n   * The raw body of the request.\n   */\n  rawBody: string;\n}\n\nexport const ValidationErrorReason = {\n  MissingBody: 'missing_body',\n  InvalidHmac: 'invalid_hmac',\n  MissingHmac: 'missing_hmac',\n} as const;\n\nexport type ValidationErrorReasonType =\n  (typeof ValidationErrorReason)[keyof typeof ValidationErrorReason];\n\nexport interface ValidationInvalid {\n  /**\n   * Whether the request is a valid Flow request from Shopify.\n   */\n  valid: false;\n  /**\n   * The reason why the request is not valid.\n   */\n  reason: ValidationErrorReasonType;\n}\n\nexport interface ValidationValid {\n  /**\n   * Whether the request is a valid request from Shopify.\n   */\n  valid: true;\n}\n", "export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;\n", "import REGEX from './regex.js';\nfunction validate(uuid) {\n    return typeof uuid === 'string' && REGEX.test(uuid);\n}\nexport default validate;\n", "import validate from './validate.js';\nfunction parse(uuid) {\n    if (!validate(uuid)) {\n        throw TypeError('Invalid UUID');\n    }\n    let v;\n    return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, (v >>> 16) & 0xff, (v >>> 8) & 0xff, v & 0xff, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 0xff, ((v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000) & 0xff, (v / 0x100000000) & 0xff, (v >>> 24) & 0xff, (v >>> 16) & 0xff, (v >>> 8) & 0xff, v & 0xff);\n}\nexport default parse;\n", "import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n", "let getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n    if (!getRandomValues) {\n        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {\n            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n        }\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    return getRandomValues(rnds8);\n}\n", "function md5(bytes) {\n    const words = uint8ToUint32(bytes);\n    const md5Bytes = wordsToMd5(words, bytes.length * 8);\n    return uint32ToUint8(md5Bytes);\n}\nfunction uint32ToUint8(input) {\n    const bytes = new Uint8Array(input.length * 4);\n    for (let i = 0; i < input.length * 4; i++) {\n        bytes[i] = (input[i >> 2] >>> ((i % 4) * 8)) & 0xff;\n    }\n    return bytes;\n}\nfunction getOutputLength(inputLength8) {\n    return (((inputLength8 + 64) >>> 9) << 4) + 14 + 1;\n}\nfunction wordsToMd5(x, len) {\n    const xpad = new Uint32Array(getOutputLength(len)).fill(0);\n    xpad.set(x);\n    xpad[len >> 5] |= 0x80 << len % 32;\n    xpad[xpad.length - 1] = len;\n    x = xpad;\n    let a = 1732584193;\n    let b = -271733879;\n    let c = -1732584194;\n    let d = 271733878;\n    for (let i = 0; i < x.length; i += 16) {\n        const olda = a;\n        const oldb = b;\n        const oldc = c;\n        const oldd = d;\n        a = md5ff(a, b, c, d, x[i], 7, -680876936);\n        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n        b = md5gg(b, c, d, a, x[i], 20, -373897302);\n        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n        d = md5hh(d, a, b, c, x[i], 11, -358537222);\n        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n        a = md5ii(a, b, c, d, x[i], 6, -198630844);\n        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n        a = safeAdd(a, olda);\n        b = safeAdd(b, oldb);\n        c = safeAdd(c, oldc);\n        d = safeAdd(d, oldd);\n    }\n    return Uint32Array.of(a, b, c, d);\n}\nfunction uint8ToUint32(input) {\n    if (input.length === 0) {\n        return new Uint32Array();\n    }\n    const output = new Uint32Array(getOutputLength(input.length * 8)).fill(0);\n    for (let i = 0; i < input.length; i++) {\n        output[i >> 2] |= (input[i] & 0xff) << ((i % 4) * 8);\n    }\n    return output;\n}\nfunction safeAdd(x, y) {\n    const lsw = (x & 0xffff) + (y & 0xffff);\n    const msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n    return (msw << 16) | (lsw & 0xffff);\n}\nfunction bitRotateLeft(num, cnt) {\n    return (num << cnt) | (num >>> (32 - cnt));\n}\nfunction md5cmn(q, a, b, x, s, t) {\n    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\nfunction md5ff(a, b, c, d, x, s, t) {\n    return md5cmn((b & c) | (~b & d), a, b, x, s, t);\n}\nfunction md5gg(a, b, c, d, x, s, t) {\n    return md5cmn((b & d) | (c & ~d), a, b, x, s, t);\n}\nfunction md5hh(a, b, c, d, x, s, t) {\n    return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\nfunction md5ii(a, b, c, d, x, s, t) {\n    return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\nexport default md5;\n", "import parse from './parse.js';\nimport { unsafeStringify } from './stringify.js';\nexport function stringToBytes(str) {\n    str = unescape(encodeURIComponent(str));\n    const bytes = new Uint8Array(str.length);\n    for (let i = 0; i < str.length; ++i) {\n        bytes[i] = str.charCodeAt(i);\n    }\n    return bytes;\n}\nexport const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function v35(version, hash, value, namespace, buf, offset) {\n    const valueBytes = typeof value === 'string' ? stringToBytes(value) : value;\n    const namespaceBytes = typeof namespace === 'string' ? parse(namespace) : namespace;\n    if (typeof namespace === 'string') {\n        namespace = parse(namespace);\n    }\n    if (namespace?.length !== 16) {\n        throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    }\n    let bytes = new Uint8Array(16 + valueBytes.length);\n    bytes.set(namespaceBytes);\n    bytes.set(valueBytes, namespaceBytes.length);\n    bytes = hash(bytes);\n    bytes[6] = (bytes[6] & 0x0f) | version;\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = bytes[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(bytes);\n}\n", "import md5 from './md5.js';\nimport v35, { DNS, URL } from './v35.js';\nexport { DNS, URL } from './v35.js';\nfunction v3(value, namespace, buf, offset) {\n    return v35(0x30, md5, value, namespace, buf, offset);\n}\nv3.DNS = DNS;\nv3.URL = URL;\nexport default v3;\n", "const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default { randomUUID };\n", "function f(s, x, y, z) {\n    switch (s) {\n        case 0:\n            return (x & y) ^ (~x & z);\n        case 1:\n            return x ^ y ^ z;\n        case 2:\n            return (x & y) ^ (x & z) ^ (y & z);\n        case 3:\n            return x ^ y ^ z;\n    }\n}\nfunction ROTL(x, n) {\n    return (x << n) | (x >>> (32 - n));\n}\nfunction sha1(bytes) {\n    const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n    const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n    const newBytes = new Uint8Array(bytes.length + 1);\n    newBytes.set(bytes);\n    newBytes[bytes.length] = 0x80;\n    bytes = newBytes;\n    const l = bytes.length / 4 + 2;\n    const N = Math.ceil(l / 16);\n    const M = new Array(N);\n    for (let i = 0; i < N; ++i) {\n        const arr = new Uint32Array(16);\n        for (let j = 0; j < 16; ++j) {\n            arr[j] =\n                (bytes[i * 64 + j * 4] << 24) |\n                    (bytes[i * 64 + j * 4 + 1] << 16) |\n                    (bytes[i * 64 + j * 4 + 2] << 8) |\n                    bytes[i * 64 + j * 4 + 3];\n        }\n        M[i] = arr;\n    }\n    M[N - 1][14] = ((bytes.length - 1) * 8) / Math.pow(2, 32);\n    M[N - 1][14] = Math.floor(M[N - 1][14]);\n    M[N - 1][15] = ((bytes.length - 1) * 8) & 0xffffffff;\n    for (let i = 0; i < N; ++i) {\n        const W = new Uint32Array(80);\n        for (let t = 0; t < 16; ++t) {\n            W[t] = M[i][t];\n        }\n        for (let t = 16; t < 80; ++t) {\n            W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n        }\n        let a = H[0];\n        let b = H[1];\n        let c = H[2];\n        let d = H[3];\n        let e = H[4];\n        for (let t = 0; t < 80; ++t) {\n            const s = Math.floor(t / 20);\n            const T = (ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t]) >>> 0;\n            e = d;\n            d = c;\n            c = ROTL(b, 30) >>> 0;\n            b = a;\n            a = T;\n        }\n        H[0] = (H[0] + a) >>> 0;\n        H[1] = (H[1] + b) >>> 0;\n        H[2] = (H[2] + c) >>> 0;\n        H[3] = (H[3] + d) >>> 0;\n        H[4] = (H[4] + e) >>> 0;\n    }\n    return Uint8Array.of(H[0] >> 24, H[0] >> 16, H[0] >> 8, H[0], H[1] >> 24, H[1] >> 16, H[1] >> 8, H[1], H[2] >> 24, H[2] >> 16, H[2] >> 8, H[2], H[3] >> 24, H[3] >> 16, H[3] >> 8, H[3], H[4] >> 24, H[4] >> 16, H[4] >> 8, H[4]);\n}\nexport default sha1;\n", "import sha1 from './sha1.js';\nimport v35, { DNS, URL } from './v35.js';\nexport { DNS, URL } from './v35.js';\nfunction v5(value, namespace, buf, offset) {\n    return v35(0x50, sha1, value, namespace, buf, offset);\n}\nv5.DNS = DNS;\nv5.URL = URL;\nexport default v5;\n", "/* eslint-disable no-fallthrough */\nimport {InvalidSession} from '../error';\nimport {OnlineAccessInfo} from '../auth/oauth/types';\nimport {AuthScopes} from '../auth/scopes';\n\nimport {SessionParams} from './types';\n\nconst propertiesToSave = [\n  'id',\n  'shop',\n  'state',\n  'isOnline',\n  'scope',\n  'accessToken',\n  'expires',\n  'onlineAccessInfo',\n];\n\n/**\n * Stores App information from logged in merchants so they can make authenticated requests to the Admin API.\n */\nexport class Session {\n  public static fromPropertyArray(\n    entries: [string, string | number | boolean][],\n    returnUserData = false,\n  ): Session {\n    if (!Array.isArray(entries)) {\n      throw new InvalidSession(\n        'The parameter is not an array: a Session cannot be created from this object.',\n      );\n    }\n\n    const obj = Object.fromEntries(\n      entries\n        .filter(([_key, value]) => value !== null && value !== undefined)\n        // Sanitize keys\n        .map(([key, value]) => {\n          switch (key.toLowerCase()) {\n            case 'isonline':\n              return ['isOnline', value];\n            case 'accesstoken':\n              return ['accessToken', value];\n            case 'onlineaccessinfo':\n              return ['onlineAccessInfo', value];\n            case 'userid':\n              return ['userId', value];\n            case 'firstname':\n              return ['firstName', value];\n            case 'lastname':\n              return ['lastName', value];\n            case 'accountowner':\n              return ['accountOwner', value];\n            case 'emailverified':\n              return ['emailVerified', value];\n            default:\n              return [key.toLowerCase(), value];\n          }\n        }),\n    );\n\n    const sessionData = {} as SessionParams;\n    const onlineAccessInfo = {\n      associated_user: {},\n    } as OnlineAccessInfo;\n    Object.entries(obj).forEach(([key, value]) => {\n      switch (key) {\n        case 'isOnline':\n          if (typeof value === 'string') {\n            sessionData[key] = value.toString().toLowerCase() === 'true';\n          } else if (typeof value === 'number') {\n            sessionData[key] = Boolean(value);\n          } else {\n            sessionData[key] = value;\n          }\n          break;\n        case 'scope':\n          sessionData[key] = value.toString();\n          break;\n        case 'expires':\n          sessionData[key] = value ? new Date(Number(value)) : undefined;\n          break;\n        case 'onlineAccessInfo':\n          onlineAccessInfo.associated_user.id = Number(value);\n          break;\n        case 'userId':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.id = Number(value);\n            break;\n          }\n        case 'firstName':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.first_name = String(value);\n            break;\n          }\n        case 'lastName':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.last_name = String(value);\n            break;\n          }\n        case 'email':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.email = String(value);\n            break;\n          }\n        case 'accountOwner':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.account_owner = Boolean(value);\n            break;\n          }\n        case 'locale':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.locale = String(value);\n            break;\n          }\n        case 'collaborator':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.collaborator = Boolean(value);\n            break;\n          }\n        case 'emailVerified':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.email_verified = Boolean(value);\n            break;\n          }\n        // Return any user keys as passed in\n        default:\n          sessionData[key] = value;\n      }\n    });\n    if (sessionData.isOnline) {\n      sessionData.onlineAccessInfo = onlineAccessInfo;\n    }\n    const session = new Session(sessionData);\n    return session;\n  }\n\n  /**\n   * The unique identifier for the session.\n   */\n  readonly id: string;\n  /**\n   * The Shopify shop domain, such as `example.myshopify.com`.\n   */\n  public shop: string;\n  /**\n   * The state of the session. Used for the OAuth authentication code flow.\n   */\n  public state: string;\n  /**\n   * Whether the access token in the session is online or offline.\n   */\n  public isOnline: boolean;\n  /**\n   * The desired scopes for the access token, at the time the session was created.\n   */\n  public scope?: string;\n  /**\n   * The date the access token expires.\n   */\n  public expires?: Date;\n  /**\n   * The access token for the session.\n   */\n  public accessToken?: string;\n  /**\n   * Information on the user for the session. Only present for online sessions.\n   */\n  public onlineAccessInfo?: OnlineAccessInfo;\n\n  constructor(params: SessionParams) {\n    Object.assign(this, params);\n  }\n\n  /**\n   * Whether the session is active. Active sessions have an access token that is not expired, and has has the given\n   * scopes if scopes is equal to a truthy value.\n   */\n  public isActive(\n    scopes: AuthScopes | string | string[] | undefined,\n    withinMillisecondsOfExpiry = 500,\n  ): boolean {\n    const hasAccessToken = Boolean(this.accessToken);\n    const isTokenNotExpired = !this.isExpired(withinMillisecondsOfExpiry);\n    const isScopeChanged = this.isScopeChanged(scopes);\n    return !isScopeChanged && hasAccessToken && isTokenNotExpired;\n  }\n\n  /**\n   * Whether the access token includes the given scopes if they are provided.\n   */\n  public isScopeChanged(\n    scopes: AuthScopes | string | string[] | undefined,\n  ): boolean {\n    if (typeof scopes === 'undefined') {\n      return false;\n    }\n\n    return !this.isScopeIncluded(scopes);\n  }\n\n  /**\n   * Whether the access token includes the given scopes.\n   */\n  public isScopeIncluded(scopes: AuthScopes | string | string[]): boolean {\n    const requiredScopes =\n      scopes instanceof AuthScopes ? scopes : new AuthScopes(scopes);\n    const sessionScopes = new AuthScopes(this.scope);\n\n    return sessionScopes.has(requiredScopes);\n  }\n\n  /**\n   * Whether the access token is expired.\n   */\n  public isExpired(withinMillisecondsOfExpiry = 0): boolean {\n    return Boolean(\n      this.expires &&\n        this.expires.getTime() - withinMillisecondsOfExpiry < Date.now(),\n    );\n  }\n\n  /**\n   * Converts an object with data into a Session.\n   */\n  public toObject(): SessionParams {\n    const object: SessionParams = {\n      id: this.id,\n      shop: this.shop,\n      state: this.state,\n      isOnline: this.isOnline,\n    };\n\n    if (this.scope) {\n      object.scope = this.scope;\n    }\n    if (this.expires) {\n      object.expires = this.expires;\n    }\n    if (this.accessToken) {\n      object.accessToken = this.accessToken;\n    }\n    if (this.onlineAccessInfo) {\n      object.onlineAccessInfo = this.onlineAccessInfo;\n    }\n    return object;\n  }\n\n  /**\n   * Checks whether the given session is equal to this session.\n   */\n  public equals(other: Session | undefined): boolean {\n    if (!other) return false;\n\n    const mandatoryPropsMatch =\n      this.id === other.id &&\n      this.shop === other.shop &&\n      this.state === other.state &&\n      this.isOnline === other.isOnline;\n\n    if (!mandatoryPropsMatch) return false;\n\n    const copyA = this.toPropertyArray(true);\n    copyA.sort(([k1], [k2]) => (k1 < k2 ? -1 : 1));\n\n    const copyB = other.toPropertyArray(true);\n    copyB.sort(([k1], [k2]) => (k1 < k2 ? -1 : 1));\n\n    return JSON.stringify(copyA) === JSON.stringify(copyB);\n  }\n\n  /**\n   * Converts the session into an array of key-value pairs.\n   */\n  public toPropertyArray(\n    returnUserData = false,\n  ): [string, string | number | boolean][] {\n    return (\n      Object.entries(this)\n        .filter(\n          ([key, value]) =>\n            propertiesToSave.includes(key) &&\n            value !== undefined &&\n            value !== null,\n        )\n        // Prepare values for db storage\n        .flatMap(([key, value]): [string, string | number | boolean][] => {\n          switch (key) {\n            case 'expires':\n              return [[key, value ? value.getTime() : undefined]];\n            case 'onlineAccessInfo':\n              // eslint-disable-next-line no-negated-condition\n              if (!returnUserData) {\n                return [[key, value.associated_user.id]];\n              } else {\n                return [\n                  ['userId', value?.associated_user?.id],\n                  ['firstName', value?.associated_user?.first_name],\n                  ['lastName', value?.associated_user?.last_name],\n                  ['email', value?.associated_user?.email],\n                  ['locale', value?.associated_user?.locale],\n                  ['emailVerified', value?.associated_user?.email_verified],\n                  ['accountOwner', value?.associated_user?.account_owner],\n                  ['collaborator', value?.associated_user?.collaborator],\n                ];\n              }\n            default:\n              return [[key, value]];\n          }\n        })\n        // Filter out tuples with undefined values\n        .filter(([_key, value]) => value !== undefined)\n    );\n  }\n}\n", "import {throwFailedRequest} from '../../clients/common';\nimport {decodeSessionToken} from '../../session/decode-session-token';\nimport {sanitizeShop} from '../../utils/shop-validator';\nimport {ConfigInterface} from '../../base-types';\nimport {Session} from '../../session/session';\nimport {DataType} from '../../clients/types';\nimport {fetchRequestFactory} from '../../utils/fetch-request';\n\nimport {createSession} from './create-session';\nimport {AccessTokenResponse} from './types';\n\nexport enum RequestedTokenType {\n  OnlineAccessToken = 'urn:shopify:params:oauth:token-type:online-access-token',\n  OfflineAccessToken = 'urn:shopify:params:oauth:token-type:offline-access-token',\n}\n\nconst TokenExchangeGrantType =\n  'urn:ietf:params:oauth:grant-type:token-exchange';\nconst IdTokenType = 'urn:ietf:params:oauth:token-type:id_token';\n\nexport interface TokenExchangeParams {\n  shop: string;\n  sessionToken: string;\n  requestedTokenType: RequestedTokenType;\n}\n\nexport type TokenExchange = (\n  params: TokenExchangeParams,\n) => Promise<{session: Session}>;\n\nexport function tokenExchange(config: ConfigInterface): TokenExchange {\n  return async ({\n    shop,\n    sessionToken,\n    requestedTokenType,\n  }: TokenExchangeParams) => {\n    await decodeSessionToken(config)(sessionToken);\n\n    const body = {\n      client_id: config.apiKey,\n      client_secret: config.apiSecretKey,\n      grant_type: TokenExchangeGrantType,\n      subject_token: sessionToken,\n      subject_token_type: IdTokenType,\n      requested_token_type: requestedTokenType,\n    };\n\n    const cleanShop = sanitizeShop(config)(shop, true)!;\n\n    const postResponse = await fetchRequestFactory(config)(\n      `https://${cleanShop}/admin/oauth/access_token`,\n      {\n        method: 'POST',\n        body: JSON.stringify(body),\n        headers: {\n          'Content-Type': DataType.JSON,\n          Accept: DataType.JSON,\n        },\n      },\n    );\n\n    if (!postResponse.ok) {\n      throwFailedRequest(await postResponse.json(), false, postResponse);\n    }\n\n    return {\n      session: createSession({\n        accessTokenResponse: await postResponse.json<AccessTokenResponse>(),\n        shop: cleanShop,\n        // We need to keep this as an empty string as our template DB schemas have this required\n        state: '',\n        config,\n      }),\n    };\n  };\n}\n", "import {ValidationErrorReason, ValidationInvalid} from '../utils/types';\nimport {AdapterArgs} from '../../runtime/types';\nimport {Session} from '../session/session';\n\nexport enum DeliveryMethod {\n  Http = 'http',\n  EventBridge = 'eventbridge',\n  PubSub = 'pubsub',\n}\n\nexport type WebhookHandlerFunction = (\n  topic: string,\n  shop_domain: string,\n  body: string,\n  webhookId: string,\n  apiVersion?: string,\n  subTopic?: string,\n  context?: any,\n) => Promise<void>;\n\ninterface BaseWebhookHandler {\n  id?: string;\n  includeFields?: string[];\n  metafieldNamespaces?: string[];\n  subTopic?: string;\n  context?: any;\n}\n\nexport interface HttpWebhookHandler extends BaseWebhookHandler {\n  deliveryMethod: DeliveryMethod.Http;\n  callbackUrl: string;\n}\n\nexport interface HttpWebhookHandlerWithCallback extends HttpWebhookHandler {\n  callback: WebhookHandlerFunction;\n}\n\nexport interface EventBridgeWebhookHandler extends BaseWebhookHandler {\n  deliveryMethod: DeliveryMethod.EventBridge;\n  arn: string;\n}\n\nexport interface PubSubWebhookHandler extends BaseWebhookHandler {\n  deliveryMethod: DeliveryMethod.PubSub;\n  pubSubProject: string;\n  pubSubTopic: string;\n}\n\nexport type WebhookHandler =\n  | HttpWebhookHandler\n  | HttpWebhookHandlerWithCallback\n  | EventBridgeWebhookHandler\n  | PubSubWebhookHandler;\n\n// See https://shopify.dev/docs/api/admin-graphql/latest/enums/webhooksubscriptiontopic for available topics\nexport type WebhookRegistry<Handler extends WebhookHandler = WebhookHandler> =\n  Record<string, Handler[]>;\n\n// eslint-disable-next-line no-warning-comments\n// TODO Rethink the wording for this enum - the operations we're doing are actually \"subscribing\" and \"unsubscribing\"\n// Consider changing the values when releasing v12.0.0 when it can be safely deprecated\nexport enum WebhookOperation {\n  Create = 'create',\n  Update = 'update',\n  Delete = 'delete',\n}\n\nexport interface RegisterParams {\n  session: Session;\n}\n\nexport interface RegisterResult {\n  success: boolean;\n  deliveryMethod: DeliveryMethod;\n  result: unknown;\n  operation: WebhookOperation;\n}\n\nexport type RegisterReturn = Record<string, RegisterResult[]>;\n\ninterface WebhookHttpEndpoint {\n  __typename: 'WebhookHttpEndpoint';\n  callbackUrl: string;\n}\ninterface WebhookEventBridgeEndpoint {\n  __typename: 'WebhookEventBridgeEndpoint';\n  arn: string;\n}\ninterface WebhookPubSubEndpoint {\n  __typename: 'WebhookPubSubEndpoint';\n  pubSubProject: string;\n  pubSubTopic: string;\n}\n\ntype WebhookEndpoint =\n  | WebhookHttpEndpoint\n  | WebhookEventBridgeEndpoint\n  | WebhookPubSubEndpoint;\n\nexport interface WebhookCheckResponseNode<\n  T = {\n    endpoint: WebhookEndpoint;\n  },\n> {\n  node: {\n    id: string;\n    topic: string;\n    includeFields: string[];\n    metafieldNamespaces: string[];\n  } & T;\n}\n\nexport interface WebhookCheckResponse<T = WebhookCheckResponseNode> {\n  webhookSubscriptions: {\n    edges: T[];\n    pageInfo: {\n      endCursor: string;\n      hasNextPage: boolean;\n    };\n  };\n}\n\nexport type AddHandlersParams = Record<\n  string,\n  WebhookHandler | WebhookHandler[]\n>;\n\nexport interface WebhookProcessParams extends AdapterArgs {\n  rawBody: string;\n  context?: any;\n}\n\nexport interface WebhookValidateParams extends WebhookProcessParams {}\n\nexport const WebhookValidationErrorReason = {\n  ...ValidationErrorReason,\n  MissingHeaders: 'missing_headers',\n} as const;\n\nexport type WebhookValidationErrorReasonType =\n  (typeof WebhookValidationErrorReason)[keyof typeof WebhookValidationErrorReason];\n\nexport interface WebhookFields {\n  webhookId: string;\n  apiVersion: string;\n  domain: string;\n  hmac: string;\n  topic: string;\n  subTopic?: string;\n}\n\nexport interface WebhookValidationInvalid\n  extends Omit<ValidationInvalid, 'reason'> {\n  valid: false;\n  reason: WebhookValidationErrorReasonType;\n}\n\nexport interface WebhookValidationMissingHeaders\n  extends WebhookValidationInvalid {\n  reason: typeof WebhookValidationErrorReason.MissingHeaders;\n  missingHeaders: string[];\n}\n\nexport interface WebhookValidationValid extends WebhookFields {\n  valid: true;\n}\n\nexport type WebhookValidation =\n  | WebhookValidationValid\n  | WebhookValidationInvalid\n  | WebhookValidationMissingHeaders;\n", "import {logger} from '../logger';\nimport {validateHmacFromRequestFactory} from '../utils/hmac-validator';\nimport {HmacValidationType, ValidationErrorReason} from '../utils/types';\nimport {\n  abstractConvertRequest,\n  getHeader,\n  Headers,\n  NormalizedRequest,\n} from '../../runtime/http';\nimport {ShopifyHeader} from '../types';\nimport {ConfigInterface} from '../base-types';\n\nimport {\n  WebhookFields,\n  WebhookValidateParams,\n  WebhookValidation,\n  WebhookValidationErrorReason,\n  WebhookValidationMissingHeaders,\n  WebhookValidationValid,\n} from './types';\nimport {topicForStorage} from './registry';\n\nconst OPTIONAL_HANDLER_PROPERTIES = {\n  subTopic: ShopifyHeader.SubTopic,\n};\n\nconst HANDLER_PROPERTIES = {\n  apiVersion: ShopifyHeader.ApiVersion,\n  domain: ShopifyHeader.Domain,\n  hmac: ShopifyHeader.Hmac,\n  topic: ShopifyHeader.Topic,\n  webhookId: ShopifyHeader.WebhookId,\n  ...OPTIONAL_HANDLER_PROPERTIES,\n};\n\nexport function validateFactory(config: ConfigInterface) {\n  return async function validate({\n    rawBody,\n    ...adapterArgs\n  }: WebhookValidateParams): Promise<WebhookValidation> {\n    const request: NormalizedRequest =\n      await abstractConvertRequest(adapterArgs);\n\n    const validHmacResult = await validateHmacFromRequestFactory(config)({\n      type: HmacValidationType.Webhook,\n      rawBody,\n      ...adapterArgs,\n    });\n\n    if (!validHmacResult.valid) {\n      if (validHmacResult.reason === ValidationErrorReason.InvalidHmac) {\n        const log = logger(config);\n        await log.debug(\n          \"Webhook HMAC validation failed. Please note that events manually triggered from a store's Notifications settings will fail this validation. To test this, please use the CLI or trigger the actual event in a development store.\",\n        );\n      }\n      return validHmacResult;\n    }\n\n    return checkWebhookHeaders(request.headers);\n  };\n}\n\nfunction checkWebhookHeaders(\n  headers: Headers,\n): WebhookValidationMissingHeaders | WebhookValidationValid {\n  const missingHeaders: ShopifyHeader[] = [];\n  const entries = Object.entries(HANDLER_PROPERTIES) as [\n    keyof WebhookFields,\n    ShopifyHeader,\n  ][];\n  const headerValues = entries.reduce((acc, [property, headerName]) => {\n    const headerValue = getHeader(headers, headerName);\n    if (headerValue) {\n      acc[property] = headerValue;\n    } else if (!(property in OPTIONAL_HANDLER_PROPERTIES)) {\n      missingHeaders.push(headerName);\n    }\n\n    return acc;\n  }, {} as WebhookFields);\n\n  if (missingHeaders.length) {\n    return {\n      valid: false,\n      reason: WebhookValidationErrorReason.MissingHeaders,\n      missingHeaders,\n    };\n  } else {\n    return {\n      valid: true,\n      ...headerValues,\n      ...(headerValues.subTopic ? {subTopic: headerValues.subTopic} : {}),\n      topic: topicForStorage(headerValues.topic),\n    };\n  }\n}\n", "import {StatusCode} from '@shopify/network';\n\nimport {\n  abstractConvertResponse,\n  AdapterResponse,\n  isOK,\n  NormalizedResponse,\n} from '../../runtime/http';\nimport {ConfigInterface} from '../base-types';\nimport * as ShopifyErrors from '../error';\nimport {logger} from '../logger';\n\nimport {\n  DeliveryMethod,\n  HttpWebhookHandlerWithCallback,\n  WebhookProcessParams,\n  WebhookRegistry,\n  WebhookValidationErrorReason,\n  WebhookValidationInvalid,\n  WebhookValidationMissingHeaders,\n  WebhookValidationValid,\n} from './types';\nimport {validateFactory} from './validate';\n\ninterface HandlerCallResult {\n  statusCode: StatusCode;\n  errorMessage?: string;\n}\n\ninterface ErrorCallResult {\n  statusCode: StatusCode;\n  errorMessage: string;\n}\n\nconst STATUS_TEXT_LOOKUP: Record<string, string> = {\n  [StatusCode.Ok]: 'OK',\n  [StatusCode.BadRequest]: 'Bad Request',\n  [StatusCode.Unauthorized]: 'Unauthorized',\n  [StatusCode.NotFound]: 'Not Found',\n  [StatusCode.InternalServerError]: 'Internal Server Error',\n};\n\nexport function process(\n  config: ConfigInterface,\n  webhookRegistry: WebhookRegistry<HttpWebhookHandlerWithCallback>,\n) {\n  return async function process({\n    context,\n    rawBody,\n    ...adapterArgs\n  }: WebhookProcessParams): Promise<AdapterResponse> {\n    const response: NormalizedResponse = {\n      statusCode: StatusCode.Ok,\n      statusText: STATUS_TEXT_LOOKUP[StatusCode.Ok],\n      headers: {},\n    };\n\n    await logger(config).info('Receiving webhook request');\n\n    const webhookCheck = await validateFactory(config)({\n      rawBody,\n      ...adapterArgs,\n    });\n\n    let errorMessage = 'Unknown error while handling webhook';\n    if (webhookCheck.valid) {\n      const handlerResult = await callWebhookHandlers(\n        config,\n        webhookRegistry,\n        webhookCheck,\n        rawBody,\n        context,\n      );\n\n      response.statusCode = handlerResult.statusCode;\n      if (!isOK(response)) {\n        errorMessage = handlerResult.errorMessage || errorMessage;\n      }\n    } else {\n      const errorResult = await handleInvalidWebhook(config, webhookCheck);\n\n      response.statusCode = errorResult.statusCode;\n      response.statusText = STATUS_TEXT_LOOKUP[response.statusCode];\n      errorMessage = errorResult.errorMessage;\n    }\n\n    const returnResponse = await abstractConvertResponse(response, adapterArgs);\n    if (!isOK(response)) {\n      throw new ShopifyErrors.InvalidWebhookError({\n        message: errorMessage,\n        response: returnResponse,\n      });\n    }\n\n    return Promise.resolve(returnResponse);\n  };\n}\n\nasync function callWebhookHandlers(\n  config: ConfigInterface,\n  webhookRegistry: WebhookRegistry<HttpWebhookHandlerWithCallback>,\n  webhookCheck: WebhookValidationValid,\n  rawBody: string,\n  context: any,\n): Promise<HandlerCallResult> {\n  const log = logger(config);\n  const {hmac: _hmac, valid: _valid, ...loggingContext} = webhookCheck;\n\n  await log.debug(\n    'Webhook request is valid, looking for HTTP handlers to call',\n    loggingContext,\n  );\n\n  const handlers = webhookRegistry[webhookCheck.topic] || [];\n\n  const response: HandlerCallResult = {statusCode: StatusCode.Ok};\n\n  let found = false;\n  for (const handler of handlers) {\n    if (handler.deliveryMethod !== DeliveryMethod.Http) {\n      continue;\n    }\n    if (!handler.callback) {\n      response.statusCode = StatusCode.InternalServerError;\n      response.errorMessage =\n        \"Cannot call webhooks.process with a webhook handler that doesn't have a callback\";\n\n      throw new ShopifyErrors.MissingWebhookCallbackError({\n        message: response.errorMessage,\n        response,\n      });\n    }\n\n    found = true;\n\n    await log.debug('Found HTTP handler, triggering it', loggingContext);\n\n    try {\n      await handler.callback(\n        webhookCheck.topic,\n        webhookCheck.domain,\n        rawBody,\n        webhookCheck.webhookId,\n        webhookCheck.apiVersion,\n        ...(webhookCheck?.subTopic ? webhookCheck.subTopic : ''),\n        context,\n      );\n    } catch (error) {\n      response.statusCode = StatusCode.InternalServerError;\n      response.errorMessage = error.message;\n    }\n  }\n\n  if (!found) {\n    await log.debug('No HTTP handlers found', loggingContext);\n\n    response.statusCode = StatusCode.NotFound;\n    response.errorMessage = `No HTTP webhooks registered for topic ${webhookCheck.topic}`;\n  }\n\n  return response;\n}\n\nasync function handleInvalidWebhook(\n  config: ConfigInterface,\n  webhookCheck: WebhookValidationInvalid,\n): Promise<ErrorCallResult> {\n  const response: ErrorCallResult = {\n    statusCode: StatusCode.InternalServerError,\n    errorMessage: 'Unknown error while handling webhook',\n  };\n\n  switch (webhookCheck.reason) {\n    case WebhookValidationErrorReason.MissingHeaders:\n      response.statusCode = StatusCode.BadRequest;\n      response.errorMessage = `Missing one or more of the required HTTP headers to process webhooks: [${(\n        webhookCheck as WebhookValidationMissingHeaders\n      ).missingHeaders.join(', ')}]`;\n      break;\n    case WebhookValidationErrorReason.MissingBody:\n      response.statusCode = StatusCode.BadRequest;\n      response.errorMessage = 'No body was received when processing webhook';\n      break;\n    case WebhookValidationErrorReason.MissingHmac:\n      response.statusCode = StatusCode.BadRequest;\n      response.errorMessage = `Missing HMAC header in request`;\n      break;\n    case WebhookValidationErrorReason.InvalidHmac:\n      response.statusCode = StatusCode.Unauthorized;\n      response.errorMessage = `Could not validate request HMAC`;\n      break;\n  }\n\n  await logger(config).debug(\n    `Webhook request is invalid, returning ${response.statusCode}: ${response.errorMessage}`,\n  );\n\n  return response;\n}\n", "import {\n  BillingInterval,\n  BillingReplacementBehavior,\n  RecurringBillingIntervals,\n} from '../types';\nimport {Session} from '../session/session';\nimport {\n  FeatureEnabled,\n  FutureFlagOptions,\n  FutureFlags,\n} from '../../future/flags';\n\nexport interface BillingConfigPlan {\n  /**\n   * Amount to charge for this plan.\n   */\n  amount: number;\n  /**\n   * Currency code for this plan.\n   */\n  currencyCode: string;\n}\n\nexport interface BillingConfigOneTimePlan extends BillingConfigPlan {\n  /**\n   * Interval for this plan.\n   *\n   * Must be set to `OneTime`.\n   */\n  interval: BillingInterval.OneTime;\n}\n\nexport interface BillingConfigSubscriptionPlan extends BillingConfigPlan {\n  /**\n   * Recurring interval for this plan.\n   *\n   * Must be either `Every30Days` or `Annual`.\n   */\n  interval: Exclude<RecurringBillingIntervals, BillingInterval.Usage>;\n  /**\n   * How many trial days to give before charging for this plan.\n   */\n  trialDays?: number;\n  /**\n   * The behavior to use when replacing an existing subscription with a new one.\n   */\n  replacementBehavior?: BillingReplacementBehavior;\n  /**\n   * The discount to apply to this plan.\n   */\n  discount?: BillingConfigSubscriptionPlanDiscount;\n}\n\nexport interface BillingConfigSubscriptionPlanDiscountAmount {\n  /**\n   * The amount to discount.\n   *\n   * Cannot be set if `percentage` is set.\n   */\n  amount: number;\n  /**\n   * The percentage to discount.\n   *\n   * Cannot be set if `amount` is set.\n   */\n  percentage?: never;\n}\n\nexport interface BillingConfigSubscriptionPlanDiscountPercentage {\n  /**\n   * The amount to discount.\n   *\n   * Cannot be set if `percentage` is set.\n   */\n  amount?: never;\n  /**\n   * The percentage to discount.\n   *\n   * Cannot be set if `amount` is set.\n   */\n  percentage: number;\n}\n\nexport interface BillingConfigSubscriptionPlanDiscount {\n  /**\n   * The number of intervals to apply the discount for.\n   */\n  durationLimitInIntervals?: number;\n  /**\n   * The discount to apply.\n   */\n  value:\n    | BillingConfigSubscriptionPlanDiscountAmount\n    | BillingConfigSubscriptionPlanDiscountPercentage;\n}\n\nexport interface BillingConfigUsagePlan extends BillingConfigPlan {\n  /**\n   * Interval for this plan.\n   *\n   * Must be set to `Usage`.\n   */\n  interval: BillingInterval.Usage;\n  /**\n   * Usage terms for this plan.\n   */\n  usageTerms: string;\n  /**\n   * How many trial days to give before charging for this plan.\n   */\n  trialDays?: number;\n  /**\n   * The behavior to use when replacing an existing subscription with a new one.\n   */\n  replacementBehavior?: BillingReplacementBehavior;\n}\n\nexport type BillingConfigLegacyItem =\n  | BillingConfigOneTimePlan\n  | BillingConfigSubscriptionPlan\n  | BillingConfigUsagePlan;\n\nexport type BillingConfigItem<\n  Future extends FutureFlagOptions = FutureFlagOptions,\n> =\n  FeatureEnabled<Future, 'lineItemBilling'> extends true\n    ? BillingConfigOneTimePlan | BillingConfigSubscriptionLineItemPlan\n    : BillingConfigLegacyItem;\n\n// Type this as an interface to improve TSDoc support for it.\n\n/**\n * Billing configuration options, indexed by an app-specific plan name.\n */\nexport interface BillingConfig<\n  Future extends FutureFlagOptions = FutureFlagOptions,\n> {\n  /**\n   * An individual billing plan.\n   */\n  [plan: string]: BillingConfigItem<\n    Future & {\n      lineItemBilling: Future extends FutureFlags\n        ? Future['lineItemBilling'] extends true\n          ? true\n          : Future['lineItemBilling'] extends false\n            ? false\n            : Future['v10_lineItemBilling'] extends true\n              ? true\n              : false\n        : false;\n    }\n  >;\n}\n\nexport type RequestConfigOverrides =\n  | Partial<BillingConfigOneTimePlan>\n  | Partial<BillingConfigSubscriptionPlan>\n  | Partial<BillingConfigUsagePlan>;\n\nexport interface BillingConfigLineItem {\n  /**\n   * The amount to charge for this line item.\n   */\n  amount: number;\n  /**\n   * The currency code for this line item.\n   */\n  currencyCode: string;\n}\n\nexport interface BillingConfigRecurringLineItem extends BillingConfigLineItem {\n  /**\n   * The recurring interval for this line item.\n   *\n   * Must be either `Every30Days` or `Annual`.\n   */\n  interval: BillingInterval.Every30Days | BillingInterval.Annual;\n  /**\n   * An optional discount to apply for this line item.\n   */\n  discount?: BillingConfigSubscriptionPlanDiscount;\n}\n\nexport interface BillingConfigUsageLineItem extends BillingConfigLineItem {\n  /**\n   * The usage interval for this line item.\n   *\n   * Must be set to `Usage`.\n   */\n  interval: BillingInterval.Usage;\n  /**\n   * The capped amount or the maximum amount to be charged in the interval.\n   */\n  amount: number;\n  /**\n   * Usage terms for this line item.\n   */\n  terms: string;\n}\n\nexport interface BillingConfigSubscriptionLineItemPlan {\n  /**\n   * The replacement behavior to use for this plan.\n   */\n  replacementBehavior?: BillingReplacementBehavior;\n  /**\n   * How many trial days to give before charging for this plan.\n   */\n  trialDays?: number;\n  /**\n   * The line items for this plan.\n   */\n  lineItems: (BillingConfigRecurringLineItem | BillingConfigUsageLineItem)[];\n}\n\ntype DeepPartial<T> = T extends object\n  ? {[P in keyof T]?: DeepPartial<T[P]>}\n  : T;\nexport type RequestConfigLineItemOverrides =\n  DeepPartial<BillingConfigSubscriptionLineItemPlan>;\n\ninterface BillingCheckParamsNew {\n  /**\n   * The session to use for this check.\n   */\n  session: Session;\n  /**\n   * The plans to accept for this check.\n   */\n  plans?: string[] | string;\n  /**\n   * Whether to include charges that were created on test mode. Test shops and demo shops cannot be charged.\n   */\n  isTest?: boolean;\n}\n\ninterface BillingCheckParamsOld extends BillingCheckParamsNew {\n  /**\n   * The plans to accept for this check.\n   */\n  plans: string[] | string;\n  /**\n   * Whether to return the full response object.\n   */\n  returnObject?: boolean;\n}\n\nexport type BillingCheckParams<\n  Future extends FutureFlagOptions = FutureFlagOptions,\n> =\n  FeatureEnabled<Future, 'unstable_managedPricingSupport'> extends true\n    ? BillingCheckParamsNew\n    : BillingCheckParamsOld;\n\nexport interface BillingCheckResponseObject {\n  /**\n   * Whether the user has an active payment method.\n   */\n  hasActivePayment: boolean;\n  /**\n   * The one-time purchases the shop has.\n   */\n  oneTimePurchases: OneTimePurchase[];\n  /**\n   * The active subscriptions the shop has.\n   */\n  appSubscriptions: AppSubscription[];\n}\n\nexport type BillingCheckResponse<\n  Params extends BillingCheckParams<Future>,\n  Future extends FutureFlagOptions = FutureFlagOptions,\n> =\n  FeatureEnabled<Future, 'unstable_managedPricingSupport'> extends true\n    ? BillingCheckResponseObject\n    : Params extends BillingCheckParamsOld\n      ? Params['returnObject'] extends true\n        ? BillingCheckResponseObject\n        : boolean\n      : never;\n\ntype BillingRequestOverridesType<\n  Future extends FutureFlagOptions = FutureFlagOptions,\n> =\n  FeatureEnabled<Future, 'lineItemBilling'> extends true\n    ? RequestConfigOverrides & RequestConfigLineItemOverrides\n    : RequestConfigOverrides;\n\nexport type BillingRequestParams<\n  Future extends FutureFlagOptions = FutureFlagOptions,\n> = {\n  /**\n   * The session to use for this request.\n   */\n  session: Session;\n  /**\n   * The plan to request.\n   */\n  plan: string;\n  /**\n   * Whether this is a test purchase.\n   */\n  isTest?: boolean;\n  /**\n   * Override the return URL after the purchase is complete.\n   */\n  returnUrl?: string;\n  /**\n   * Whether to return the full response object.\n   */\n  returnObject?: boolean;\n} & BillingRequestOverridesType<Future>;\n\nexport interface BillingRequestResponseObject {\n  /**\n   * The confirmation URL for this request.\n   */\n  confirmationUrl: string;\n  /**\n   * The one-time purchase created by this request.\n   */\n  oneTimePurchase?: OneTimePurchase;\n  /**\n   * The app subscription created by this request.\n   */\n  appSubscription?: AppSubscription;\n}\n\nexport type BillingRequestResponse<Params extends BillingRequestParams> =\n  Params['returnObject'] extends true ? BillingRequestResponseObject : string;\n\nexport interface BillingCancelParams {\n  /**\n   * The session to use for this request.\n   */\n  session: Session;\n  /**\n   * The subscription ID to cancel.\n   */\n  subscriptionId: string;\n  /**\n   * Whether to prorate the cancellation.\n   */\n  prorate?: boolean;\n  /**\n   * Whether to consider test purchases.\n   */\n  isTest?: boolean;\n}\n\nexport interface BillingSubscriptionParams {\n  /**\n   * The session to use for this request.\n   */\n  session: Session;\n}\n\nexport interface AppSubscription {\n  /**\n   * The ID of the app subscription.\n   */\n  id: string;\n  /**\n   * The name of the purchased plan.\n   */\n  name: string;\n  /**\n   * Whether this is a test subscription.\n   */\n  test: boolean;\n  /**\n   * The number of trial days for this subscription.\n   */\n  trialDays: number;\n  /**\n   * The date and time when the subscription was created.\n   */\n  createdAt: string;\n  /**\n   * The date and time when the current period ends.\n   */\n  currentPeriodEnd: string;\n  /**\n   * The return URL for this subscription.\n   */\n  returnUrl: string;\n\n  /*\n   * The line items for this plan. This will become mandatory in v10.\n   */\n  lineItems?: ActiveSubscriptionLineItem[];\n\n  /*\n   * The status of the subscription. [ACTIVE, CANCELLED, PENDING, DECLINED, EXPIRED, FROZEN, ACCEPTED]\n   */\n  status:\n    | 'ACTIVE'\n    | 'CANCELLED'\n    | 'PENDING'\n    | 'DECLINED'\n    | 'EXPIRED'\n    | 'FROZEN'\n    | 'ACCEPTED';\n}\n\nexport interface ActiveSubscriptions {\n  activeSubscriptions: AppSubscription[];\n}\n\nexport interface ActiveSubscriptionLineItem {\n  /*\n   * The ID of the line item.\n   */\n  id: string;\n  /*\n   * The details of the plan.\n   */\n  plan: AppPlan;\n}\n\nexport interface RecurringAppPlan {\n  /*\n   * The interval for this plan is charged on.\n   */\n  interval: BillingInterval.Every30Days | BillingInterval.Annual;\n  /*\n   * The price of the plan.\n   */\n  price: Money;\n  /*\n   * The discount applied to the plan.\n   */\n  discount: AppPlanDiscount;\n}\n\nexport interface UsageAppPlan {\n  /*\n   * The total usage records for interval.\n   */\n  balanceUsed: Money;\n  /*\n   * The capped amount prevents the merchant from being charged for any usage over that amount during a billing period.\n   */\n  cappedAmount: Money;\n  /*\n   * The terms and conditions for app usage pricing.\n   */\n  terms: string;\n}\n\nexport interface Money {\n  amount: number;\n  currencyCode: string;\n}\n\nexport interface AppPlanDiscount {\n  /*\n   * The total number of intervals the discount applies to.\n   */\n  durationLimitInIntervals: number;\n  /*\n   * The remaining number of intervals the discount applies to.\n   */\n  remainingDurationInIntervals: number;\n  /*\n   * The price after the discount is applied.\n   */\n  priceAfterDiscount: Money;\n  /*\n   * The value of the discount applied every billing interval.\n   */\n  value: AppPlanDiscountAmount;\n}\n\nexport interface AppSubscriptionLineItemUpdatePayload {\n  userErrors: string[];\n  confirmationUrl: string;\n  appSubscription: AppSubscription;\n}\n\nexport type UpdateCappedAmountConfirmation = Omit<\n  AppSubscriptionLineItemUpdatePayload,\n  'userErrors'\n>;\n\ntype AppPlanDiscountAmount =\n  | BillingConfigSubscriptionPlanDiscountAmount\n  | BillingConfigSubscriptionPlanDiscountPercentage;\n\nexport interface AppPlan {\n  /*\n   * The pricing details of the plan.\n   */\n  pricingDetails: RecurringAppPlan | UsageAppPlan;\n}\nexport interface OneTimePurchase {\n  /**\n   * The ID of the one-time purchase.\n   */\n  id: string;\n  /**\n   * The name of the purchased plan.\n   */\n  name: string;\n  /**\n   * Whether this is a test purchase.\n   */\n  test: boolean;\n  /*\n   * The status of the subscription. [ACTIVE, CANCELLED, PENDING, DECLINED, EXPIRED, FROZEN, ACCEPTED]\n   */\n  status:\n    | 'ACTIVE'\n    | 'CANCELLED'\n    | 'PENDING'\n    | 'DECLINED'\n    | 'EXPIRED'\n    | 'FROZEN'\n    | 'ACCEPTED';\n}\n\nexport interface BillingCreateUsageRecordParams {\n  /**\n   * The session to use for this request.\n   */\n  session: Session;\n  /**\n   * The description of the usage record.\n   */\n  description: string;\n  /**\n   * The price and currency of the usage record.\n   */\n  price: {\n    /**\n     * The amount to charge for this usage record.\n     */\n    amount: number;\n    /**\n     * The currency code for this usage record.\n     */\n    currencyCode: string;\n  };\n  /**\n   * The subscription line item ID to associate the usage record with.\n   */\n  subscriptionLineItemId?: string;\n  /**\n   * The idempotency key for this request.\n   */\n  idempotencyKey?: string;\n  /**\n   * Whether this is a test charge.\n   * */\n  isTest?: boolean;\n}\n\nexport interface UsageRecord {\n  /**\n   * The ID of the usage record.\n   */\n  id: string;\n  /**\n   * The description of the usage record.\n   */\n  description: string;\n  /**\n   * The price and currency of the usage record.\n   */\n  price: {\n    /**\n     * The amount to charge for this usage record.\n     */\n    amount: number;\n    /**\n     * The currency code for this usage record.\n     */\n    currencyCode: string;\n  };\n  /**\n   * The subscription line item associated with the usage record.\n   */\n  plan: ActiveSubscriptionLineItem;\n  /**\n   * The idempotency key for this request.\n   */\n  idempotencyKey?: string;\n  /**\n   * The subscription line item associated with the usage record.\n   */\n  subscriptionLineItem: AppSubscriptionLineItem;\n}\n\nexport interface AppSubscriptionLineItem {\n  /**\n   * The ID of the subscription line item.\n   */\n  id: string;\n  /**\n   * The plan associated with the subscription line item.\n   */\n  plan: AppPlan;\n}\n\nexport interface BillingUpdateUsageCappedAmountParams {\n  /**\n   * The session to use for this request.\n   */\n  session: Session;\n  /**\n   * The subscription line item ID to update.\n   */\n  subscriptionLineItemId: string;\n  /**\n   * The maximum charge for the usage billing plan.\n   */\n  cappedAmount: {\n    /**\n     * The amount to update.\n     */\n    amount: number;\n    /**\n     * The currency code to update.\n     */\n    currencyCode: string;\n  };\n}\n\ninterface OneTimePurchases {\n  oneTimePurchases: {\n    edges: {\n      node: OneTimePurchase;\n    }[];\n    pageInfo: {\n      endCursor: string;\n      hasNextPage: boolean;\n    };\n  };\n}\n\nexport type CurrentAppInstallation = OneTimePurchases & ActiveSubscriptions;\n\nexport interface CurrentAppInstallations {\n  currentAppInstallation?: CurrentAppInstallation;\n}\n\nexport interface RequestResponse {\n  userErrors: string[];\n  confirmationUrl: string;\n}\n\ninterface AppSubscriptionCreate {\n  userErrors: string[];\n  confirmationUrl: string;\n  appSubscription: AppSubscription;\n}\n\ninterface AppPurchaseOneTimeCreate {\n  userErrors: string[];\n  confirmationUrl: string;\n  oneTimePurchase: OneTimePurchase;\n}\n\nexport interface RecurringPaymentResponse {\n  appSubscriptionCreate?: AppSubscriptionCreate;\n}\n\nexport interface SinglePaymentResponse {\n  appPurchaseOneTimeCreate?: AppPurchaseOneTimeCreate;\n}\n\nexport type RequestResponseData =\n  | AppSubscriptionCreate\n  | AppPurchaseOneTimeCreate;\n\nexport interface SubscriptionResponse {\n  currentAppInstallation?: ActiveSubscriptions;\n}\n\nexport interface CancelResponse {\n  appSubscriptionCancel?: {\n    appSubscription: AppSubscription;\n    userErrors: string[];\n  };\n}\n\nexport interface UsageRecordCreateResponse {\n  appUsageRecordCreate?: {\n    appUsageRecord: UsageRecord;\n    userErrors: string[];\n  };\n}\n\nexport interface BillingUpdateUsageCappedAmountResponse {\n  appSubscriptionLineItemUpdate?: AppSubscriptionLineItemUpdatePayload;\n}\n\nexport type BillingCheck<Future extends FutureFlagOptions> = <\n  Params extends BillingCheckParams<Future>,\n>(\n  params: Params,\n) => Promise<BillingCheckResponse<Params, Future>>;\n\nexport type BillingRequest = <Params extends BillingRequestParams>(\n  params: Params,\n) => Promise<BillingRequestResponse<Params>>;\n\nexport type BillingCancel = (\n  params: BillingCancelParams,\n) => Promise<AppSubscription>;\n\nexport type BillingSubscriptions = (\n  params: BillingSubscriptionParams,\n) => Promise<ActiveSubscriptions>;\n\nexport type BillingCreateUsageRecord = (\n  params: BillingCreateUsageRecordParams,\n) => Promise<UsageRecord>;\n\nexport type BillingUpdateUsageCappedAmount = (\n  params: BillingUpdateUsageCappedAmountParams,\n) => Promise<UpdateCappedAmountConfirmation>;\n\nexport interface ShopifyBilling<Future extends FutureFlagOptions> {\n  check: BillingCheck<Future>;\n  request: BillingRequest;\n  cancel: BillingCancel;\n  subscriptions: BillingSubscriptions;\n  createUsageRecord: BillingCreateUsageRecord;\n  updateUsageCappedAmount: BillingUpdateUsageCappedAmount;\n}\n\nexport const APP_SUBSCRIPTION_FRAGMENT = `\n  fragment AppSubscriptionFragment on AppSubscription {\n    id\n    name\n    test\n    status\n    trialDays\n    createdAt\n    currentPeriodEnd\n    returnUrl\n    lineItems {\n      id\n      plan {\n        pricingDetails {\n          ... on AppRecurringPricing {\n            price {\n              amount\n              currencyCode\n            }\n            interval\n            discount {\n              durationLimitInIntervals\n              remainingDurationInIntervals\n              priceAfterDiscount {\n                amount\n              }\n              value {\n                ... on AppSubscriptionDiscountAmount {\n                  amount {\n                    amount\n                    currencyCode\n                  }\n                }\n                ... on AppSubscriptionDiscountPercentage {\n                  percentage\n                }\n              }\n            }\n          }\n          ... on AppUsagePricing {\n            balanceUsed {\n              amount\n              currencyCode\n            }\n            cappedAmount {\n              amount\n              currencyCode\n            }\n            terms\n          }\n        }\n      }\n    }\n  }\n`;\n", "import {FutureFlagOptions} from '../../future/flags';\nimport {ConfigInterface} from '../base-types';\nimport {graphqlClientClass, GraphqlClient} from '../clients/admin';\nimport {BillingError} from '../error';\n\nimport {\n  AppSubscription,\n  BillingCheck,\n  BillingCheckParams,\n  BillingCheckResponse,\n  BillingCheckResponseObject,\n  CurrentAppInstallation,\n  CurrentAppInstallations,\n  OneTimePurchase,\n  APP_SUBSCRIPTION_FRAGMENT,\n} from './types';\nimport {convertLineItems} from './utils';\n\ninterface SubscriptionMeetsCriteriaParams {\n  subscription: AppSubscription;\n  isTest?: boolean;\n  plans?: string | string[];\n}\n\ninterface PurchaseMeetsCriteriaParams {\n  purchase: OneTimePurchase;\n  isTest?: boolean;\n  plans?: string | string[];\n}\n\ninterface InternalParams {\n  client: GraphqlClient;\n  isTest?: boolean;\n  plans?: string | string[];\n}\n\nexport function check<\n  Config extends ConfigInterface,\n  Future extends FutureFlagOptions = Config['future'],\n>(config: Config): BillingCheck<Future> {\n  return async function check<Params extends BillingCheckParams<Future>>(\n    params: Params,\n  ): Promise<BillingCheckResponse<Params, Future>> {\n    if (!config.future?.unstable_managedPricingSupport && !config.billing) {\n      throw new BillingError({\n        message: 'Attempted to look for purchases without billing configs',\n        errorData: [],\n      });\n    }\n\n    const {session, isTest = true, plans} = params;\n    const returnObject =\n      (params as BillingCheckParams<{unstable_managedPricingSupport: false}>)\n        .returnObject ?? false;\n\n    const GraphqlClient = graphqlClientClass({config});\n    const client = new GraphqlClient({session});\n\n    const payments = await assessPayments({client, isTest, plans});\n\n    if (config.future?.unstable_managedPricingSupport || returnObject) {\n      return payments as BillingCheckResponse<Params, Future>;\n    } else {\n      return payments.hasActivePayment as BillingCheckResponse<Params, Future>;\n    }\n  };\n}\n\nexport async function assessPayments({\n  client,\n  isTest,\n  plans,\n}: InternalParams): Promise<BillingCheckResponseObject> {\n  const returnValue: BillingCheckResponseObject = {\n    hasActivePayment: false,\n    oneTimePurchases: [],\n    appSubscriptions: [],\n  };\n\n  let installation: CurrentAppInstallation;\n  let endCursor: string | null = null;\n  do {\n    const currentInstallations = await client.request<CurrentAppInstallations>(\n      HAS_PAYMENTS_QUERY,\n      {variables: {endCursor}},\n    );\n\n    installation = currentInstallations.data?.currentAppInstallation!;\n    installation.activeSubscriptions.forEach((subscription) => {\n      if (subscriptionMeetsCriteria({subscription, isTest, plans})) {\n        returnValue.hasActivePayment = true;\n        if (subscription.lineItems) {\n          subscription.lineItems = convertLineItems(subscription.lineItems);\n        }\n        returnValue.appSubscriptions.push(subscription);\n      }\n    });\n    installation.oneTimePurchases.edges.forEach(({node: purchase}) => {\n      if (purchaseMeetsCriteria({purchase, isTest, plans})) {\n        returnValue.hasActivePayment = true;\n        returnValue.oneTimePurchases.push(purchase);\n      }\n    });\n\n    endCursor = installation.oneTimePurchases.pageInfo.endCursor;\n  } while (installation?.oneTimePurchases.pageInfo.hasNextPage);\n\n  return returnValue;\n}\n\nfunction subscriptionMeetsCriteria({\n  subscription,\n  isTest,\n  plans,\n}: SubscriptionMeetsCriteriaParams): boolean {\n  return (\n    (typeof plans === 'undefined' || plans.includes(subscription.name)) &&\n    (isTest || !subscription.test)\n  );\n}\n\nfunction purchaseMeetsCriteria({\n  purchase,\n  isTest,\n  plans,\n}: PurchaseMeetsCriteriaParams): boolean {\n  return (\n    (typeof plans === 'undefined' || plans.includes(purchase.name)) &&\n    (isTest || !purchase.test) &&\n    purchase.status === 'ACTIVE'\n  );\n}\n\nconst HAS_PAYMENTS_QUERY = `\n  ${APP_SUBSCRIPTION_FRAGMENT}\n  query appSubscription($endCursor: String) {\n    currentAppInstallation {\n      activeSubscriptions {\n        ...AppSubscriptionFragment\n      }\n      oneTimePurchases(first: 250, sortKey: CREATED_AT, after: $endCursor) {\n        edges {\n          node {\n            id\n            name\n            test\n            status\n          }\n        }\n        pageInfo {\n          hasNextPage\n          endCursor\n        }\n      }\n    }\n  }\n`;\n", "import {ConfigInterface, ConfigParams} from '../base-types';\nimport {BillingInterval} from '../types';\nimport {BillingError} from '../error';\nimport {buildEmbeddedAppUrl} from '../auth/get-embedded-app-url';\nimport {GraphqlClient, graphqlClientClass} from '../clients/admin';\nimport {hashString} from '../../runtime/crypto';\nimport {HashFormat} from '../../runtime/crypto/types';\nimport {FutureFlagOptions} from '../../future/flags';\n\nimport {\n  BillingConfigSubscriptionPlan,\n  BillingConfigOneTimePlan,\n  BillingConfigUsagePlan,\n  BillingRequestParams,\n  BillingRequestResponse,\n  RecurringPaymentResponse,\n  RequestResponseData,\n  SinglePaymentResponse,\n  BillingConfigSubscriptionLineItemPlan,\n  RequestConfigLineItemOverrides,\n  BillingRequest,\n  APP_SUBSCRIPTION_FRAGMENT,\n} from './types';\n\nconst RECURRING_PURCHASE_MUTATION = `\n  ${APP_SUBSCRIPTION_FRAGMENT}\n  mutation AppSubscriptionCreate(\n    $name: String!\n    $returnUrl: URL!\n    $test: Boolean\n    $trialDays: Int\n    $replacementBehavior: AppSubscriptionReplacementBehavior\n    $lineItems: [AppSubscriptionLineItemInput!]!\n  ) {\n    appSubscriptionCreate(\n      name: $name\n      returnUrl: $returnUrl\n      test: $test\n      trialDays: $trialDays\n      replacementBehavior: $replacementBehavior\n      lineItems: $lineItems\n    ) {\n      appSubscription {\n        ...AppSubscriptionFragment\n      }\n      confirmationUrl\n      userErrors {\n        field\n        message\n      }\n    }\n  }\n`;\n\nconst ONE_TIME_PURCHASE_MUTATION = `\n  mutation test(\n    $name: String!\n    $price: MoneyInput!\n    $returnUrl: URL!\n    $test: Boolean\n  ) {\n    appPurchaseOneTimeCreate(\n      name: $name\n      price: $price\n      returnUrl: $returnUrl\n      test: $test\n    ) {\n      appPurchaseOneTime {\n        id\n        name\n        test\n      }\n      confirmationUrl\n      userErrors {\n        field\n        message\n      }\n    }\n  }\n`;\n\ninterface RequestInternalParams {\n  client: GraphqlClient;\n  plan: string;\n  returnUrl: string;\n  isTest: boolean;\n}\n\ninterface RequestSubscriptionInternalParams extends RequestInternalParams {\n  billingConfig: BillingConfigSubscriptionPlan;\n}\n\ninterface RequestOneTimePaymentInternalParams extends RequestInternalParams {\n  billingConfig: BillingConfigOneTimePlan;\n}\n\ninterface RequestUsageSubscriptionInternalParams extends RequestInternalParams {\n  billingConfig: BillingConfigUsagePlan;\n}\n\ninterface RequestSubscriptionParams extends RequestInternalParams {\n  billingConfig: BillingConfigSubscriptionLineItemPlan;\n}\n\nexport function request<\n  Config extends ConfigInterface<Params>,\n  Params extends ConfigParams<any, Future>,\n  Future extends FutureFlagOptions,\n>(config: Config): BillingRequest {\n  return async function <Params extends BillingRequestParams>({\n    session,\n    plan,\n    isTest = true,\n    returnUrl: returnUrlParam,\n    returnObject = false,\n    ...overrides\n  }: Params): Promise<BillingRequestResponse<Params>> {\n    if (!config.billing || !config.billing[plan]) {\n      throw new BillingError({\n        message: `Could not find plan ${plan} in billing settings`,\n        errorData: [],\n      });\n    }\n\n    const billingConfig = {\n      ...config.billing[plan],\n    };\n    const filteredOverrides = Object.fromEntries(\n      Object.entries(overrides).filter(([_key, value]) => value !== undefined),\n    );\n\n    const cleanShopName = session.shop.replace('.myshopify.com', '');\n    const embeddedAppUrl = buildEmbeddedAppUrl(config)(\n      hashString(`admin.shopify.com/store/${cleanShopName}`, HashFormat.Base64),\n    );\n\n    const appUrl = `${config.hostScheme}://${config.hostName}?shop=${session.shop}`;\n\n    // if provided a return URL, use it, otherwise use the embedded app URL or hosted app URL\n    const returnUrl =\n      returnUrlParam || (config.isEmbeddedApp ? embeddedAppUrl : appUrl);\n\n    const GraphqlClient = graphqlClientClass({config});\n    const client = new GraphqlClient({session});\n\n    function isLineItemPlan(\n      billingConfig: any,\n    ): billingConfig is BillingConfigSubscriptionLineItemPlan {\n      return 'lineItems' in billingConfig;\n    }\n\n    function isOneTimePlan(\n      billingConfig: any,\n    ): billingConfig is BillingConfigOneTimePlan {\n      return billingConfig.interval === BillingInterval.OneTime;\n    }\n\n    let data: RequestResponseData;\n    if (isLineItemPlan(billingConfig)) {\n      const mergedBillingConfigs = mergeBillingConfigs(\n        billingConfig,\n        filteredOverrides,\n      );\n      const mutationRecurringResponse = await requestSubscriptionPayment({\n        billingConfig: mergedBillingConfigs,\n        plan,\n        client,\n        returnUrl,\n        isTest,\n      });\n\n      data = mutationRecurringResponse.appSubscriptionCreate!;\n    } else if (isOneTimePlan(billingConfig)) {\n      const mutationOneTimeResponse = await requestSinglePayment({\n        billingConfig: {...billingConfig, ...filteredOverrides},\n        plan,\n        client,\n        returnUrl,\n        isTest,\n      });\n      data = mutationOneTimeResponse.appPurchaseOneTimeCreate!;\n    } else {\n      switch (billingConfig.interval) {\n        case BillingInterval.Usage: {\n          const mutationUsageResponse = await requestUsagePayment({\n            billingConfig: {...billingConfig, ...filteredOverrides},\n            plan,\n            client,\n            returnUrl,\n            isTest,\n          });\n          data = mutationUsageResponse.appSubscriptionCreate!;\n          break;\n        }\n        default: {\n          const mutationRecurringResponse = await requestRecurringPayment({\n            billingConfig: {...billingConfig, ...filteredOverrides},\n            plan,\n            client,\n            returnUrl,\n            isTest,\n          });\n          data = mutationRecurringResponse.appSubscriptionCreate!;\n        }\n      }\n    }\n\n    if (data.userErrors?.length) {\n      throw new BillingError({\n        message: 'Error while billing the store',\n        errorData: data.userErrors,\n      });\n    }\n\n    if (returnObject) {\n      return data as Omit<\n        RequestResponseData,\n        'userErrors'\n      > as BillingRequestResponse<Params>;\n    } else {\n      return data.confirmationUrl as BillingRequestResponse<Params>;\n    }\n  };\n}\n\nasync function requestSubscriptionPayment({\n  billingConfig,\n  plan,\n  client,\n  returnUrl,\n  isTest,\n}: RequestSubscriptionParams): Promise<RecurringPaymentResponse> {\n  const lineItems = billingConfig.lineItems.map((item) => {\n    if (\n      item.interval === BillingInterval.Every30Days ||\n      item.interval === BillingInterval.Annual\n    ) {\n      const appRecurringPricingDetails: any = {\n        interval: item.interval,\n        price: {\n          amount: item.amount,\n          currencyCode: item.currencyCode,\n        },\n      };\n\n      if (item.discount) {\n        appRecurringPricingDetails.discount = {\n          durationLimitInIntervals: item.discount.durationLimitInIntervals,\n          value: {\n            amount: item.discount.value.amount,\n            percentage: item.discount.value.percentage,\n          },\n        };\n      }\n\n      return {\n        plan: {\n          appRecurringPricingDetails,\n        },\n      };\n    } else if (item.interval === BillingInterval.Usage) {\n      const appUsagePricingDetails = {\n        terms: item.terms,\n        cappedAmount: {\n          amount: item.amount,\n          currencyCode: item.currencyCode,\n        },\n      };\n\n      return {\n        plan: {\n          appUsagePricingDetails,\n        },\n      };\n    } else {\n      throw new BillingError({\n        message: 'Invalid interval provided',\n        errorData: [item],\n      });\n    }\n  });\n\n  const mutationResponse = await client.request<RecurringPaymentResponse>(\n    RECURRING_PURCHASE_MUTATION,\n    {\n      variables: {\n        name: plan,\n        trialDays: billingConfig.trialDays,\n        replacementBehavior: billingConfig.replacementBehavior,\n        returnUrl,\n        test: isTest,\n        lineItems,\n      },\n    },\n  );\n\n  if (mutationResponse.errors) {\n    throw new BillingError({\n      message: 'Error while billing the store',\n      errorData: mutationResponse.errors,\n    });\n  }\n\n  return mutationResponse.data!;\n}\n\nasync function requestRecurringPayment({\n  billingConfig,\n  plan,\n  client,\n  returnUrl,\n  isTest,\n}: RequestSubscriptionInternalParams): Promise<RecurringPaymentResponse> {\n  const mutationResponse = await client.request<RecurringPaymentResponse>(\n    RECURRING_PURCHASE_MUTATION,\n    {\n      variables: {\n        name: plan,\n        returnUrl,\n        test: isTest,\n        trialDays: billingConfig.trialDays,\n        replacementBehavior: billingConfig.replacementBehavior,\n        lineItems: [\n          {\n            plan: {\n              appRecurringPricingDetails: {\n                interval: billingConfig.interval,\n                price: {\n                  amount: billingConfig.amount,\n                  currencyCode: billingConfig.currencyCode,\n                },\n                discount: billingConfig.discount\n                  ? {\n                      durationLimitInIntervals:\n                        billingConfig.discount?.durationLimitInIntervals,\n                      value: {\n                        amount: billingConfig.discount?.value?.amount,\n                        percentage: billingConfig.discount?.value?.percentage,\n                      },\n                    }\n                  : undefined,\n              },\n            },\n          },\n        ],\n      },\n    },\n  );\n\n  if (mutationResponse.data?.appSubscriptionCreate?.userErrors.length) {\n    throw new BillingError({\n      message: 'Error while creating a subscription',\n      errorData: mutationResponse.data?.appSubscriptionCreate?.userErrors,\n    });\n  }\n\n  return mutationResponse.data!;\n}\n\nasync function requestUsagePayment({\n  billingConfig,\n  plan,\n  client,\n  returnUrl,\n  isTest,\n}: RequestUsageSubscriptionInternalParams): Promise<RecurringPaymentResponse> {\n  const mutationResponse = await client.request<RecurringPaymentResponse>(\n    RECURRING_PURCHASE_MUTATION,\n    {\n      variables: {\n        name: plan,\n        returnUrl,\n        test: isTest,\n        trialDays: billingConfig.trialDays,\n        replacementBehavior: billingConfig.replacementBehavior,\n        lineItems: [\n          {\n            plan: {\n              appUsagePricingDetails: {\n                terms: billingConfig.usageTerms,\n                cappedAmount: {\n                  amount: billingConfig.amount,\n                  currencyCode: billingConfig.currencyCode,\n                },\n              },\n            },\n          },\n        ],\n      },\n    },\n  );\n\n  if (mutationResponse.data?.appSubscriptionCreate?.userErrors.length) {\n    throw new BillingError({\n      message: 'Error while creating a subscription',\n      errorData: mutationResponse.data?.appSubscriptionCreate?.userErrors,\n    });\n  }\n\n  return mutationResponse.data!;\n}\n\nasync function requestSinglePayment({\n  billingConfig,\n  plan,\n  client,\n  returnUrl,\n  isTest,\n}: RequestOneTimePaymentInternalParams): Promise<SinglePaymentResponse> {\n  const mutationResponse = await client.request<SinglePaymentResponse>(\n    ONE_TIME_PURCHASE_MUTATION,\n    {\n      variables: {\n        name: plan,\n        returnUrl,\n        test: isTest,\n        price: {\n          amount: billingConfig.amount,\n          currencyCode: billingConfig.currencyCode,\n        },\n      },\n    },\n  );\n\n  if (mutationResponse.errors) {\n    throw new BillingError({\n      message: 'Error while billing the store',\n      errorData: mutationResponse.errors,\n    });\n  }\n\n  return mutationResponse.data!;\n}\n\nfunction mergeBillingConfigs(\n  billingConfig: BillingConfigSubscriptionLineItemPlan,\n  overrides: RequestConfigLineItemOverrides,\n): BillingConfigSubscriptionLineItemPlan {\n  const mergedConfig = {...billingConfig, ...overrides};\n  const mergedLineItems = [];\n\n  if (billingConfig.lineItems && overrides.lineItems) {\n    for (const i of billingConfig.lineItems) {\n      let found = false;\n\n      for (const j of overrides.lineItems) {\n        if (i.interval === j!.interval) {\n          mergedLineItems.push({...i, ...j});\n          found = true;\n          break;\n        }\n      }\n\n      if (!found) {\n        mergedLineItems.push(i);\n      }\n    }\n\n    mergedConfig.lineItems = mergedLineItems;\n  }\n\n  return mergedConfig as BillingConfigSubscriptionLineItemPlan;\n}\n", "import {ConfigInterface} from '../base-types';\nimport {graphqlClientClass} from '../clients/admin';\nimport {BillingError, GraphqlQueryError} from '../error';\n\nimport {\n  AppSubscription,\n  BillingCancel,\n  BillingCancelParams,\n  CancelResponse,\n  APP_SUBSCRIPTION_FRAGMENT,\n} from './types';\n\nconst CANCEL_MUTATION = `\n  ${APP_SUBSCRIPTION_FRAGMENT}\n  mutation appSubscriptionCancel($id: ID!, $prorate: Boolean) {\n    appSubscriptionCancel(id: $id, prorate: $prorate) {\n      appSubscription {\n        ...AppSubscriptionFragment\n      }\n      userErrors {\n        field\n        message\n      }\n    }\n  }\n`;\n\nexport function cancel(config: ConfigInterface): BillingCancel {\n  return async function (\n    subscriptionInfo: BillingCancelParams,\n  ): Promise<AppSubscription> {\n    const {session, subscriptionId, prorate = true} = subscriptionInfo;\n\n    const GraphqlClient = graphqlClientClass({config});\n    const client = new GraphqlClient({session});\n\n    try {\n      const response = await client.request<CancelResponse>(CANCEL_MUTATION, {\n        variables: {id: subscriptionId, prorate},\n      });\n\n      if (response.data?.appSubscriptionCancel?.userErrors.length) {\n        throw new BillingError({\n          message: 'Error while canceling a subscription',\n          errorData: response.data?.appSubscriptionCancel?.userErrors,\n        });\n      }\n\n      return response.data?.appSubscriptionCancel?.appSubscription!;\n    } catch (error) {\n      if (error instanceof GraphqlQueryError) {\n        throw new BillingError({\n          message: error.message,\n          errorData: error.response?.errors,\n        });\n      } else {\n        throw error;\n      }\n    }\n  };\n}\n", "import {BillingError} from '../error';\nimport {ConfigInterface} from '../base-types';\nimport {graphqlClientClass} from '../clients/admin';\n\nimport {\n  ActiveSubscriptions,\n  BillingSubscriptionParams,\n  BillingSubscriptions,\n  SubscriptionResponse,\n  APP_SUBSCRIPTION_FRAGMENT,\n} from './types';\nimport {convertLineItems} from './utils';\n\nconst SUBSCRIPTION_QUERY = `\n${APP_SUBSCRIPTION_FRAGMENT}\nquery appSubscription {\n  currentAppInstallation {\n    activeSubscriptions {\n      ...AppSubscriptionFragment\n    }\n  }\n}\n`;\n\nexport function subscriptions(config: ConfigInterface): BillingSubscriptions {\n  return async function ({\n    session,\n  }: BillingSubscriptionParams): Promise<ActiveSubscriptions> {\n    if (!config.future?.unstable_managedPricingSupport && !config.billing) {\n      throw new BillingError({\n        message: 'Attempted to look for purchases without billing configs',\n        errorData: [],\n      });\n    }\n\n    const GraphqlClient = graphqlClientClass({config});\n    const client = new GraphqlClient({session});\n\n    const response =\n      await client.request<SubscriptionResponse>(SUBSCRIPTION_QUERY);\n\n    if (!response.data?.currentAppInstallation?.activeSubscriptions) {\n      return {activeSubscriptions: []};\n    }\n\n    const activeSubscriptions =\n      response.data.currentAppInstallation.activeSubscriptions;\n    activeSubscriptions.forEach((subscription) => {\n      if (subscription.lineItems) {\n        subscription.lineItems = convertLineItems(subscription.lineItems);\n      }\n    });\n\n    return {\n      activeSubscriptions,\n    };\n  };\n}\n", "import {BillingError, GraphqlQueryError} from '../error';\nimport {ConfigInterface} from '../base-types';\nimport {graphqlClientClass} from '../clients/admin';\n\nimport {\n  BillingUpdateUsageCappedAmount,\n  BillingUpdateUsageCappedAmountParams,\n  BillingUpdateUsageCappedAmountResponse,\n  UpdateCappedAmountConfirmation,\n  APP_SUBSCRIPTION_FRAGMENT,\n} from './types';\nimport {convertLineItems} from './utils';\n\nconst UPDATE_USAGE_CAPPED_AMOUNT_MUTATION = `\n${APP_SUBSCRIPTION_FRAGMENT}\nmutation appSubscriptionLineItemUpdate($cappedAmount: MoneyInput!, $id: ID!) {\n  appSubscriptionLineItemUpdate(cappedAmount: $cappedAmount, id: $id) {\n    userErrors {\n      field\n      message\n    }\n    confirmationUrl\n    appSubscription {\n      ...AppSubscriptionFragment\n    }\n  }\n}\n`;\n\nexport function updateUsageCappedAmount(\n  config: ConfigInterface,\n): BillingUpdateUsageCappedAmount {\n  return async function updateUsageCappedAmount(\n    params: BillingUpdateUsageCappedAmountParams,\n  ): Promise<UpdateCappedAmountConfirmation> {\n    if (!config.billing) {\n      throw new BillingError({\n        message: 'Attempted to update line item without billing configs',\n        errorData: [],\n      });\n    }\n\n    const {\n      session,\n      subscriptionLineItemId,\n      cappedAmount: {amount, currencyCode},\n    } = params;\n\n    const GraphqlClient = graphqlClientClass({config});\n    const client = new GraphqlClient({session});\n\n    try {\n      const response =\n        await client.request<BillingUpdateUsageCappedAmountResponse>(\n          UPDATE_USAGE_CAPPED_AMOUNT_MUTATION,\n          {\n            variables: {\n              id: subscriptionLineItemId,\n              cappedAmount: {\n                amount,\n                currencyCode,\n              },\n            },\n          },\n        );\n\n      if (response.data?.appSubscriptionLineItemUpdate?.userErrors.length) {\n        throw new BillingError({\n          message: 'Error while updating usage subscription capped amount',\n          errorData: response.data?.appSubscriptionLineItemUpdate?.userErrors,\n        });\n      }\n\n      const appSubscription =\n        response.data?.appSubscriptionLineItemUpdate?.appSubscription!;\n      if (appSubscription && appSubscription.lineItems) {\n        appSubscription.lineItems = convertLineItems(appSubscription.lineItems);\n      }\n\n      return {\n        confirmationUrl:\n          response.data?.appSubscriptionLineItemUpdate?.confirmationUrl!,\n        appSubscription,\n      };\n    } catch (error) {\n      if (error instanceof GraphqlQueryError) {\n        throw new BillingError({\n          message: error.message,\n          errorData: error.response?.errors,\n        });\n      }\n\n      throw error;\n    }\n  };\n}\n", "import {Session} from '@shopify/shopify-api';\nimport {SessionStorage} from '@shopify/shopify-app-session-storage';\nimport type {PrismaClient, Session as Row} from '@prisma/client';\nimport {Prisma} from '@prisma/client';\n\ninterface PrismaSessionStorageOptions {\n  tableName?: string;\n  connectionRetries?: number;\n  connectionRetryIntervalMs?: number;\n}\n\nconst UNIQUE_KEY_CONSTRAINT_ERROR_CODE = 'P2002';\n\n// eslint-disable-next-line no-warning-comments\n// TODO: Remove this when all session storages have implemented the isReady method\nexport interface PrismaSessionStorageInterface extends SessionStorage {\n  isReady(): Promise<boolean>;\n}\n\nexport class PrismaSessionStorage<T extends PrismaClient>\n  implements PrismaSessionStorageInterface\n{\n  private ready: Promise<boolean>;\n  private readonly tableName: string = 'session';\n  private connectionRetries = 2;\n  private connectionRetryIntervalMs = 5000;\n\n  constructor(\n    private prisma: T,\n    {\n      tableName,\n      connectionRetries,\n      connectionRetryIntervalMs,\n    }: PrismaSessionStorageOptions = {},\n  ) {\n    if (tableName) {\n      this.tableName = tableName;\n    }\n\n    if (connectionRetries !== undefined) {\n      this.connectionRetries = connectionRetries;\n    }\n\n    if (connectionRetryIntervalMs !== undefined) {\n      this.connectionRetryIntervalMs = connectionRetryIntervalMs;\n    }\n\n    if (this.getSessionTable() === undefined) {\n      throw new Error(`PrismaClient does not have a ${this.tableName} table`);\n    }\n\n    this.ready = this.pollForTable()\n      .then(() => true)\n      .catch((cause) => {\n        throw new MissingSessionTableError(\n          `Prisma ${this.tableName} table does not exist. This could happen for a few reasons, see https://github.com/Shopify/shopify-app-js/tree/main/packages/apps/session-storage/shopify-app-session-storage-prisma#troubleshooting for more information`,\n          cause,\n        );\n      });\n  }\n\n  public async storeSession(session: Session): Promise<boolean> {\n    await this.ensureReady();\n    const data = this.sessionToRow(session);\n\n    try {\n      await this.getSessionTable().upsert({\n        where: {id: session.id},\n        update: data,\n        create: data,\n      });\n    } catch (error) {\n      if (\n        error instanceof Prisma.PrismaClientKnownRequestError &&\n        error.code === UNIQUE_KEY_CONSTRAINT_ERROR_CODE\n      ) {\n        console.log(\n          'Caught PrismaClientKnownRequestError P2002 - Unique Key Key Constraint, retrying upsert.',\n        );\n        await this.getSessionTable().upsert({\n          where: {id: session.id},\n          update: data,\n          create: data,\n        });\n        return true;\n      }\n      throw error;\n    }\n\n    return true;\n  }\n\n  public async loadSession(id: string): Promise<Session | undefined> {\n    await this.ensureReady();\n    const row = await this.getSessionTable().findUnique({\n      where: {id},\n    });\n\n    if (!row) {\n      return undefined;\n    }\n\n    return this.rowToSession(row);\n  }\n\n  public async deleteSession(id: string): Promise<boolean> {\n    await this.ensureReady();\n    try {\n      await this.getSessionTable().delete({where: {id}});\n    } catch {\n      return true;\n    }\n\n    return true;\n  }\n\n  public async deleteSessions(ids: string[]): Promise<boolean> {\n    await this.ensureReady();\n    await this.getSessionTable().deleteMany({where: {id: {in: ids}}});\n\n    return true;\n  }\n\n  public async findSessionsByShop(shop: string): Promise<Session[]> {\n    await this.ensureReady();\n    const sessions = await this.getSessionTable().findMany({\n      where: {shop},\n      take: 25,\n      orderBy: [{expires: 'desc'}],\n    });\n\n    return sessions.map((session) => this.rowToSession(session));\n  }\n\n  public async isReady(): Promise<boolean> {\n    try {\n      await this.pollForTable();\n      this.ready = Promise.resolve(true);\n    } catch (_error) {\n      this.ready = Promise.resolve(false);\n    }\n    return this.ready;\n  }\n\n  private async ensureReady(): Promise<void> {\n    if (!(await this.ready))\n      throw new MissingSessionStorageError(\n        'Prisma session storage is not ready. Use the `isReady` method to poll for the table.',\n      );\n  }\n\n  private async pollForTable(): Promise<void> {\n    for (let i = 0; i < this.connectionRetries; i++) {\n      try {\n        await this.getSessionTable().count();\n        return;\n      } catch (error) {\n        console.log(`Error obtaining session table: ${error}`);\n      }\n      await sleep(this.connectionRetryIntervalMs);\n    }\n    throw Error(\n      `The table \\`${this.tableName}\\` does not exist in the current database.`,\n    );\n  }\n\n  private sessionToRow(session: Session): Row {\n    const sessionParams = session.toObject();\n\n    return {\n      id: session.id,\n      shop: session.shop,\n      state: session.state,\n      isOnline: session.isOnline,\n      scope: session.scope || null,\n      expires: session.expires || null,\n      accessToken: session.accessToken || '',\n      userId:\n        (sessionParams.onlineAccessInfo?.associated_user\n          .id as unknown as bigint) || null,\n      firstName:\n        sessionParams.onlineAccessInfo?.associated_user.first_name || null,\n      lastName:\n        sessionParams.onlineAccessInfo?.associated_user.last_name || null,\n      email: sessionParams.onlineAccessInfo?.associated_user.email || null,\n      accountOwner:\n        sessionParams.onlineAccessInfo?.associated_user.account_owner || false,\n      locale: sessionParams.onlineAccessInfo?.associated_user.locale || null,\n      collaborator:\n        sessionParams.onlineAccessInfo?.associated_user.collaborator || false,\n      emailVerified:\n        sessionParams.onlineAccessInfo?.associated_user.email_verified || false,\n    };\n  }\n\n  private rowToSession(row: Row): Session {\n    const sessionParams: Record<string, boolean | string | number> = {\n      id: row.id,\n      shop: row.shop,\n      state: row.state,\n      isOnline: row.isOnline,\n      userId: String(row.userId),\n      firstName: String(row.firstName),\n      lastName: String(row.lastName),\n      email: String(row.email),\n      locale: String(row.locale),\n    };\n\n    if (row.accountOwner !== null) {\n      sessionParams.accountOwner = row.accountOwner;\n    }\n\n    if (row.collaborator !== null) {\n      sessionParams.collaborator = row.collaborator;\n    }\n\n    if (row.emailVerified !== null) {\n      sessionParams.emailVerified = row.emailVerified;\n    }\n\n    if (row.expires) {\n      sessionParams.expires = row.expires.getTime();\n    }\n\n    if (row.scope) {\n      sessionParams.scope = row.scope;\n    }\n\n    if (row.accessToken) {\n      sessionParams.accessToken = row.accessToken;\n    }\n\n    return Session.fromPropertyArray(Object.entries(sessionParams), true);\n  }\n\n  private getSessionTable(): T['session'] {\n    return (this.prisma as any)[this.tableName];\n  }\n}\n\nexport class MissingSessionTableError extends Error {\n  constructor(\n    message: string,\n    public readonly cause: Error,\n  ) {\n    super(message);\n  }\n}\n\nexport class MissingSessionStorageError extends Error {\n  constructor(message: string) {\n    super(message);\n  }\n}\n\nasync function sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n"],
  "mappings": "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",
  "names": ["HmacValidationType", "URL", "URL", "URL", "RequestedTokenType", "DeliveryMethod", "WebhookOperation"]
}
