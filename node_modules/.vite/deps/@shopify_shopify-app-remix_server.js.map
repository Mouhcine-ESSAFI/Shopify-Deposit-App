{
  "version": 3,
  "sources": ["../../@shopify/shopify-app-remix/node_modules/adapters/web-api/adapter.ts", "../../@shopify/shopify-app-remix/node_modules/adapters/web-api/index.ts", "../../@shopify/shopify-app-remix/node_modules/lib/types.ts", "../../@shopify/shopify-app-remix/node_modules/lib/version.ts", "../../@shopify/shopify-app-remix/node_modules/lib/logger/log.ts", "../../@shopify/shopify-app-remix/node_modules/lib/logger/index.ts", "../../@shopify/shopify-app-remix/node_modules/rest/load-rest-resources.ts", "../../@shopify/shopify-app-remix/node_modules/future/flags.ts", "../../@shopify/shopify-app-remix/node_modules/lib/auth/scopes/index.ts", "../../@shopify/shopify-app-remix/node_modules/lib/config.ts", "../../@shopify/shopify-app-remix/node_modules/lib/clients/common.ts", "../../@shopify/shopify-app-remix/node_modules/lib/clients/admin/graphql/client.ts", "../../lossless-json/src/utils.ts", "../../lossless-json/src/LosslessNumber.ts", "../../lossless-json/src/numberParsers.ts", "../../lossless-json/src/revive.ts", "../../lossless-json/src/parse.ts", "../../@shopify/shopify-app-remix/node_modules/lib/clients/admin/rest/client.ts", "../../@shopify/shopify-app-remix/node_modules/lib/clients/storefront/client.ts", "../../@shopify/shopify-app-remix/node_modules/lib/clients/graphql_proxy/graphql_proxy.ts", "../../@shopify/shopify-app-remix/node_modules/lib/clients/index.ts", "../../@shopify/shopify-app-remix/node_modules/lib/utils/processed-query.ts", "../../@shopify/shopify-app-remix/node_modules/lib/auth/oauth/safe-compare.ts", "../../@shopify/shopify-app-remix/node_modules/lib/utils/types.ts", "../../@shopify/shopify-app-remix/node_modules/lib/utils/hmac-validator.ts", "../../@shopify/shopify-app-remix/node_modules/lib/auth/decode-host.ts", "../../@shopify/shopify-app-remix/node_modules/lib/utils/shop-admin-url-helper.ts", "../../@shopify/shopify-app-remix/node_modules/lib/utils/shop-validator.ts", "../../@shopify/shopify-app-remix/node_modules/lib/clients/types.ts", "../../@shopify/shopify-app-remix/node_modules/lib/utils/fetch-request.ts", "../../@shopify/shopify-app-remix/node_modules/lib/auth/oauth/types.ts", "../../@shopify/shopify-app-remix/node_modules/lib/auth/oauth/nonce.ts", "../../@shopify/shopify-app-remix/node_modules/lib/session/session.ts", "../../@shopify/shopify-app-remix/node_modules/lib/utils/get-hmac-key.ts", "../../@shopify/shopify-app-remix/node_modules/lib/session/decode-session-token.ts", "../../@shopify/shopify-app-remix/node_modules/lib/session/session-utils.ts", "../../@shopify/shopify-app-remix/node_modules/lib/auth/oauth/create-session.ts", "../../@shopify/shopify-app-remix/node_modules/lib/auth/oauth/oauth.ts", "../../@shopify/shopify-app-remix/node_modules/lib/auth/get-embedded-app-url.ts", "../../@shopify/shopify-app-remix/node_modules/lib/auth/oauth/token-exchange.ts", "../../@shopify/shopify-app-remix/node_modules/lib/auth/oauth/client-credentials.ts", "../../@shopify/shopify-app-remix/node_modules/lib/auth/index.ts", "../../@shopify/shopify-app-remix/node_modules/lib/session/index.ts", "../../@shopify/shopify-app-remix/node_modules/lib/utils/version-compatible.ts", "../../@shopify/shopify-app-remix/node_modules/lib/utils/index.ts", "../../@shopify/shopify-app-remix/node_modules/lib/webhooks/types.ts", "../../@shopify/shopify-app-remix/node_modules/lib/webhooks/registry.ts", "../../@shopify/shopify-app-remix/node_modules/lib/webhooks/query-template.ts", "../../@shopify/shopify-app-remix/node_modules/lib/webhooks/register.ts", "../../@shopify/shopify-app-remix/node_modules/lib/webhooks/validate.ts", "../../@shopify/shopify-app-remix/node_modules/lib/webhooks/process.ts", "../../@shopify/shopify-app-remix/node_modules/lib/webhooks/index.ts", "../../@shopify/shopify-app-remix/node_modules/lib/billing/types.ts", "../../@shopify/shopify-app-remix/node_modules/lib/billing/utils.ts", "../../@shopify/shopify-app-remix/node_modules/lib/billing/check.ts", "../../@shopify/shopify-app-remix/node_modules/lib/billing/request.ts", "../../@shopify/shopify-app-remix/node_modules/lib/billing/cancel.ts", "../../@shopify/shopify-app-remix/node_modules/lib/billing/subscriptions.ts", "../../@shopify/shopify-app-remix/node_modules/lib/billing/create-usage-record.ts", "../../@shopify/shopify-app-remix/node_modules/lib/billing/update-usage-subscription-capped-amount.ts", "../../@shopify/shopify-app-remix/node_modules/lib/billing/index.ts", "../../@shopify/shopify-app-remix/node_modules/lib/flow/validate.ts", "../../@shopify/shopify-app-remix/node_modules/lib/flow/index.ts", "../../@shopify/shopify-app-remix/node_modules/lib/fulfillment-service/validate.ts", "../../@shopify/shopify-app-remix/node_modules/lib/fulfillment-service/index.ts", "../../@shopify/shopify-app-remix/node_modules/lib/index.ts", "../../@shopify/src/server/boundary/headers.ts", "../../@shopify/src/server/boundary/error.tsx", "../../@shopify/src/server/boundary/index.ts", "../../@shopify/src/server/version.ts", "../../@shopify/src/server/authenticate/webhooks/register.ts", "../../@shopify/src/server/authenticate/helpers/ensure-cors-headers.ts", "../../@shopify/src/server/authenticate/admin/helpers/redirect-to-bounce-page.ts", "../../@shopify/src/server/authenticate/helpers/respond-to-invalid-session-token.ts", "../../@shopify/src/server/authenticate/helpers/get-shop-from-request.ts", "../../@shopify/src/server/authenticate/helpers/validate-session-token.ts", "../../@shopify/src/server/authenticate/helpers/get-session-token-header.ts", "../../@shopify/src/server/authenticate/helpers/reject-bot-request.ts", "../../@shopify/src/server/authenticate/helpers/respond-to-options-request.ts", "../../@shopify/src/server/authenticate/admin/helpers/begin-auth.ts", "../../@shopify/src/server/authenticate/admin/helpers/redirect-with-exitiframe.ts", "../../@shopify/src/server/authenticate/admin/helpers/redirect-with-app-bridge-headers.ts", "../../@shopify/src/server/authenticate/admin/helpers/redirect-to-auth-page.ts", "../../@shopify/src/server/authenticate/helpers/invalidate-access-token.ts", "../../@shopify/src/server/authenticate/admin/billing/cancel.ts", "../../@shopify/src/server/authenticate/admin/billing/require.ts", "../../@shopify/src/server/authenticate/admin/billing/helpers.ts", "../../@shopify/src/server/authenticate/admin/billing/request.ts", "../../@shopify/src/server/authenticate/admin/billing/check.ts", "../../@shopify/src/server/authenticate/admin/billing/create-usage-record.ts", "../../@shopify/src/server/authenticate/admin/billing/update-usage-subscription-capped-amount.ts", "../../@shopify/src/server/clients/admin/graphql.ts", "../../@shopify/src/server/clients/admin/factory.ts", "../../@shopify/src/server/authenticate/admin/helpers/create-admin-api-context.ts", "../../@shopify/src/server/authenticate/admin/helpers/redirect-to-shopify-or-app-root.ts", "../../@shopify/src/server/authenticate/admin/helpers/ensure-app-is-embedded-if-required.ts", "../../@shopify/src/server/authenticate/admin/helpers/ensure-session-token-search-param-if-required.ts", "../../@shopify/src/server/authenticate/helpers/add-response-headers.ts", "../../@shopify/src/server/authenticate/admin/helpers/validate-redirect-url.ts", "../../@shopify/src/server/authenticate/admin/helpers/render-app-bridge.ts", "../../@shopify/src/server/authenticate/admin/helpers/redirect.ts", "../../@shopify/src/server/authenticate/admin/helpers/validate-shop-and-host-params.ts", "../../@shopify/src/server/authenticate/admin/helpers/redirect-to-install-page.ts", "../../@shopify/src/server/authenticate/admin/scope/client/fetch-scopes-details.ts", "../../@shopify/src/server/authenticate/admin/scope/request.ts", "../../@shopify/src/server/authenticate/admin/scope/query.ts", "../../@shopify/src/server/authenticate/admin/scope/client/revoke-scopes.ts", "../../@shopify/src/server/authenticate/admin/scope/revoke.ts", "../../@shopify/src/server/authenticate/admin/scope/factory.ts", "../../@shopify/src/server/authenticate/admin/authenticate.ts", "../../@shopify/src/server/authenticate/admin/helpers/handle-client-error.ts", "../../@shopify/src/server/authenticate/helpers/create-or-load-offline-session.ts", "../../@shopify/src/server/authenticate/webhooks/authenticate.ts", "../../@shopify/src/server/override-logger.ts", "../../@shopify/src/server/authenticate/login/login.ts", "../../@shopify/src/server/errors.ts", "../../@shopify/src/server/unauthenticated/admin/factory.ts", "../../@shopify/src/server/authenticate/public/extension/authenticate.ts", "../../@shopify/src/server/authenticate/public/checkout/authenticate.ts", "../../@shopify/src/server/clients/storefront/factory.ts", "../../@shopify/src/server/authenticate/public/appProxy/authenticate.ts", "../../@shopify/src/server/authenticate/public/customer-account/authenticate.ts", "../../@shopify/src/server/authenticate/public/pos/authenticate.ts", "../../@shopify/src/server/authenticate/public/factory.ts", "../../@shopify/src/server/unauthenticated/storefront/factory.ts", "../../@shopify/src/server/authenticate/admin/helpers/trigger-after-auth-hook.ts", "../../@shopify/src/server/authenticate/admin/strategies/auth-code-flow.ts", "../../@shopify/src/server/authenticate/admin/strategies/token-exchange.ts", "../../@shopify/src/server/authenticate/admin/strategies/merchant-custom-app.ts", "../../@shopify/src/server/authenticate/helpers/idempotent-promise-handler.ts", "../../@shopify/src/server/authenticate/flow/authenticate.ts", "../../@shopify/src/server/authenticate/fulfillment-service/authenticate.ts", "../../@shopify/src/server/future/flags.ts", "../../@shopify/src/server/shopify-app.ts", "../../@shopify/src/server/index.ts"],
  "sourcesContent": ["import type {\n  Headers as ShopifyHeaders,\n  AdapterArgs,\n  NormalizedResponse,\n  NormalizedRequest,\n} from '../../runtime';\nimport {addHeader, flatHeaders} from '../../runtime';\n\ninterface WebApiAdapterArgs extends AdapterArgs {\n  rawRequest: Request;\n}\n\nexport async function webApiConvertRequest(\n  adapterArgs: WebApiAdapterArgs,\n): Promise<NormalizedRequest> {\n  const request = adapterArgs.rawRequest;\n  const headers = {};\n  for (const [key, value] of request.headers.entries()) {\n    addHeader(headers, key, value);\n  }\n\n  return {\n    headers,\n    method: request.method ?? 'GET',\n    url: new URL(request.url).toString(),\n  };\n}\n\nexport async function webApiConvertHeaders(\n  headers: ShopifyHeaders,\n  _adapterArgs: WebApiAdapterArgs,\n): Promise<Headers> {\n  const remixHeaders = new Headers();\n  flatHeaders(headers ?? {}).forEach(([key, value]) =>\n    remixHeaders.append(key, value),\n  );\n  return Promise.resolve(remixHeaders);\n}\n\nexport async function webApiConvertResponse(\n  resp: NormalizedResponse,\n  adapterArgs: WebApiAdapterArgs,\n): Promise<Response> {\n  return new Response(resp.body, {\n    status: resp.statusCode,\n    statusText: resp.statusText,\n    headers: await webApiConvertHeaders(resp.headers ?? {}, adapterArgs),\n  });\n}\n\nexport function webApiRuntimeString(): string {\n  return 'Web API';\n}\n", "import {\n  setAbstractFetchFunc,\n  setAbstractConvertRequestFunc,\n  setAbstractConvertResponseFunc,\n  setAbstractConvertHeadersFunc,\n  setAbstractRuntimeString,\n} from '../../runtime';\n\nimport {\n  webApiConvertHeaders,\n  webApiConvertRequest,\n  webApiConvertResponse,\n  webApiRuntimeString,\n} from './adapter';\n\nsetAbstractFetchFunc(fetch);\nsetAbstractConvertRequestFunc(webApiConvertRequest);\nsetAbstractConvertResponseFunc(webApiConvertResponse);\nsetAbstractConvertHeadersFunc(webApiConvertHeaders);\nsetAbstractRuntimeString(webApiRuntimeString);\n", "export enum LogSeverity {\n  Error,\n  Warning,\n  Info,\n  Debug,\n}\n\nexport enum ApiVersion {\n  October22 = '2022-10',\n  January23 = '2023-01',\n  April23 = '2023-04',\n  July23 = '2023-07',\n  October23 = '2023-10',\n  January24 = '2024-01',\n  April24 = '2024-04',\n  July24 = '2024-07',\n  October24 = '2024-10',\n  January25 = '2025-01',\n  April25 = '2025-04',\n  July25 = '2025-07',\n  October25 = '2025-10',\n  Unstable = 'unstable',\n}\n\nexport const LIBRARY_NAME = 'Shopify API Library';\n\n/* eslint-disable @shopify/typescript/prefer-pascal-case-enums */\nexport enum ShopifyHeader {\n  AccessToken = 'X-Shopify-Access-Token',\n  ApiVersion = 'X-Shopify-API-Version',\n  Domain = 'X-Shopify-Shop-Domain',\n  Hmac = 'X-Shopify-Hmac-Sha256',\n  Topic = 'X-Shopify-Topic',\n  SubTopic = 'X-Shopify-Sub-Topic',\n  WebhookId = 'X-Shopify-Webhook-Id',\n  StorefrontPrivateToken = 'Shopify-Storefront-Private-Token',\n  StorefrontSDKVariant = 'X-SDK-Variant',\n  StorefrontSDKVersion = 'X-SDK-Version',\n}\n/* eslint-enable @shopify/typescript/prefer-pascal-case-enums */\n\nexport enum ClientType {\n  Rest = 'rest',\n  Graphql = 'graphql',\n}\n\nexport const privacyTopics: string[] = [\n  'CUSTOMERS_DATA_REQUEST',\n  'CUSTOMERS_REDACT',\n  'SHOP_REDACT',\n];\n\nexport enum BillingInterval {\n  OneTime = 'ONE_TIME',\n  Every30Days = 'EVERY_30_DAYS',\n  Annual = 'ANNUAL',\n  Usage = 'USAGE',\n}\n\nexport type RecurringBillingIntervals = Exclude<\n  BillingInterval,\n  BillingInterval.OneTime\n>;\n\nexport enum BillingReplacementBehavior {\n  ApplyImmediately = 'APPLY_IMMEDIATELY',\n  ApplyOnNextBillingCycle = 'APPLY_ON_NEXT_BILLING_CYCLE',\n  Standard = 'STANDARD',\n}\n\nexport enum StatusCode {\n  Continue = 100,\n  SwitchingProtocols = 101,\n  Ok = 200,\n  Created = 201,\n  Accepted = 202,\n  NonAuthoritativeInformation = 203,\n  NoContent = 204,\n  ResetContent = 205,\n  PartialContent = 206,\n  MultipleChoices = 300,\n  MovedPermanently = 301,\n  Found = 302,\n  SeeOther = 303,\n  NotModified = 304,\n  UseProxy = 305,\n  TemporaryRedirect = 307,\n  BadRequest = 400,\n  Unauthorized = 401,\n  PaymentRequired = 402,\n  Forbidden = 403,\n  NotFound = 404,\n  MethodNotAllowed = 405,\n  NotAcceptable = 406,\n  ProxyAuthenticationRequired = 407,\n  RequestTimeout = 408,\n  Conflict = 409,\n  Gone = 410,\n  LengthRequired = 411,\n  PreconditionFailed = 412,\n  RequestEntityTooLarge = 413,\n  RequestUriTooLong = 414,\n  UnsupportedMediaType = 415,\n  RequestedRangeNotSatisfiable = 416,\n  ExpectationFailed = 417,\n  ImATeapot = 418,\n  UnprocessableEntity = 422,\n  TooManyRequests = 429,\n  InternalServerError = 500,\n  NotImplemented = 501,\n  BadGateway = 502,\n  ServiceUnavailable = 503,\n  GatewayTimeout = 504,\n  HttpVersionNotSupported = 505,\n}\n\nexport enum Method {\n  Get = 'GET',\n  Post = 'POST',\n  Put = 'PUT',\n  Patch = 'PATCH',\n  Delete = 'DELETE',\n  Head = 'HEAD',\n  Options = 'OPTIONS',\n  Connect = 'CONNECT',\n}\n", "export const SHOPIFY_API_LIBRARY_VERSION = '12.0.0';\n", "import {LogSeverity} from '../types';\nimport {ConfigInterface} from '../base-types';\n\nimport {LogContext} from './types';\n\nexport type LoggerFunction = (\n  severity: LogSeverity,\n  message: string,\n  context?: Record<string, any>,\n) => void;\n\nexport function log(config: ConfigInterface): LoggerFunction {\n  return function (\n    severity: LogSeverity,\n    message: string,\n    context: LogContext = {},\n  ): void {\n    if (severity > config.logger.level) {\n      return;\n    }\n\n    const prefix: string[] = [];\n\n    if (config.logger.timestamps) {\n      prefix.push(`${new Date().toISOString().slice(0, -5)}Z`);\n    }\n\n    let packageString = context.package || 'shopify-api';\n    delete context.package;\n\n    switch (severity) {\n      case LogSeverity.Debug:\n        packageString = `${packageString}/DEBUG`;\n        break;\n      case LogSeverity.Info:\n        packageString = `${packageString}/INFO`;\n        break;\n      case LogSeverity.Warning:\n        packageString = `${packageString}/WARNING`;\n        break;\n      case LogSeverity.Error:\n        packageString = `${packageString}/ERROR`;\n        break;\n    }\n\n    prefix.push(packageString);\n\n    const contextParts: string[] = [];\n    Object.entries(context).forEach(([key, value]) => {\n      contextParts.push(`${key}: ${value}`);\n    });\n\n    let suffix = '';\n    if (contextParts.length > 0) {\n      suffix = ` | {${contextParts.join(', ')}}`;\n    }\n\n    config.logger.log(severity, `[${prefix.join('] [')}] ${message}${suffix}`);\n  };\n}\n", "import {compare} from 'compare-versions';\n\nimport {LogSeverity} from '../types';\nimport {ConfigInterface} from '../base-types';\nimport {FeatureDeprecatedError} from '../error';\nimport {SHOPIFY_API_LIBRARY_VERSION} from '../version';\n\nimport {log, LoggerFunction} from './log';\nimport {LogContext} from './types';\n\nexport function logger(config: ConfigInterface) {\n  const logFunction = log(config);\n\n  return {\n    log: logFunction,\n    debug: async (message: string, context: LogContext = {}) =>\n      logFunction(LogSeverity.Debug, message, context),\n    info: async (message: string, context: LogContext = {}) =>\n      logFunction(LogSeverity.Info, message, context),\n    warning: async (message: string, context: LogContext = {}) =>\n      logFunction(LogSeverity.Warning, message, context),\n    error: async (message: string, context: LogContext = {}) =>\n      logFunction(LogSeverity.Error, message, context),\n    deprecated: deprecated(logFunction),\n  };\n}\n\nexport type ShopifyLogger = ReturnType<typeof logger>;\n\nfunction deprecated(logFunction: LoggerFunction) {\n  return function (version: string, message: string): void {\n    if (compare(SHOPIFY_API_LIBRARY_VERSION, version, '>=')) {\n      throw new FeatureDeprecatedError(\n        `Feature was deprecated in version ${version}`,\n      );\n    }\n\n    return logFunction(\n      LogSeverity.Warning,\n      `[Deprecated | ${version}] ${message}`,\n    );\n  };\n}\n", "import type {ShopifyClients} from '../lib';\nimport {ConfigInterface} from '../lib/base-types';\nimport {logger} from '../lib/logger';\n\nimport {Base} from './base';\nimport {ShopifyRestResources} from './types';\n\nexport interface LoadRestResourcesParams<\n  Resources extends ShopifyRestResources,\n> {\n  resources: Resources;\n  config: ConfigInterface;\n  RestClient: ShopifyClients['Rest'];\n}\n\nexport function loadRestResources<Resources extends ShopifyRestResources>({\n  resources,\n  config,\n  RestClient,\n}: LoadRestResourcesParams<Resources>): Resources {\n  const firstResource = Object.keys(resources)[0];\n  if (config.apiVersion !== resources[firstResource].apiVersion) {\n    logger(config).warning(\n      `Loading REST resources for API version ${resources[firstResource].apiVersion}, which doesn't match the default ${config.apiVersion}`,\n    );\n  }\n\n  return Object.fromEntries(\n    Object.entries(resources).map(([name, resource]) => {\n      class NewResource extends resource {}\n\n      NewResource.setClassProperties({\n        Client: RestClient,\n        config,\n      });\n\n      Object.entries(NewResource.hasOne).map(([_attribute, klass]) => {\n        (klass as typeof Base).setClassProperties({\n          Client: RestClient,\n          config,\n        });\n      });\n\n      Object.entries(NewResource.hasMany).map(([_attribute, klass]) => {\n        (klass as typeof Base).setClassProperties({\n          Client: RestClient,\n          config,\n        });\n      });\n\n      Reflect.defineProperty(NewResource, 'name', {\n        value: name,\n      });\n\n      return [name, NewResource];\n    }),\n  ) as Resources;\n}\n", "import {type ShopifyLogger} from '../lib/logger';\nimport {type ConfigInterface} from '../lib/base-types';\n\n/**\n * Future flags are used to enable features that are not yet available by default.\n */\nexport interface FutureFlags {\n  /**\n   * Enable support for managed pricing, so apps can check for payments without needing a billing config.\n   */\n  unstable_managedPricingSupport?: boolean;\n\n  /**\n   * Change the CustomerAddress classes to expose a `is_default` property instead of `default` when fetching data. This\n   * resolves a conflict with the default() method in that class.\n   */\n  customerAddressDefaultFix?: boolean;\n}\n\n/**\n * Configuration option for future flags.\n */\nexport type FutureFlagOptions = FutureFlags | undefined;\n\nexport type FeatureEnabled<\n  Future extends FutureFlagOptions,\n  Flag extends keyof FutureFlags,\n> = Future extends FutureFlags\n  ? Future[Flag] extends true\n    ? true\n    : false\n  : false;\n\nexport function logDisabledFutureFlags(\n  config: ConfigInterface,\n  logger: ShopifyLogger,\n) {\n  if (!config._logDisabledFutureFlags) {\n    return;\n  }\n\n  const logFlag = (flag: string, message: string) =>\n    logger.info(`Future flag ${flag} is disabled.\\n\\n  ${message}\\n`);\n\n  if (!config.future?.customerAddressDefaultFix) {\n    logFlag(\n      'customerAddressDefaultFix',\n      \"Enable this flag to change the CustomerAddress classes to expose a 'is_default' property instead of 'default' when fetching data.\",\n    );\n  }\n\n  if (!config.future?.unstable_managedPricingSupport) {\n    logFlag(\n      'unstable_managedPricingSupport',\n      'Enable this flag to support managed pricing, so apps can check for payments without needing a billing config. Learn more at https://shopify.dev/docs/apps/launch/billing/managed-pricing',\n    );\n  }\n}\n", "/**\n * A class that represents a set of access token scopes.\n */\nclass AuthScopes {\n  public static SCOPE_DELIMITER = ',';\n\n  private compressedScopes: Set<string>;\n  private expandedScopes: Set<string>;\n  private originalScopes: Set<string>;\n\n  constructor(scopes: string | string[] | AuthScopes | undefined) {\n    let scopesArray: string[] = [];\n    if (typeof scopes === 'string') {\n      scopesArray = scopes.split(\n        new RegExp(`${AuthScopes.SCOPE_DELIMITER}\\\\s*`),\n      );\n    } else if (Array.isArray(scopes)) {\n      scopesArray = scopes;\n    } else if (scopes) {\n      scopesArray = Array.from(scopes.expandedScopes);\n    }\n\n    scopesArray = scopesArray\n      .map((scope) => scope.trim())\n      .filter((scope) => scope.length);\n\n    const impliedScopes = this.getImpliedScopes(scopesArray);\n\n    const scopeSet = new Set(scopesArray);\n    const impliedSet = new Set(impliedScopes);\n\n    this.compressedScopes = new Set(\n      [...scopeSet].filter((x) => !impliedSet.has(x)),\n    );\n    this.expandedScopes = new Set([...scopeSet, ...impliedSet]);\n    this.originalScopes = scopeSet;\n  }\n\n  /**\n   * Checks whether the current set of scopes includes the given one.\n   */\n  public has(scope: string | string[] | AuthScopes | undefined) {\n    let other: AuthScopes;\n\n    if (scope instanceof AuthScopes) {\n      other = scope;\n    } else {\n      other = new AuthScopes(scope);\n    }\n\n    return (\n      other.toArray().filter((x) => !this.expandedScopes.has(x)).length === 0\n    );\n  }\n\n  /**\n   * Checks whether the current set of scopes equals the given one.\n   */\n  public equals(otherScopes: string | string[] | AuthScopes | undefined) {\n    let other: AuthScopes;\n\n    if (otherScopes instanceof AuthScopes) {\n      other = otherScopes;\n    } else {\n      other = new AuthScopes(otherScopes);\n    }\n\n    return (\n      this.compressedScopes.size === other.compressedScopes.size &&\n      this.toArray().filter((x) => !other.has(x)).length === 0\n    );\n  }\n\n  /**\n   * Returns a comma-separated string with the current set of scopes.\n   */\n  public toString() {\n    return this.toArray().join(AuthScopes.SCOPE_DELIMITER);\n  }\n\n  /**\n   * Returns an array with the current set of scopes.\n   */\n  public toArray(returnOriginalScopes = false) {\n    return returnOriginalScopes\n      ? [...this.originalScopes]\n      : [...this.compressedScopes];\n  }\n\n  private getImpliedScopes(scopesArray: string[]): string[] {\n    return scopesArray.reduce((array: string[], current: string) => {\n      const matches = current.match(/^(unauthenticated_)?write_(.*)$/);\n      if (matches) {\n        array.push(`${matches[1] ? matches[1] : ''}read_${matches[2]}`);\n      }\n\n      return array;\n    }, []);\n  }\n}\n\nexport {AuthScopes};\n", "import {ShopifyError} from './error';\nimport {ConfigInterface, ConfigParams} from './base-types';\nimport {LogSeverity} from './types';\nimport {AuthScopes} from './auth/scopes';\nimport {logger as createLogger} from './logger';\n\nexport function validateConfig<Params extends ConfigParams>(\n  params: Params,\n): ConfigInterface<Params> {\n  const config = {\n    apiKey: '',\n    apiSecretKey: '',\n    hostName: '',\n    hostScheme: 'https',\n    isEmbeddedApp: true,\n    isCustomStoreApp: false,\n    logger: {\n      log: defaultLogFunction,\n      level: LogSeverity.Info,\n      httpRequests: false,\n      timestamps: false,\n    },\n    future: {},\n    _logDisabledFutureFlags: true,\n  } as ConfigInterface<Params>;\n\n  // Make sure that the essential params actually have content in them\n  const mandatory: (keyof Params)[] = [\n    'apiSecretKey',\n    'hostName',\n    'apiVersion',\n  ];\n  if (!('isCustomStoreApp' in params) || !params.isCustomStoreApp) {\n    mandatory.push('apiKey');\n  }\n  if ('isCustomStoreApp' in params && params.isCustomStoreApp) {\n    if (\n      !('adminApiAccessToken' in params) ||\n      params.adminApiAccessToken?.length === 0\n    ) {\n      mandatory.push('adminApiAccessToken');\n    }\n  }\n\n  const missing: (keyof Params)[] = [];\n  mandatory.forEach((key) => {\n    if (!notEmpty(params[key])) {\n      missing.push(key);\n    }\n  });\n\n  if (missing.length) {\n    throw new ShopifyError(\n      `Cannot initialize Shopify API Library. Missing values for: ${missing.join(\n        ', ',\n      )}. For apiVersion, please specify an explicit API version (e.g., ApiVersion.July25). See https://shopify.dev/docs/api/usage/versioning for more information.`,\n    );\n  }\n\n  const {\n    hostScheme,\n    isCustomStoreApp,\n    adminApiAccessToken,\n    userAgentPrefix,\n    logger,\n    privateAppStorefrontAccessToken,\n    customShopDomains,\n    billing,\n    future,\n    ...mandatoryParams\n  } = params;\n\n  let scopes;\n  if (params.scopes === undefined) {\n    scopes = undefined;\n  } else if (params.scopes instanceof AuthScopes) {\n    scopes = params.scopes;\n  } else {\n    scopes = new AuthScopes(params.scopes);\n  }\n\n  Object.assign(config, mandatoryParams, {\n    hostName: params.hostName.replace(/\\/$/, ''),\n    scopes,\n    hostScheme: hostScheme ?? config.hostScheme,\n    isCustomStoreApp: isCustomStoreApp ?? config.isCustomStoreApp,\n    adminApiAccessToken: adminApiAccessToken ?? config.adminApiAccessToken,\n    userAgentPrefix: userAgentPrefix ?? config.userAgentPrefix,\n    logger: {...config.logger, ...(logger || {})},\n    privateAppStorefrontAccessToken:\n      privateAppStorefrontAccessToken ?? config.privateAppStorefrontAccessToken,\n    customShopDomains: customShopDomains ?? config.customShopDomains,\n    billing: billing ?? config.billing,\n    future: future ?? config.future,\n  });\n\n  if (\n    config.isCustomStoreApp &&\n    params.adminApiAccessToken === params.apiSecretKey\n  ) {\n    createLogger(config).warning(\n      \"adminApiAccessToken is set to the same value as apiSecretKey. adminApiAccessToken should be set to the Admin API access token for custom store apps; apiSecretKey should be set to the custom store app's API secret key.\",\n    );\n  }\n\n  return config;\n}\n\nfunction notEmpty<T>(value: T): value is NonNullable<T> {\n  if (value == null) {\n    return false;\n  }\n  return typeof value === 'string' || Array.isArray(value)\n    ? value.length > 0\n    : true;\n}\n\nfunction defaultLogFunction(severity: LogSeverity, message: string): void {\n  switch (severity) {\n    case LogSeverity.Debug:\n      console.debug(message);\n      break;\n    case LogSeverity.Info:\n      console.log(message);\n      break;\n    case LogSeverity.Warning:\n      console.warn(message);\n      break;\n    case LogSeverity.Error:\n      console.error(message);\n      break;\n  }\n}\n", "import {\n  HTTPResponseLog,\n  HTTPRetryLog,\n  HTTPResponseGraphQLDeprecationNotice,\n  LogContent,\n} from '@shopify/admin-api-client';\n\nimport * as ShopifyErrors from '../error';\nimport {LIBRARY_NAME, StatusCode} from '../types';\nimport {ConfigInterface} from '../base-types';\nimport {SHOPIFY_API_LIBRARY_VERSION} from '../version';\nimport {\n  abstractRuntimeString,\n  canonicalizeHeaders,\n  getHeader,\n} from '../../runtime';\nimport {logger} from '../logger';\n\nexport function getUserAgent(config: ConfigInterface): string {\n  let userAgentPrefix = `${LIBRARY_NAME} v${SHOPIFY_API_LIBRARY_VERSION} | ${abstractRuntimeString()}`;\n  if (config.userAgentPrefix) {\n    userAgentPrefix = `${config.userAgentPrefix} | ${userAgentPrefix}`;\n  }\n\n  return userAgentPrefix;\n}\n\nfunction serializeResponse(response: Response | any) {\n  if (!response) {\n    return {error: 'No response object provided'};\n  }\n\n  try {\n    const {status, statusText, ok, redirected, type, url, headers} = response;\n\n    const serialized: any = {\n      status,\n      statusText,\n      ok,\n      redirected,\n      type,\n      url,\n    };\n\n    if (headers?.entries) {\n      serialized.headers = Object.fromEntries(headers.entries());\n    } else if (headers) {\n      serialized.headers = headers;\n    }\n\n    return serialized;\n  } catch {\n    return response;\n  }\n}\n\nexport function clientLoggerFactory(config: ConfigInterface) {\n  return (logContent: LogContent) => {\n    if (config.logger.httpRequests) {\n      switch (logContent.type) {\n        case 'HTTP-Response': {\n          const responseLog: HTTPResponseLog['content'] = logContent.content;\n          logger(config).debug('Received response for HTTP request', {\n            requestParams: JSON.stringify(responseLog.requestParams),\n            response: JSON.stringify(serializeResponse(responseLog.response)),\n          });\n          break;\n        }\n        case 'HTTP-Retry': {\n          const responseLog: HTTPRetryLog['content'] = logContent.content;\n          logger(config).debug('Retrying HTTP request', {\n            requestParams: JSON.stringify(responseLog.requestParams),\n            retryAttempt: responseLog.retryAttempt,\n            maxRetries: responseLog.maxRetries,\n            response: responseLog.lastResponse\n              ? JSON.stringify(serializeResponse(responseLog.lastResponse))\n              : 'undefined',\n          });\n          break;\n        }\n        case 'HTTP-Response-GraphQL-Deprecation-Notice': {\n          const responseLog: HTTPResponseGraphQLDeprecationNotice['content'] =\n            logContent.content;\n          logger(config).debug(\n            'Received response containing Deprecated GraphQL Notice',\n            {\n              requestParams: JSON.stringify(responseLog.requestParams),\n              deprecationNotice: responseLog.deprecationNotice,\n            },\n          );\n          break;\n        }\n        default: {\n          logger(config).debug(`HTTP request event: ${logContent.content}`);\n          break;\n        }\n      }\n    }\n  };\n}\n\nexport function throwFailedRequest(\n  body: any,\n  atMaxRetries: boolean,\n  response?: Response,\n): never {\n  if (typeof response === 'undefined') {\n    const message = body?.errors?.message ?? '';\n    throw new ShopifyErrors.HttpRequestError(\n      `Http request error, no response available: ${message}`,\n    );\n  }\n\n  const responseHeaders = canonicalizeHeaders(\n    Object.fromEntries(response.headers.entries() ?? []),\n  );\n\n  if (response.status === StatusCode.Ok && body.errors.graphQLErrors) {\n    throw new ShopifyErrors.GraphqlQueryError({\n      message:\n        body.errors.graphQLErrors?.[0].message ?? 'GraphQL operation failed',\n      response: response as Record<string, any>,\n      headers: responseHeaders,\n      body: body as Record<string, any>,\n    });\n  }\n\n  const errorMessages: string[] = [];\n  if (body.errors) {\n    errorMessages.push(JSON.stringify(body.errors, null, 2));\n  }\n  const xRequestId = getHeader(responseHeaders, 'x-request-id');\n  if (xRequestId) {\n    errorMessages.push(\n      `If you report this error, please include this id: ${xRequestId}`,\n    );\n  }\n\n  const errorMessage = errorMessages.length\n    ? `:\\n${errorMessages.join('\\n')}`\n    : '';\n  const code = response.status;\n  const statusText = response.statusText;\n\n  switch (true) {\n    case response.status === StatusCode.TooManyRequests: {\n      if (atMaxRetries) {\n        throw new ShopifyErrors.HttpMaxRetriesError(\n          'Attempted the maximum number of retries for HTTP request.',\n        );\n      } else {\n        const retryAfter = getHeader(responseHeaders, 'Retry-After');\n        throw new ShopifyErrors.HttpThrottlingError({\n          message: `Shopify is throttling requests ${errorMessage}`,\n          code,\n          statusText,\n          body,\n          headers: responseHeaders,\n          retryAfter: retryAfter ? parseFloat(retryAfter) : undefined,\n        });\n      }\n    }\n    case response.status >= StatusCode.InternalServerError:\n      if (atMaxRetries) {\n        throw new ShopifyErrors.HttpMaxRetriesError(\n          'Attempted the maximum number of retries for HTTP request.',\n        );\n      } else {\n        throw new ShopifyErrors.HttpInternalError({\n          message: `Shopify internal error${errorMessage}`,\n          code,\n          statusText,\n          body,\n          headers: responseHeaders,\n        });\n      }\n    default:\n      throw new ShopifyErrors.HttpResponseError({\n        message: `Received an error response (${response.status} ${response.statusText}) from Shopify${errorMessage}`,\n        code,\n        statusText,\n        body,\n        headers: responseHeaders,\n      });\n  }\n}\n", "import {\n  AdminApiClient,\n  AdminOperations,\n  ApiClientRequestOptions,\n  createAdminApiClient,\n  ReturnData,\n} from '@shopify/admin-api-client';\n\nimport {ApiVersion} from '../../../types';\nimport {ConfigInterface} from '../../../base-types';\nimport type {\n  RequestReturn,\n  GraphqlParams,\n  GraphqlClientParams,\n  GraphqlQueryOptions,\n  GraphQLClientResponse,\n} from '../../types';\nimport {Session} from '../../../session/session';\nimport {logger} from '../../../logger';\nimport * as ShopifyErrors from '../../../error';\nimport {abstractFetch, canonicalizeHeaders} from '../../../../runtime';\nimport {\n  clientLoggerFactory,\n  getUserAgent,\n  throwFailedRequest,\n} from '../../common';\n\ninterface GraphqlClientClassParams {\n  config: ConfigInterface;\n}\nexport class GraphqlClient {\n  public static config: ConfigInterface;\n\n  readonly session: Session;\n  readonly client: AdminApiClient;\n  readonly apiVersion?: ApiVersion;\n\n  constructor(params: GraphqlClientParams) {\n    const config = this.graphqlClass().config;\n\n    if (!config.isCustomStoreApp && !params.session.accessToken) {\n      throw new ShopifyErrors.MissingRequiredArgument(\n        'Missing access token when creating GraphQL client',\n      );\n    }\n\n    if (params.apiVersion) {\n      const message =\n        params.apiVersion === config.apiVersion\n          ? `Admin client has a redundant API version override to the default ${params.apiVersion}`\n          : `Admin client overriding default API version ${config.apiVersion} with ${params.apiVersion}`;\n\n      logger(config).debug(message);\n    }\n\n    this.session = params.session;\n    this.apiVersion = params.apiVersion;\n    this.client = createAdminApiClient({\n      accessToken: config.adminApiAccessToken ?? this.session.accessToken!,\n      apiVersion: this.apiVersion ?? config.apiVersion,\n      storeDomain: this.session.shop,\n      customFetchApi: abstractFetch,\n      logger: clientLoggerFactory(config),\n      userAgentPrefix: getUserAgent(config),\n      isTesting: config.isTesting,\n    });\n  }\n\n  public async query<T = undefined>(\n    params: GraphqlParams,\n  ): Promise<RequestReturn<T>> {\n    logger(this.graphqlClass().config).deprecated(\n      '12.0.0',\n      'The query method is deprecated, and was replaced with the request method.\\n' +\n        'See the migration guide: https://github.com/Shopify/shopify-app-js/blob/main/packages/apps/shopify-api/docs/migrating-to-v9.md#using-the-new-clients.',\n    );\n\n    if (\n      (typeof params.data === 'string' && params.data.length === 0) ||\n      Object.entries(params.data).length === 0\n    ) {\n      throw new ShopifyErrors.MissingRequiredArgument('Query missing.');\n    }\n\n    let operation: string;\n    let variables: Record<string, any> | undefined;\n    if (typeof params.data === 'string') {\n      operation = params.data;\n    } else {\n      operation = params.data.query;\n      variables = params.data.variables;\n    }\n\n    const headers = Object.fromEntries(\n      Object.entries(params?.extraHeaders ?? {}).map(([key, value]) => [\n        key,\n        Array.isArray(value) ? value.join(', ') : value.toString(),\n      ]),\n    );\n\n    const response = await this.request<T>(operation, {\n      headers,\n      retries: params.tries ? params.tries - 1 : undefined,\n      variables,\n    });\n\n    return {body: response as T, headers: {}};\n  }\n\n  public async request<\n    T = undefined,\n    Operation extends keyof Operations = string,\n    Operations extends AdminOperations = AdminOperations,\n  >(\n    operation: Operation,\n    options?: GraphqlQueryOptions<Operation, Operations>,\n  ): Promise<\n    GraphQLClientResponse<\n      T extends undefined ? ReturnData<Operation, Operations> : T\n    >\n  > {\n    const response = await this.client.request<\n      T extends undefined ? ReturnData<Operation, Operations> : T,\n      Operation\n    >(operation, {\n      apiVersion: this.apiVersion || this.graphqlClass().config.apiVersion,\n      ...(options as ApiClientRequestOptions<Operation, AdminOperations>),\n    });\n\n    if (response.errors) {\n      const fetchResponse = response.errors.response;\n\n      throwFailedRequest(response, (options?.retries ?? 0) > 0, fetchResponse);\n    }\n\n    const headerObject = Object.fromEntries(\n      response.headers ? response.headers.entries() : [],\n    );\n\n    return {\n      ...response,\n      headers: canonicalizeHeaders(headerObject ?? {}),\n    };\n  }\n\n  private graphqlClass() {\n    return this.constructor as typeof GraphqlClient;\n  }\n}\n\nexport function graphqlClientClass({\n  config,\n}: GraphqlClientClassParams): typeof GraphqlClient {\n  class NewGraphqlClient extends GraphqlClient {\n    public static config = config;\n  }\n\n  Reflect.defineProperty(NewGraphqlClient, 'name', {\n    value: 'GraphqlClient',\n  });\n\n  return NewGraphqlClient as typeof GraphqlClient;\n}\n", "import type { NumberSplit } from './types'\n\n/**\n * Test whether a string contains an integer number\n */\nexport function isInteger(value: string): boolean {\n  return INTEGER_REGEX.test(value)\n}\n\nconst INTEGER_REGEX = /^-?[0-9]+$/\n\n/**\n * Test whether a string contains a number\n * http://stackoverflow.com/questions/13340717/json-numbers-regular-expression\n */\nexport function isNumber(value: string): boolean {\n  return NUMBER_REGEX.test(value)\n}\n\nconst NUMBER_REGEX = /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?$/\n\n/**\n * Test whether a string can be safely represented with a number\n * without information loss.\n *\n * When approx is true, floating point numbers that lose a few digits but\n * are still approximately equal in value are considered safe too.\n * Integer numbers must still be exactly equal.\n */\nexport function isSafeNumber(\n  value: string,\n  config?: {\n    approx: boolean\n  }\n): boolean {\n  if (isInteger(value)) {\n    return Number.isSafeInteger(Number.parseInt(value, 10))\n  }\n\n  const num = Number.parseFloat(value)\n  const parsed = String(num)\n\n  if (value === parsed) {\n    return true\n  }\n\n  const valueDigits = extractSignificantDigits(value)\n  const parsedDigits = extractSignificantDigits(parsed)\n\n  if (valueDigits === parsedDigits) {\n    return true\n  }\n\n  if (config?.approx === true) {\n    // A value is approximately equal when:\n    // 1. it is a floating point number, not an integer\n    // 2. it has at least 14 digits\n    // 3. the first 14 digits are equal\n    const requiredDigits = 14\n    if (\n      !isInteger(value) &&\n      parsedDigits.length >= requiredDigits &&\n      valueDigits.startsWith(parsedDigits.substring(0, requiredDigits))\n    ) {\n      return true\n    }\n  }\n\n  return false\n}\n\nexport enum UnsafeNumberReason {\n  underflow = 'underflow',\n  overflow = 'overflow',\n  truncate_integer = 'truncate_integer',\n  truncate_float = 'truncate_float'\n}\n\n/**\n * When the provided value is an unsafe number, describe what the reason is:\n * overflow, underflow, truncate_integer, or truncate_float.\n * Returns undefined when the value is safe.\n */\nexport function getUnsafeNumberReason(value: string): UnsafeNumberReason | undefined {\n  if (isSafeNumber(value, { approx: false })) {\n    return undefined\n  }\n\n  if (isInteger(value)) {\n    return UnsafeNumberReason.truncate_integer\n  }\n\n  const num = Number.parseFloat(value)\n  if (!Number.isFinite(num)) {\n    return UnsafeNumberReason.overflow\n  }\n\n  if (num === 0) {\n    return UnsafeNumberReason.underflow\n  }\n\n  return UnsafeNumberReason.truncate_float\n}\n\n/**\n * Convert a string into a number when it is safe to do so.\n * Throws an error otherwise, explaining the reason.\n */\nexport function toSafeNumberOrThrow(\n  value: string,\n  config?: {\n    approx: boolean\n  }\n): number {\n  const number = Number.parseFloat(value)\n\n  const unsafeReason = getUnsafeNumberReason(value)\n  if (\n    config?.approx === true\n      ? unsafeReason && unsafeReason !== UnsafeNumberReason.truncate_float\n      : unsafeReason\n  ) {\n    const unsafeReasonText = unsafeReason?.replace(/_\\w+$/, '')\n    throw new Error(\n      `Cannot safely convert to number: the value '${value}' would ${unsafeReasonText} and become ${number}`\n    )\n  }\n\n  return number\n}\n\n/**\n * Split a number into sign, digits, and exponent.\n * The value can be constructed again from a split number by inserting a dot\n * at the second character of the digits if there is more than one digit,\n * prepending it with the sign, and appending the exponent like `e${exponent}`\n */\nexport function splitNumber(value: string): NumberSplit {\n  const match = value.match(/^(-?)(\\d+\\.?\\d*)([eE]([+-]?\\d+))?$/)\n  if (!match) {\n    throw new SyntaxError(`Invalid number: ${value}`)\n  }\n\n  const sign = match[1] as '-' | ''\n  const digitsStr = match[2]\n  let exponent = match[4] !== undefined ? Number.parseInt(match[4], 10) : 0\n\n  const dot = digitsStr.indexOf('.')\n  exponent += dot !== -1 ? dot - 1 : digitsStr.length - 1\n\n  const digits = digitsStr\n    .replace('.', '') // remove the dot (must be removed before removing leading zeros)\n    .replace(/^0*/, (zeros: string) => {\n      // remove leading zeros, add their count to the exponent\n      exponent -= zeros.length\n      return ''\n    })\n    .replace(/0*$/, '') // remove trailing zeros\n\n  return digits.length > 0\n    ? { sign, digits, exponent }\n    : { sign, digits: '0', exponent: exponent + 1 }\n}\n\n/**\n * Compare two strings containing a numeric value\n * Returns 1 when a is larger than b, 0 when they are equal,\n * and -1 when a is smaller than b.\n */\nexport function compareNumber(a: string, b: string): 1 | 0 | -1 {\n  if (a === b) {\n    return 0\n  }\n\n  const aa = splitNumber(a)\n  const bb = splitNumber(b)\n\n  type Sign = -1 | 1\n\n  const sign: Sign = aa.sign === '-' ? -1 : 1\n\n  if (aa.sign !== bb.sign) {\n    if (aa.digits === '0' && bb.digits === '0') {\n      return 0\n    }\n\n    return sign\n  }\n\n  if (aa.exponent !== bb.exponent) {\n    return aa.exponent > bb.exponent ? sign : aa.exponent < bb.exponent ? (-sign as Sign) : 0\n  }\n\n  return aa.digits > bb.digits ? sign : aa.digits < bb.digits ? (-sign as Sign) : 0\n}\n\n/**\n * Count the significant digits of a number.\n *\n * For example:\n *   '2.34' returns 3\n *   '-77' returns 2\n *   '0.003400' returns 2\n *   '120.5e+30' returns 4\n **/\nexport function countSignificantDigits(value: string): number {\n  const { start, end } = getSignificantDigitRange(value)\n\n  const dot = value.indexOf('.')\n  if (dot === -1 || dot < start || dot > end) {\n    return end - start\n  }\n\n  return end - start - 1\n}\n\n/**\n * Get the significant digits of a number.\n *\n * For example:\n *   '2.34' returns '234'\n *   '-77' returns '77'\n *   '0.003400' returns '34'\n *   '120.5e+30' returns '1205'\n **/\nexport function extractSignificantDigits(value: string): string {\n  const { start, end } = getSignificantDigitRange(value)\n\n  const digits = value.substring(start, end)\n\n  const dot = digits.indexOf('.')\n  if (dot === -1) {\n    return digits\n  }\n\n  return digits.substring(0, dot) + digits.substring(dot + 1)\n}\n\n/**\n * Returns the range (start to end) of the significant digits of a value.\n * Note that this range _may_ contain the decimal dot.\n *\n * For example:\n *\n *     getSignificantDigitRange('0.0325900') // { start: 3, end: 7 }\n *     getSignificantDigitRange('2.0300')    // { start: 0, end: 3 }\n *     getSignificantDigitRange('0.0')       // { start: 3, end: 3 }\n *\n */\nfunction getSignificantDigitRange(value: string): { start: number; end: number } {\n  let start = 0\n  if (value[0] === '-') {\n    start++\n  }\n  while (value[start] === '0' || value[start] === '.') {\n    start++\n  }\n\n  let end = value.lastIndexOf('e')\n  if (end === -1) {\n    end = value.lastIndexOf('E')\n  }\n  if (end === -1) {\n    end = value.length\n  }\n  while ((value[end - 1] === '0' || value[end - 1] === '.') && end > start) {\n    end--\n  }\n\n  return { start, end }\n}\n", "import {\n  compareNumber,\n  countSignificantDigits,\n  getUnsafeNumberReason,\n  isInteger,\n  isNumber,\n  UnsafeNumberReason\n} from './utils.js'\n\n/**\n * A lossless number. Stores its numeric value as string\n */\nexport class LosslessNumber {\n  // numeric value as string\n  value: string\n\n  // type information\n  isLosslessNumber = true\n\n  constructor(value: string) {\n    if (!isNumber(value)) {\n      throw new Error(`Invalid number (value: \"${value}\")`)\n    }\n\n    this.value = value\n  }\n\n  /**\n   * Get the value of the LosslessNumber as number or bigint.\n   *\n   * - a number is returned for safe numbers and decimal values that only lose some insignificant digits\n   * - a bigint is returned for big integer numbers\n   * - an Error is thrown for values that will overflow or underflow\n   *\n   * Note that you can implement your own strategy for conversion by just getting the value as string\n   * via .toString(), and using util functions like isInteger, isSafeNumber, getUnsafeNumberReason,\n   * and toSafeNumberOrThrow to convert it to a numeric value.\n   */\n  valueOf(): number | bigint {\n    const unsafeReason = getUnsafeNumberReason(this.value)\n\n    // safe or truncate_float\n    if (unsafeReason === undefined || unsafeReason === UnsafeNumberReason.truncate_float) {\n      return Number.parseFloat(this.value)\n    }\n\n    // truncate_integer\n    if (isInteger(this.value)) {\n      return BigInt(this.value)\n    }\n\n    // overflow or underflow\n    throw new Error(\n      `Cannot safely convert to number: the value '${this.value}' would ${unsafeReason} and become ${Number.parseFloat(this.value)}`\n    )\n  }\n\n  /**\n   * Get the value of the LosslessNumber as string.\n   */\n  toString(): string {\n    return this.value\n  }\n\n  // Note: we do NOT implement a .toJSON() method, and you should not implement\n  // or use that, it cannot safely turn the numeric value in the string into\n  // stringified JSON since it has to be parsed into a number first.\n}\n\n/**\n * Test whether a value is a LosslessNumber\n */\nexport function isLosslessNumber(value: unknown): value is LosslessNumber {\n  // @ts-expect-error\n  return (value && typeof value === 'object' && value.isLosslessNumber) || false\n}\n\n/**\n * Convert a number into a LosslessNumber if this is possible in a safe way\n * If the value has too many digits, or is NaN or Infinity, an error will be thrown\n */\nexport function toLosslessNumber(value: number): LosslessNumber {\n  const maxDigits = 15\n  if (countSignificantDigits(String(value)) > maxDigits) {\n    throw new Error(\n      `Invalid number: contains more than 15 digits and is most likely truncated and unsafe by itself (value: ${value})`\n    )\n  }\n\n  if (Number.isNaN(value)) {\n    throw new Error('Invalid number: NaN')\n  }\n\n  if (!Number.isFinite(value)) {\n    throw new Error(`Invalid number: ${value}`)\n  }\n\n  return new LosslessNumber(String(value))\n}\n\n/**\n * Compare two lossless numbers.\n * Returns 1 when a is larger than b, 0 when they are equal,\n * and -1 when a is smaller than b.\n */\nexport function compareLosslessNumber(a: LosslessNumber, b: LosslessNumber): 1 | 0 | -1 {\n  return compareNumber(a.value, b.value)\n}\n", "import { LosslessNumber } from './LosslessNumber.js'\nimport { isInteger } from './utils.js'\n\nexport function parseLosslessNumber(value: string): LosslessNumber {\n  return new LosslessNumber(value)\n}\n\nexport function parseNumberAndBigInt(value: string): number | bigint {\n  return isInteger(value) ? BigInt(value) : Number.parseFloat(value)\n}\n", "import { isLosslessNumber } from './LosslessNumber.js'\nimport type { GenericObject, Reviver } from './types'\n\n/**\n * Revive a json object.\n * Applies the reviver function recursively on all values in the JSON object.\n * @param json   A JSON Object, Array, or value\n * @param reviver\n *              A reviver function invoked with arguments `key` and `value`,\n *              which must return a replacement value. The function context\n *              (`this`) is the Object or Array that contains the currently\n *              handled value.\n */\nexport function revive(json: unknown, reviver: Reviver): unknown {\n  return reviveValue({ '': json }, '', json, reviver)\n}\n\n/**\n * Revive a value\n */\nfunction reviveValue(\n  context: GenericObject<unknown> | Array<unknown>,\n  key: string,\n  value: unknown,\n  reviver: Reviver\n): unknown {\n  if (Array.isArray(value)) {\n    return reviver.call(context, key, reviveArray(value, reviver))\n  }\n\n  if (value && typeof value === 'object' && !isLosslessNumber(value)) {\n    // note the special case for LosslessNumber,\n    // we don't want to iterate over the internals of a LosslessNumber\n    return reviver.call(context, key, reviveObject(value as GenericObject<unknown>, reviver))\n  }\n\n  return reviver.call(context, key, value)\n}\n\n/**\n * Revive the properties of an object\n */\nfunction reviveObject(object: GenericObject<unknown>, reviver: Reviver) {\n  for (const key of Object.keys(object)) {\n    const value = reviveValue(object, key, object[key], reviver)\n    if (value !== undefined) {\n      object[key] = value\n    } else {\n      delete object[key]\n    }\n  }\n\n  return object\n}\n\n/**\n * Revive the properties of an Array\n */\nfunction reviveArray(array: Array<unknown>, reviver: Reviver): Array<unknown> {\n  for (let i = 0; i < array.length; i++) {\n    array[i] = reviveValue(array, String(i), array[i], reviver)\n  }\n\n  return array\n}\n", "import { parseLosslessNumber } from './numberParsers.js'\nimport { revive } from './revive.js'\nimport type { GenericObject, NumberParser, Reviver } from './types'\n\n/**\n * The LosslessJSON.parse() method parses a string as JSON, optionally transforming\n * the value produced by parsing.\n *\n * The parser is based on the parser of Tan Li Hou shared in\n * https://lihautan.com/json-parser-with-javascript/\n *\n * @param text\n * The string to parse as JSON. See the JSON object for a description of JSON syntax.\n *\n * @param [reviver]\n * If a function, prescribes how the value originally produced by parsing is\n * transformed, before being returned.\n *\n * @param [parseNumber=parseLosslessNumber]\n * Pass a custom number parser. Input is a string, and the output can be unknown\n * numeric value: number, bigint, LosslessNumber, or a custom BigNumber library.\n *\n * @returns Returns the Object corresponding to the given JSON text.\n *\n * @throws Throws a SyntaxError exception if the string to parse is not valid JSON.\n */\nexport function parse(\n  text: string,\n  reviver?: Reviver | null,\n  parseNumber: NumberParser = parseLosslessNumber\n): unknown {\n  let i = 0\n  const value = parseValue()\n  expectValue(value)\n  expectEndOfInput()\n\n  return reviver ? revive(value, reviver) : value\n\n  function parseObject(): GenericObject<unknown> | undefined {\n    if (text.charCodeAt(i) === codeOpeningBrace) {\n      i++\n      skipWhitespace()\n\n      const object: GenericObject<unknown> = {}\n      let initial = true\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBrace) {\n        if (!initial) {\n          eatComma()\n          skipWhitespace()\n        } else {\n          initial = false\n        }\n\n        const start = i\n\n        const key = parseString()\n        if (key === undefined) {\n          throwObjectKeyExpected()\n          return // To make TS happy\n        }\n\n        skipWhitespace()\n        eatColon()\n        const value = parseValue()\n\n        if (value === undefined) {\n          throwObjectValueExpected()\n          return // To make TS happy\n        }\n\n        // biome-ignore lint/suspicious/noPrototypeBuiltins: TODO: replace with hasOwn one day, when browser support is high enough\n        if (Object.prototype.hasOwnProperty.call(object, key) && !isDeepEqual(value, object[key])) {\n          // Note that we could also test `if(key in object) {...}`\n          // or `if (object[key] !== 'undefined') {...}`, but that is slower.\n          throwDuplicateKey(key, start + 1)\n        }\n\n        object[key] = value\n      }\n\n      if (text.charCodeAt(i) !== codeClosingBrace) {\n        throwObjectKeyOrEndExpected()\n      }\n      i++\n\n      return object\n    }\n  }\n\n  function parseArray(): Array<unknown> | unknown {\n    if (text.charCodeAt(i) === codeOpeningBracket) {\n      i++\n      skipWhitespace()\n\n      const array = []\n      let initial = true\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBracket) {\n        if (!initial) {\n          eatComma()\n        } else {\n          initial = false\n        }\n\n        const value = parseValue()\n        expectArrayItem(value)\n        array.push(value)\n      }\n\n      if (text.charCodeAt(i) !== codeClosingBracket) {\n        throwArrayItemOrEndExpected()\n      }\n      i++\n\n      return array\n    }\n  }\n\n  function parseValue(): unknown {\n    skipWhitespace()\n\n    const value =\n      parseString() ??\n      parseNumeric() ??\n      parseObject() ??\n      parseArray() ??\n      parseKeyword('true', true) ??\n      parseKeyword('false', false) ??\n      parseKeyword('null', null)\n\n    skipWhitespace()\n\n    return value\n  }\n\n  function parseKeyword(name: string, value: unknown): unknown | undefined {\n    if (text.slice(i, i + name.length) === name) {\n      i += name.length\n      return value\n    }\n  }\n\n  function skipWhitespace() {\n    while (isWhitespace(text.charCodeAt(i))) {\n      i++\n    }\n  }\n\n  function parseString() {\n    if (text.charCodeAt(i) === codeDoubleQuote) {\n      i++\n      let result = ''\n      while (i < text.length && text.charCodeAt(i) !== codeDoubleQuote) {\n        if (text.charCodeAt(i) === codeBackslash) {\n          const char = text[i + 1]\n          const escapeChar = escapeCharacters[char]\n          if (escapeChar !== undefined) {\n            result += escapeChar\n            i++\n          } else if (char === 'u') {\n            if (\n              isHex(text.charCodeAt(i + 2)) &&\n              isHex(text.charCodeAt(i + 3)) &&\n              isHex(text.charCodeAt(i + 4)) &&\n              isHex(text.charCodeAt(i + 5))\n            ) {\n              result += String.fromCharCode(Number.parseInt(text.slice(i + 2, i + 6), 16))\n              i += 5\n            } else {\n              throwInvalidUnicodeCharacter(i)\n            }\n          } else {\n            throwInvalidEscapeCharacter(i)\n          }\n        } else {\n          if (isValidStringCharacter(text.charCodeAt(i))) {\n            result += text[i]\n          } else {\n            throwInvalidCharacter(text[i])\n          }\n        }\n        i++\n      }\n      expectEndOfString()\n      i++\n      return result\n    }\n  }\n\n  function parseNumeric() {\n    const start = i\n    if (text.charCodeAt(i) === codeMinus) {\n      i++\n      expectDigit(start)\n    }\n\n    if (text.charCodeAt(i) === codeZero) {\n      i++\n    } else if (isNonZeroDigit(text.charCodeAt(i))) {\n      i++\n      while (isDigit(text.charCodeAt(i))) {\n        i++\n      }\n    }\n\n    if (text.charCodeAt(i) === codeDot) {\n      i++\n      expectDigit(start)\n      while (isDigit(text.charCodeAt(i))) {\n        i++\n      }\n    }\n\n    if (text.charCodeAt(i) === codeLowercaseE || text.charCodeAt(i) === codeUppercaseE) {\n      i++\n      if (text.charCodeAt(i) === codeMinus || text.charCodeAt(i) === codePlus) {\n        i++\n      }\n      expectDigit(start)\n      while (isDigit(text.charCodeAt(i))) {\n        i++\n      }\n    }\n\n    if (i > start) {\n      return parseNumber(text.slice(start, i))\n    }\n  }\n\n  function eatComma() {\n    if (text.charCodeAt(i) !== codeComma) {\n      throw new SyntaxError(`Comma ',' expected after value ${gotAt()}`)\n    }\n    i++\n  }\n\n  function eatColon() {\n    if (text.charCodeAt(i) !== codeColon) {\n      throw new SyntaxError(`Colon ':' expected after property name ${gotAt()}`)\n    }\n    i++\n  }\n\n  function expectValue(value: unknown) {\n    if (value === undefined) {\n      throw new SyntaxError(`JSON value expected ${gotAt()}`)\n    }\n  }\n\n  function expectArrayItem(value: unknown) {\n    if (value === undefined) {\n      throw new SyntaxError(`Array item expected ${gotAt()}`)\n    }\n  }\n\n  function expectEndOfInput() {\n    if (i < text.length) {\n      throw new SyntaxError(`Expected end of input ${gotAt()}`)\n    }\n  }\n\n  function expectDigit(start: number) {\n    if (!isDigit(text.charCodeAt(i))) {\n      const numSoFar = text.slice(start, i)\n      throw new SyntaxError(`Invalid number '${numSoFar}', expecting a digit ${gotAt()}`)\n    }\n  }\n\n  function expectEndOfString() {\n    if (text.charCodeAt(i) !== codeDoubleQuote) {\n      throw new SyntaxError(`End of string '\"' expected ${gotAt()}`)\n    }\n  }\n\n  function throwObjectKeyExpected() {\n    throw new SyntaxError(`Quoted object key expected ${gotAt()}`)\n  }\n\n  function throwDuplicateKey(key: string, pos: number) {\n    throw new SyntaxError(`Duplicate key '${key}' encountered at position ${pos}`)\n  }\n\n  function throwObjectKeyOrEndExpected() {\n    throw new SyntaxError(`Quoted object key or end of object '}' expected ${gotAt()}`)\n  }\n\n  function throwArrayItemOrEndExpected() {\n    throw new SyntaxError(`Array item or end of array ']' expected ${gotAt()}`)\n  }\n\n  function throwInvalidCharacter(char: string) {\n    throw new SyntaxError(`Invalid character '${char}' ${pos()}`)\n  }\n\n  function throwInvalidEscapeCharacter(start: number) {\n    const chars = text.slice(start, start + 2)\n    throw new SyntaxError(`Invalid escape character '${chars}' ${pos()}`)\n  }\n\n  function throwObjectValueExpected() {\n    throw new SyntaxError(`Object value expected after ':' ${pos()}`)\n  }\n\n  function throwInvalidUnicodeCharacter(start: number) {\n    const chars = text.slice(start, start + 6)\n    throw new SyntaxError(`Invalid unicode character '${chars}' ${pos()}`)\n  }\n\n  // zero based character position\n  function pos(): string {\n    return `at position ${i}`\n  }\n\n  function got(): string {\n    return i < text.length ? `but got '${text[i]}'` : 'but reached end of input'\n  }\n\n  function gotAt(): string {\n    return `${got()} ${pos()}`\n  }\n}\n\nfunction isWhitespace(code: number): boolean {\n  return code === codeSpace || code === codeNewline || code === codeTab || code === codeReturn\n}\n\nfunction isHex(code: number): boolean {\n  return (\n    (code >= codeZero && code <= codeNine) ||\n    (code >= codeUppercaseA && code <= codeUppercaseF) ||\n    (code >= codeLowercaseA && code <= codeLowercaseF)\n  )\n}\n\nfunction isDigit(code: number): boolean {\n  return code >= codeZero && code <= codeNine\n}\n\nfunction isNonZeroDigit(code: number): boolean {\n  return code >= codeOne && code <= codeNine\n}\n\nexport function isValidStringCharacter(code: number): boolean {\n  return code >= 0x20 && code <= 0x10ffff\n}\n\nexport function isDeepEqual(a: unknown, b: unknown): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.length === b.length && a.every((item, index) => isDeepEqual(item, b[index]))\n  }\n\n  if (isObject(a) && isObject(b)) {\n    const keys = [...new Set([...Object.keys(a), ...Object.keys(b)])]\n    return keys.every((key) => isDeepEqual(a[key], b[key]))\n  }\n\n  return false\n}\n\nfunction isObject(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null\n}\n\n// map with all escape characters\nconst escapeCharacters: GenericObject<string> = {\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t'\n  // note that \\u is handled separately in parseString()\n}\n\nconst codeBackslash = 0x5c // \"\\\"\nconst codeOpeningBrace = 0x7b // \"{\"\nconst codeClosingBrace = 0x7d // \"}\"\nconst codeOpeningBracket = 0x5b // \"[\"\nconst codeClosingBracket = 0x5d // \"]\"\nconst codeSpace = 0x20 // \" \"\nconst codeNewline = 0xa // \"\\n\"\nconst codeTab = 0x9 // \"\\t\"\nconst codeReturn = 0xd // \"\\r\"\nconst codeDoubleQuote = 0x0022 // \"\nconst codePlus = 0x2b // \"+\"\nconst codeMinus = 0x2d // \"-\"\nconst codeZero = 0x30\nconst codeOne = 0x31\nconst codeNine = 0x39\nconst codeComma = 0x2c // \",\"\nconst codeDot = 0x2e // \".\" (dot, period)\nconst codeColon = 0x3a // \":\"\nexport const codeUppercaseA = 0x41 // \"A\"\nexport const codeLowercaseA = 0x61 // \"a\"\nexport const codeUppercaseE = 0x45 // \"E\"\nexport const codeLowercaseE = 0x65 // \"e\"\nexport const codeUppercaseF = 0x46 // \"F\"\nexport const codeLowercaseF = 0x66 // \"f\"\n", "import {\n  AdminRestApiClient,\n  createAdminRestApiClient,\n} from '@shopify/admin-api-client';\nimport * as LosslessJSON from 'lossless-json';\n\nimport {\n  clientLoggerFactory,\n  getUserAgent,\n  throwFailedRequest,\n} from '../../common';\nimport {\n  HashFormat,\n  NormalizedRequest,\n  abstractFetch,\n  canonicalizeHeaders,\n  createSHA256HMAC,\n  getHeader,\n} from '../../../../runtime';\nimport {ConfigInterface} from '../../../base-types';\nimport * as ShopifyErrors from '../../../error';\nimport {logger} from '../../../logger';\nimport {\n  RestRequestReturn,\n  PageInfo,\n  RestClientParams,\n  PageInfoParams,\n} from '../types';\nimport type {\n  RequestParams,\n  GetRequestParams,\n  PutRequestParams,\n  PostRequestParams,\n  DeleteRequestParams,\n} from '../../types';\nimport {ApiVersion, Method} from '../../../types';\nimport {Session} from '../../../session/session';\n\nexport interface RestClientClassParams {\n  config: ConfigInterface;\n  formatPaths?: boolean;\n}\n\ninterface DeprecationInterface {\n  message: string | null;\n  path: string;\n  body?: string;\n}\n\nexport class RestClient {\n  public static config: ConfigInterface;\n  public static formatPaths: boolean;\n\n  static LINK_HEADER_REGEXP = /<([^<]+)>; rel=\"([^\"]+)\"/;\n  static DEFAULT_LIMIT = '50';\n  static RETRY_WAIT_TIME = 1000;\n\n  static readonly DEPRECATION_ALERT_DELAY = 300000;\n  loggedDeprecations: Record<string, number> = {};\n\n  readonly client: AdminRestApiClient;\n  readonly session: Session;\n  readonly apiVersion: ApiVersion;\n\n  public constructor({session, apiVersion}: RestClientParams) {\n    const config = this.restClass().config;\n\n    if (!config.isCustomStoreApp && !session.accessToken) {\n      throw new ShopifyErrors.MissingRequiredArgument(\n        'Missing access token when creating REST client',\n      );\n    }\n\n    if (apiVersion) {\n      const message =\n        apiVersion === config.apiVersion\n          ? `REST client has a redundant API version override to the default ${apiVersion}`\n          : `REST client overriding default API version ${config.apiVersion} with ${apiVersion}`;\n\n      logger(config).debug(message);\n    }\n\n    const customStoreAppAccessToken =\n      config.adminApiAccessToken ?? config.apiSecretKey;\n\n    this.session = session;\n    this.apiVersion = apiVersion ?? config.apiVersion;\n    this.client = createAdminRestApiClient({\n      scheme: config.hostScheme,\n      storeDomain: session.shop,\n      apiVersion: apiVersion ?? config.apiVersion,\n      accessToken: config.isCustomStoreApp\n        ? customStoreAppAccessToken\n        : session.accessToken!,\n      customFetchApi: abstractFetch,\n      logger: clientLoggerFactory(config),\n      userAgentPrefix: getUserAgent(config),\n      defaultRetryTime: this.restClass().RETRY_WAIT_TIME,\n      formatPaths: this.restClass().formatPaths,\n      isTesting: config.isTesting,\n    });\n  }\n\n  /**\n   * Performs a GET request on the given path.\n   */\n  public async get<T = any>(params: GetRequestParams) {\n    return this.request<T>({method: Method.Get, ...params});\n  }\n\n  /**\n   * Performs a POST request on the given path.\n   */\n  public async post<T = any>(params: PostRequestParams) {\n    return this.request<T>({method: Method.Post, ...params});\n  }\n\n  /**\n   * Performs a PUT request on the given path.\n   */\n  public async put<T = any>(params: PutRequestParams) {\n    return this.request<T>({method: Method.Put, ...params});\n  }\n\n  /**\n   * Performs a DELETE request on the given path.\n   */\n  public async delete<T = any>(params: DeleteRequestParams) {\n    return this.request<T>({method: Method.Delete, ...params});\n  }\n\n  protected async request<T = any>(\n    params: RequestParams,\n  ): Promise<RestRequestReturn<T>> {\n    const requestParams = {\n      headers: {\n        ...params.extraHeaders,\n        ...(params.type ? {'Content-Type': params.type.toString()} : {}),\n      },\n      retries: params.tries ? params.tries - 1 : undefined,\n      searchParams: params.query,\n    };\n\n    let response: Response;\n    switch (params.method) {\n      case Method.Get:\n        response = await this.client.get(params.path, requestParams);\n        break;\n      case Method.Put:\n        response = await this.client.put(params.path, {\n          ...requestParams,\n          data: params.data!,\n        });\n        break;\n      case Method.Post:\n        response = await this.client.post(params.path, {\n          ...requestParams,\n          data: params.data!,\n        });\n        break;\n      case Method.Delete:\n        response = await this.client.delete(params.path, requestParams);\n        break;\n      default:\n        throw new ShopifyErrors.InvalidRequestError(\n          `Unsupported request method '${params.method}'`,\n        );\n    }\n\n    const bodyString: string = await response.text();\n\n    // Some DELETE requests return an empty body but are still valid responses, we want those to go through\n    const body: any =\n      params.method === Method.Delete && bodyString === ''\n        ? {}\n        : this.parseJsonWithLosslessNumbers(bodyString);\n\n    const responseHeaders = canonicalizeHeaders(\n      Object.fromEntries(response.headers.entries()),\n    );\n\n    if (!response.ok) {\n      throwFailedRequest(body, (params.tries ?? 1) > 1, response);\n    }\n\n    const requestReturn: RestRequestReturn<T> = {\n      body,\n      headers: responseHeaders,\n    };\n\n    await this.logDeprecations(\n      {\n        method: params.method,\n        url: params.path,\n        headers: requestParams.headers,\n        body: params.data ? JSON.stringify(params.data) : undefined,\n      },\n      requestReturn,\n    );\n\n    const link = response.headers.get('Link');\n    if (link !== undefined) {\n      const pageInfo: PageInfo = {\n        limit: params.query?.limit\n          ? params.query?.limit.toString()\n          : RestClient.DEFAULT_LIMIT,\n      };\n\n      if (link) {\n        const links = link.split(', ');\n\n        for (const link of links) {\n          const parsedLink = link.match(RestClient.LINK_HEADER_REGEXP);\n          if (!parsedLink) {\n            continue;\n          }\n\n          const linkRel = parsedLink[2];\n          const linkUrl = new URL(parsedLink[1]);\n          const linkFields = linkUrl.searchParams.get('fields');\n          const linkPageToken = linkUrl.searchParams.get('page_info');\n\n          if (!pageInfo.fields && linkFields) {\n            pageInfo.fields = linkFields.split(',');\n          }\n\n          if (linkPageToken) {\n            switch (linkRel) {\n              case 'previous':\n                pageInfo.previousPageUrl = parsedLink[1];\n                pageInfo.prevPage = this.buildRequestParams(parsedLink[1]);\n                break;\n              case 'next':\n                pageInfo.nextPageUrl = parsedLink[1];\n                pageInfo.nextPage = this.buildRequestParams(parsedLink[1]);\n                break;\n            }\n          }\n        }\n      }\n\n      requestReturn.pageInfo = pageInfo;\n    }\n\n    return requestReturn;\n  }\n\n  private restClass() {\n    return this.constructor as typeof RestClient;\n  }\n\n  /**\n   * Parse JSON with lossless-json to preserve numeric precision.\n   * Converts all ID fields (ending with _id, _ids, or named 'id') to strings.\n   */\n  private parseJsonWithLosslessNumbers(jsonString: string): any {\n    // Parse with lossless-json first to preserve precision\n    const parsed = LosslessJSON.parse(jsonString);\n\n    // Recursively process the parsed object to convert IDs to strings\n    const processValue = (value: any, key?: string): any => {\n      if (value === null || value === undefined) {\n        return value;\n      }\n\n      // Handle LosslessNumber instances\n      if (value && value.isLosslessNumber === true) {\n        const keyLower = (key || '').toLowerCase();\n        // Always convert ID fields to strings\n        if (keyLower === 'id' || keyLower.endsWith('_id')) {\n          return value.toString();\n        }\n        // For non-ID fields, always convert to regular JavaScript number\n        // The IDs have already been handled, so we can use standard conversion\n        return Number(value.value);\n      }\n\n      // Handle arrays - special case for _ids arrays\n      if (Array.isArray(value)) {\n        const isIdsArray = key && key.toLowerCase().endsWith('_ids');\n        return value.map((item) => {\n          // If this is an _ids array and item is a LosslessNumber, convert to string\n          if (isIdsArray && item && item.isLosslessNumber === true) {\n            return item.toString();\n          }\n          return processValue(item);\n        });\n      }\n\n      // Handle objects\n      if (typeof value === 'object') {\n        const result: any = {};\n        for (const objKey in value) {\n          if (Object.prototype.hasOwnProperty.call(value, objKey)) {\n            result[objKey] = processValue(value[objKey], objKey);\n          }\n        }\n        return result;\n      }\n\n      return value;\n    };\n\n    return processValue(parsed);\n  }\n\n  private buildRequestParams(newPageUrl: string): PageInfoParams {\n    const pattern = `^/admin/api/[^/]+/(.*).json$`;\n\n    const url = new URL(newPageUrl);\n    const path = url.pathname.replace(new RegExp(pattern), '$1');\n    return {\n      path,\n      query: Object.fromEntries(url.searchParams.entries()),\n    };\n  }\n\n  private async logDeprecations(\n    request: NormalizedRequest,\n    response: RestRequestReturn,\n  ) {\n    const config = this.restClass().config;\n\n    const deprecationReason = getHeader(\n      response.headers,\n      'X-Shopify-API-Deprecated-Reason',\n    );\n    if (deprecationReason) {\n      const deprecation: DeprecationInterface = {\n        message: deprecationReason,\n        path: request.url,\n      };\n\n      if (request.body) {\n        // This can only be a string, since we're always converting the body before calling this method\n        deprecation.body = `${(request.body as string).substring(0, 100)}...`;\n      }\n\n      const depHash = await createSHA256HMAC(\n        config.apiSecretKey,\n        JSON.stringify(deprecation),\n        HashFormat.Hex,\n      );\n\n      if (\n        !Object.keys(this.loggedDeprecations).includes(depHash) ||\n        Date.now() - this.loggedDeprecations[depHash] >=\n          RestClient.DEPRECATION_ALERT_DELAY\n      ) {\n        this.loggedDeprecations[depHash] = Date.now();\n\n        const stack = new Error().stack;\n        const message = `API Deprecation Notice ${new Date().toLocaleString()} : ${JSON.stringify(\n          deprecation,\n        )}  -  Stack Trace: ${stack}`;\n        await logger(config).warning(message);\n      }\n    }\n  }\n}\n\nexport function restClientClass(\n  params: RestClientClassParams,\n): typeof RestClient {\n  const {config, formatPaths} = params;\n\n  class NewRestClient extends RestClient {\n    public static config = config;\n    public static formatPaths = formatPaths === undefined ? true : formatPaths;\n  }\n\n  Reflect.defineProperty(NewRestClient, 'name', {\n    value: 'RestClient',\n  });\n\n  return NewRestClient as typeof RestClient;\n}\n", "import {\n  StorefrontApiClient,\n  StorefrontOperations,\n  ClientResponse,\n  createStorefrontApiClient,\n  ReturnData,\n  ApiClientRequestOptions,\n} from '@shopify/storefront-api-client';\n\nimport {ApiVersion} from '../../types';\nimport {logger} from '../../logger';\nimport * as ShopifyErrors from '../../error';\nimport {MissingRequiredArgument} from '../../error';\nimport type {\n  GraphqlClientParams,\n  GraphqlParams,\n  GraphqlQueryOptions,\n  RequestReturn,\n} from '../types';\nimport {ConfigInterface} from '../../base-types';\nimport {Session} from '../../session/session';\nimport {abstractFetch} from '../../../runtime';\nimport {clientLoggerFactory, getUserAgent, throwFailedRequest} from '../common';\n\ninterface GraphqlClientClassParams {\n  config: ConfigInterface;\n}\n\nexport class StorefrontClient {\n  public static config: ConfigInterface;\n\n  readonly session: Session;\n  readonly client: StorefrontApiClient;\n  readonly apiVersion?: ApiVersion;\n\n  constructor(params: GraphqlClientParams) {\n    const config = this.storefrontClass().config;\n\n    if (!config.isCustomStoreApp && !params.session.accessToken) {\n      throw new ShopifyErrors.MissingRequiredArgument(\n        'Missing access token when creating GraphQL client',\n      );\n    }\n\n    if (params.apiVersion) {\n      const message =\n        params.apiVersion === config.apiVersion\n          ? `Storefront client has a redundant API version override to the default ${params.apiVersion}`\n          : `Storefront client overriding default API version ${config.apiVersion} with ${params.apiVersion}`;\n\n      logger(config).debug(message);\n    }\n\n    let accessToken: string | undefined;\n    if (config.isCustomStoreApp) {\n      accessToken = config.privateAppStorefrontAccessToken;\n\n      if (!accessToken) {\n        throw new MissingRequiredArgument(\n          'Custom store apps must set the privateAppStorefrontAccessToken property to call the Storefront API.',\n        );\n      }\n    } else {\n      accessToken = params.session.accessToken;\n\n      if (!accessToken) {\n        throw new MissingRequiredArgument('Session missing access token.');\n      }\n    }\n\n    this.session = params.session;\n    this.apiVersion = params.apiVersion;\n    this.client = createStorefrontApiClient({\n      privateAccessToken: accessToken,\n      apiVersion: this.apiVersion ?? config.apiVersion,\n      storeDomain: this.session.shop,\n      customFetchApi: abstractFetch,\n      logger: clientLoggerFactory(config),\n      clientName: getUserAgent(config),\n    });\n  }\n\n  public async query<T = undefined>(\n    params: GraphqlParams,\n  ): Promise<RequestReturn<T>> {\n    logger(this.storefrontClass().config).deprecated(\n      '12.0.0',\n      'The query method is deprecated, and was replaced with the request method.\\n' +\n        'See the migration guide: https://github.com/Shopify/shopify-app-js/blob/main/packages/apps/shopify-api/docs/migrating-to-v9.md#using-the-new-clients.',\n    );\n\n    if (\n      (typeof params.data === 'string' && params.data.length === 0) ||\n      Object.entries(params.data).length === 0\n    ) {\n      throw new ShopifyErrors.MissingRequiredArgument('Query missing.');\n    }\n\n    let operation: string;\n    let variables: Record<string, any> | undefined;\n    if (typeof params.data === 'string') {\n      operation = params.data;\n    } else {\n      operation = params.data.query;\n      variables = params.data.variables;\n    }\n\n    const headers = Object.fromEntries(\n      Object.entries(params?.extraHeaders ?? {}).map(([key, value]) => [\n        key,\n        Array.isArray(value) ? value.join(', ') : value.toString(),\n      ]),\n    );\n\n    const response = await this.request<T>(operation, {\n      headers,\n      retries: params.tries ? params.tries - 1 : undefined,\n      variables,\n    });\n\n    return {body: response as T, headers: {}};\n  }\n\n  public async request<\n    T = undefined,\n    Operation extends keyof Operations = string,\n    Operations extends StorefrontOperations = StorefrontOperations,\n  >(\n    operation: Operation,\n    options?: GraphqlQueryOptions<Operation, Operations>,\n  ): Promise<\n    ClientResponse<T extends undefined ? ReturnData<Operation, Operations> : T>\n  > {\n    const response = await this.client.request<T, Operation>(operation, {\n      apiVersion: this.apiVersion || this.storefrontClass().config.apiVersion,\n      ...(options as ApiClientRequestOptions<Operation, StorefrontOperations>),\n    });\n\n    if (response.errors) {\n      const fetchResponse = response.errors.response;\n\n      throwFailedRequest(response, (options?.retries ?? 0) > 0, fetchResponse);\n    }\n\n    return response;\n  }\n\n  private storefrontClass() {\n    return this.constructor as typeof StorefrontClient;\n  }\n}\n\nexport function storefrontClientClass(params: GraphqlClientClassParams) {\n  const {config} = params;\n  class NewStorefrontClient extends StorefrontClient {\n    public static config = config;\n  }\n\n  Reflect.defineProperty(NewStorefrontClient, 'name', {\n    value: 'StorefrontClient',\n  });\n\n  return NewStorefrontClient as typeof StorefrontClient;\n}\n", "import {ConfigInterface} from '../../base-types';\nimport * as ShopifyErrors from '../../error';\nimport {graphqlClientClass} from '../admin';\n\nimport {GraphqlProxy} from './types';\n\nexport function graphqlProxy(config: ConfigInterface): GraphqlProxy {\n  return async ({session, rawBody}) => {\n    if (!session.accessToken) {\n      throw new ShopifyErrors.InvalidSession(\n        'Cannot proxy query. Session not authenticated.',\n      );\n    }\n\n    const GraphqlClient = graphqlClientClass({config});\n    const client = new GraphqlClient({session});\n\n    let query: string;\n    let variables: Record<string, any> | undefined;\n    if (typeof rawBody === 'string') {\n      query = rawBody;\n    } else {\n      query = rawBody.query;\n      variables = rawBody.variables;\n    }\n\n    if (!query) {\n      throw new ShopifyErrors.MissingRequiredArgument('Query missing.');\n    }\n\n    const response = await client.request(query, {variables});\n\n    return {body: response, headers: {}};\n  };\n}\n", "import {ConfigInterface} from '../base-types';\n\nimport {restClientClass, graphqlClientClass} from './admin';\nimport {storefrontClientClass} from './storefront';\nimport {graphqlProxy} from './graphql_proxy/graphql_proxy';\nimport {ShopifyClients} from './types';\n\nexport type {ShopifyClients} from './types';\n\nexport function clientClasses(config: ConfigInterface): ShopifyClients {\n  return {\n    // We don't pass in the HttpClient because the RestClient inherits from it, and goes through the same setup process\n    Rest: restClientClass({config}),\n    Graphql: graphqlClientClass({config}),\n    Storefront: storefrontClientClass({config}),\n    graphqlProxy: graphqlProxy(config),\n  };\n}\n", "export default class ProcessedQuery {\n  static stringify(keyValuePairs?: Record<string, any>): string {\n    if (!keyValuePairs || Object.keys(keyValuePairs).length === 0) return '';\n\n    return new ProcessedQuery().putAll(keyValuePairs).stringify();\n  }\n\n  processedQuery: URLSearchParams;\n\n  constructor() {\n    this.processedQuery = new URLSearchParams();\n  }\n\n  putAll(keyValuePairs: Record<string, any>): ProcessedQuery {\n    Object.entries(keyValuePairs).forEach(([key, value]: [string, any]) =>\n      this.put(key, value),\n    );\n    return this;\n  }\n\n  put(key: string, value: any): void {\n    if (Array.isArray(value)) {\n      this.putArray(key, value);\n    } else if (value?.constructor === Object) {\n      this.putObject(key, value);\n    } else {\n      this.putSimple(key, value);\n    }\n  }\n\n  putArray(key: string, value: (string | number)[]): void {\n    value.forEach((arrayValue) =>\n      this.processedQuery.append(`${key}[]`, `${arrayValue}`),\n    );\n  }\n\n  putObject(key: string, value: object): void {\n    Object.entries(value).forEach(\n      ([entry, entryValue]: [string, string | number]) => {\n        this.processedQuery.append(`${key}[${entry}]`, `${entryValue}`);\n      },\n    );\n  }\n\n  putSimple(key: string, value: string | number): void {\n    this.processedQuery.append(key, `${value}`);\n  }\n\n  stringify(omitQuestionMark = false): string {\n    const queryString = this.processedQuery.toString();\n    return omitQuestionMark ? queryString : `?${queryString}`;\n  }\n}\n", "import * as ShopifyErrors from '../../error';\n\nexport type SafeCompare = (\n  strA: string | Record<string, string> | string[] | number[],\n  strB: string | Record<string, string> | string[] | number[],\n) => boolean;\n\nexport const safeCompare: SafeCompare = (strA, strB) => {\n  if (typeof strA === typeof strB) {\n    const enc = new TextEncoder();\n    const buffA = enc.encode(JSON.stringify(strA));\n    const buffB = enc.encode(JSON.stringify(strB));\n\n    if (buffA.length === buffB.length) {\n      return timingSafeEqual(buffA, buffB);\n    }\n  } else {\n    throw new ShopifyErrors.SafeCompareError(\n      `Mismatched data types provided: ${typeof strA} and ${typeof strB}`,\n    );\n  }\n  return false;\n};\n\n// Buffer must be same length for this function to be secure.\nfunction timingSafeEqual(bufA: ArrayBuffer, bufB: ArrayBuffer): boolean {\n  const viewA = new Uint8Array(bufA);\n  const viewB = new Uint8Array(bufB);\n  let out = 0;\n  for (let i = 0; i < viewA.length; i++) {\n    out |= viewA[i] ^ viewB[i];\n  }\n  return out === 0;\n}\n", "import {AdapterArgs} from '../../runtime/types';\n\nexport enum HmacValidationType {\n  Flow = 'flow',\n  Webhook = 'webhook',\n  FulfillmentService = 'fulfillment_service',\n}\n\nexport interface ValidateParams extends AdapterArgs {\n  /**\n   * The raw body of the request.\n   */\n  rawBody: string;\n}\n\nexport const ValidationErrorReason = {\n  MissingBody: 'missing_body',\n  InvalidHmac: 'invalid_hmac',\n  MissingHmac: 'missing_hmac',\n} as const;\n\nexport type ValidationErrorReasonType =\n  (typeof ValidationErrorReason)[keyof typeof ValidationErrorReason];\n\nexport interface ValidationInvalid {\n  /**\n   * Whether the request is a valid Flow request from Shopify.\n   */\n  valid: false;\n  /**\n   * The reason why the request is not valid.\n   */\n  reason: ValidationErrorReasonType;\n}\n\nexport interface ValidationValid {\n  /**\n   * Whether the request is a valid request from Shopify.\n   */\n  valid: true;\n}\n", "import {logger} from '../logger';\nimport {ShopifyHeader} from '../types';\nimport {\n  AdapterArgs,\n  abstractConvertRequest,\n  getHeader,\n} from '../../runtime/http';\nimport {ConfigInterface} from '../base-types';\nimport {createSHA256HMAC} from '../../runtime/crypto';\nimport {HashFormat} from '../../runtime/crypto/types';\nimport {AuthQuery} from '../auth/oauth/types';\nimport * as ShopifyErrors from '../error';\nimport {safeCompare} from '../auth/oauth/safe-compare';\n\nimport ProcessedQuery from './processed-query';\nimport {\n  ValidationErrorReason,\n  ValidationInvalid,\n  HmacValidationType,\n  ValidationValid,\n  ValidationErrorReasonType,\n} from './types';\n\nconst HMAC_TIMESTAMP_PERMITTED_CLOCK_TOLERANCE_SEC = 90;\n\nexport type HMACSignator = 'admin' | 'appProxy';\n\nexport interface ValidateParams extends AdapterArgs {\n  /**\n   * The type of validation to perform, either 'flow' or 'webhook'.\n   */\n  type: HmacValidationType;\n  /**\n   * The raw body of the request.\n   */\n  rawBody: string;\n}\n\nfunction stringifyQueryForAdmin(query: AuthQuery): string {\n  const processedQuery = new ProcessedQuery();\n  Object.keys(query)\n    .sort((val1, val2) => val1.localeCompare(val2))\n    .forEach((key: string) => processedQuery.put(key, query[key]));\n\n  return processedQuery.stringify(true);\n}\n\nfunction stringifyQueryForAppProxy(query: AuthQuery): string {\n  return Object.entries(query)\n    .sort(([val1], [val2]) => val1.localeCompare(val2))\n    .reduce((acc, [key, value]) => {\n      return `${acc}${key}=${Array.isArray(value) ? value.join(',') : value}`;\n    }, '');\n}\n\nexport function generateLocalHmac(config: ConfigInterface) {\n  return async (\n    params: AuthQuery,\n    signator: HMACSignator = 'admin',\n  ): Promise<string> => {\n    const {hmac, signature, ...query} = params;\n\n    const queryString =\n      signator === 'admin'\n        ? stringifyQueryForAdmin(query)\n        : stringifyQueryForAppProxy(query);\n\n    return createSHA256HMAC(config.apiSecretKey, queryString, HashFormat.Hex);\n  };\n}\n\nexport function validateHmac(config: ConfigInterface) {\n  return async (\n    query: AuthQuery,\n    {signator}: {signator: HMACSignator} = {signator: 'admin'},\n  ): Promise<boolean> => {\n    if (signator === 'admin' && !query.hmac) {\n      throw new ShopifyErrors.InvalidHmacError(\n        'Query does not contain an HMAC value.',\n      );\n    }\n\n    if (signator === 'appProxy' && !query.signature) {\n      throw new ShopifyErrors.InvalidHmacError(\n        'Query does not contain a signature value.',\n      );\n    }\n\n    validateHmacTimestamp(query);\n\n    const hmac = signator === 'appProxy' ? query.signature : query.hmac;\n    const localHmac = await generateLocalHmac(config)(query, signator);\n\n    return safeCompare(hmac as string, localHmac);\n  };\n}\n\nexport async function validateHmacString(\n  config: ConfigInterface,\n  data: string,\n  hmac: string,\n  format: HashFormat,\n) {\n  const localHmac = await createSHA256HMAC(config.apiSecretKey, data, format);\n\n  return safeCompare(hmac, localHmac);\n}\n\nexport function getCurrentTimeInSec() {\n  return Math.trunc(Date.now() / 1000);\n}\n\nexport function validateHmacFromRequestFactory(config: ConfigInterface) {\n  return async function validateHmacFromRequest({\n    type,\n    rawBody,\n    ...adapterArgs\n  }: ValidateParams): Promise<ValidationInvalid | ValidationValid> {\n    const request = await abstractConvertRequest(adapterArgs);\n    if (!rawBody.length) {\n      return fail(ValidationErrorReason.MissingBody, type, config);\n    }\n    const hmac = getHeader(request.headers, ShopifyHeader.Hmac);\n    if (!hmac) {\n      return fail(ValidationErrorReason.MissingHmac, type, config);\n    }\n    const validHmac = await validateHmacString(\n      config,\n      rawBody,\n      hmac,\n      HashFormat.Base64,\n    );\n    if (!validHmac) {\n      return fail(ValidationErrorReason.InvalidHmac, type, config);\n    }\n\n    return succeed(type, config);\n  };\n}\n\nfunction validateHmacTimestamp(query: AuthQuery) {\n  if (\n    Math.abs(getCurrentTimeInSec() - Number(query.timestamp)) >\n    HMAC_TIMESTAMP_PERMITTED_CLOCK_TOLERANCE_SEC\n  ) {\n    throw new ShopifyErrors.InvalidHmacError(\n      'HMAC timestamp is outside of the tolerance range',\n    );\n  }\n}\n\nasync function fail(\n  reason: ValidationErrorReasonType,\n  type: HmacValidationType,\n  config: ConfigInterface,\n): Promise<ValidationInvalid> {\n  const log = logger(config);\n  await log.debug(`${type} request is not valid`, {reason});\n\n  return {\n    valid: false,\n    reason,\n  };\n}\n\nasync function succeed(\n  type: HmacValidationType,\n  config: ConfigInterface,\n): Promise<ValidationValid> {\n  const log = logger(config);\n  await log.debug(`${type} request is valid`);\n\n  return {\n    valid: true,\n  };\n}\n", "export function decodeHost(host: string): string {\n  return atob(host);\n}\n", "// Converts admin.shopify.com/store/my-shop to my-shop.myshopify.com\nexport function shopAdminUrlToLegacyUrl(shopAdminUrl: string): string | null {\n  const shopUrl = removeProtocol(shopAdminUrl);\n\n  const isShopAdminUrl = shopUrl.split('.')[0] === 'admin';\n\n  if (!isShopAdminUrl) {\n    return null;\n  }\n\n  const regex = new RegExp(`admin\\\\..+/store/([^/]+)`);\n  const matches = shopUrl.match(regex);\n\n  if (matches && matches.length === 2) {\n    const shopName = matches[1];\n    const isSpinUrl = shopUrl.includes('spin.dev/store/');\n    const isLocalUrl = shopUrl.includes('shop.dev/store/');\n\n    if (isSpinUrl) {\n      return spinAdminUrlToLegacyUrl(shopUrl);\n    } else if (isLocalUrl) {\n      return localAdminUrlToLegacyUrl(shopUrl);\n    } else {\n      return `${shopName}.myshopify.com`;\n    }\n  } else {\n    return null;\n  }\n}\n\n// Converts my-shop.myshopify.com to admin.shopify.com/store/my-shop\nexport function legacyUrlToShopAdminUrl(legacyAdminUrl: string): string | null {\n  const shopUrl = removeProtocol(legacyAdminUrl);\n  const regex = new RegExp(`(.+)\\\\.myshopify\\\\.com$`);\n  const matches = shopUrl.match(regex);\n\n  if (matches && matches.length === 2) {\n    const shopName = matches[1];\n    return `admin.shopify.com/store/${shopName}`;\n  } else {\n    const isSpinUrl = shopUrl.endsWith('spin.dev');\n    const isLocalUrl = shopUrl.endsWith('shop.dev');\n    if (isSpinUrl) {\n      return spinLegacyUrlToAdminUrl(shopUrl);\n    } else if (isLocalUrl) {\n      return localLegacyUrlToAdminUrl(shopUrl);\n    } else {\n      return null;\n    }\n  }\n}\n\nfunction spinAdminUrlToLegacyUrl(shopAdminUrl: string) {\n  const spinRegex = new RegExp(`admin\\\\.web\\\\.(.+\\\\.spin\\\\.dev)/store/(.+)`);\n  const spinMatches = shopAdminUrl.match(spinRegex);\n\n  if (spinMatches && spinMatches.length === 3) {\n    const spinUrl = spinMatches[1];\n    const shopName = spinMatches[2];\n    return `${shopName}.shopify.${spinUrl}`;\n  } else {\n    return null;\n  }\n}\n\nfunction localAdminUrlToLegacyUrl(shopAdminUrl: string) {\n  const localRegex = new RegExp(`admin\\\\.shop\\\\.dev/store/(.+)`);\n  const localMatches = shopAdminUrl.match(localRegex);\n\n  if (localMatches && localMatches.length === 2) {\n    const shopName = localMatches[1];\n    return `${shopName}.shop.dev`;\n  } else {\n    return null;\n  }\n}\n\nfunction spinLegacyUrlToAdminUrl(legacyAdminUrl: string) {\n  const spinRegex = new RegExp(`(.+)\\\\.shopify\\\\.(.+\\\\.spin\\\\.dev)`);\n  const spinMatches = legacyAdminUrl.match(spinRegex);\n\n  if (spinMatches && spinMatches.length === 3) {\n    const shopName = spinMatches[1];\n    const spinUrl = spinMatches[2];\n    return `admin.web.${spinUrl}/store/${shopName}`;\n  } else {\n    return null;\n  }\n}\n\nfunction localLegacyUrlToAdminUrl(legacyAdminUrl: string) {\n  const localRegex = new RegExp(`(.+)\\\\.shop\\\\.dev$`);\n  const localMatches = legacyAdminUrl.match(localRegex);\n\n  if (localMatches && localMatches.length === 2) {\n    const shopName = localMatches[1];\n    return `admin.shop.dev/store/${shopName}`;\n  } else {\n    return null;\n  }\n}\nfunction removeProtocol(url: string): string {\n  return url.replace(/^https?:\\/\\//, '').replace(/\\/$/, '');\n}\n", "import {ConfigInterface} from '../base-types';\nimport {InvalidHostError, InvalidShopError} from '../error';\nimport {decodeHost} from '../auth/decode-host';\n\nimport {shopAdminUrlToLegacyUrl} from './shop-admin-url-helper';\n\nexport function sanitizeShop(config: ConfigInterface) {\n  return (shop: string, throwOnInvalid = false): string | null => {\n    let shopUrl = shop;\n    const domainsRegex = [\n      'myshopify\\\\.com',\n      'shopify\\\\.com',\n      'myshopify\\\\.io',\n      'shop\\\\.dev',\n    ];\n    if (config.customShopDomains) {\n      domainsRegex.push(\n        ...config.customShopDomains.map((regex) =>\n          typeof regex === 'string' ? regex : regex.source,\n        ),\n      );\n    }\n\n    const shopUrlRegex = new RegExp(\n      `^[a-zA-Z0-9][a-zA-Z0-9-_]*\\\\.(${domainsRegex.join('|')})[/]*$`,\n    );\n\n    const shopAdminRegex = new RegExp(\n      `^admin\\\\.(${domainsRegex.join('|')})/store/([a-zA-Z0-9][a-zA-Z0-9-_]*)$`,\n    );\n\n    const isShopAdminUrl = shopAdminRegex.test(shopUrl);\n    if (isShopAdminUrl) {\n      shopUrl = shopAdminUrlToLegacyUrl(shopUrl) || '';\n    }\n\n    const sanitizedShop = shopUrlRegex.test(shopUrl) ? shopUrl : null;\n    if (!sanitizedShop && throwOnInvalid) {\n      throw new InvalidShopError('Received invalid shop argument');\n    }\n\n    return sanitizedShop;\n  };\n}\n\nexport function sanitizeHost() {\n  return (host: string, throwOnInvalid = false): string | null => {\n    const base64regex = /^[0-9a-zA-Z+/]+={0,2}$/;\n\n    let sanitizedHost = base64regex.test(host) ? host : null;\n    if (sanitizedHost) {\n      const {hostname} = new URL(`https://${decodeHost(sanitizedHost)}`);\n\n      const originsRegex = [\n        'myshopify\\\\.com',\n        'shopify\\\\.com',\n        'myshopify\\\\.io',\n        'spin\\\\.dev',\n        'shop\\\\.dev',\n      ];\n\n      const hostRegex = new RegExp(`\\\\.(${originsRegex.join('|')})$`);\n      if (!hostRegex.test(hostname)) {\n        sanitizedHost = null;\n      }\n    }\n    if (!sanitizedHost && throwOnInvalid) {\n      throw new InvalidHostError('Received invalid host argument');\n    }\n\n    return sanitizedHost;\n  };\n}\n", "import {\n  AllOperations,\n  ApiClientRequestOptions,\n  SearchParams,\n} from '@shopify/admin-api-client';\n\nimport {Session} from '../session/session';\nimport type {ApiVersion, Method} from '../types';\nimport {Headers} from '../../runtime/http';\n\nimport {GraphqlClient} from './admin/graphql/client';\nimport {StorefrontClient} from './storefront/client';\nimport type {GraphqlProxy} from './graphql_proxy/types';\nimport {RestClient} from './admin/rest/client';\n\nexport * from './admin/types';\nexport * from './graphql_proxy/types';\n\nexport interface ClientArgs {\n  session: Session;\n  apiVersion?: ApiVersion;\n  retries?: number;\n}\n\n/**\n * Headers to be sent with the request.\n */\nexport type HeaderParams = Record<string, string | number | string[]>;\n\n/* eslint-disable @shopify/typescript/prefer-pascal-case-enums */\nexport enum DataType {\n  JSON = 'application/json',\n  GraphQL = 'application/graphql',\n  URLEncoded = 'application/x-www-form-urlencoded',\n}\n\n/* eslint-enable @shopify/typescript/prefer-pascal-case-enums */\n\nexport interface GetRequestParams {\n  /**\n   * The path to the resource, relative to the API version root.\n   */\n  path: string;\n  /**\n   * The type of data expected in the response.\n   */\n  type?: DataType;\n  /**\n   * The request body.\n   */\n  data?: Record<string, any> | string;\n  /**\n   * Query parameters to be sent with the request.\n   */\n  query?: SearchParams;\n  /**\n   * Additional headers to be sent with the request.\n   */\n  extraHeaders?: HeaderParams;\n  /**\n   * The maximum number of times the request can be made if it fails with a throttling or server error.\n   */\n  tries?: number;\n}\n\nexport type PostRequestParams = GetRequestParams & {\n  data: Record<string, any> | string;\n};\n\nexport type PutRequestParams = PostRequestParams;\n\nexport type DeleteRequestParams = GetRequestParams;\n\nexport type RequestParams = (GetRequestParams | PostRequestParams) & {\n  method: Method;\n};\n\nexport interface RequestReturn<T = unknown> {\n  /**\n   * The response body.\n   */\n  body: T;\n  /**\n   * The response headers.\n   */\n  headers: Headers;\n}\n\nexport type GraphqlParams = Omit<PostRequestParams, 'path' | 'type'>;\n\nexport interface GraphqlClientParams {\n  session: Session;\n  apiVersion?: ApiVersion;\n}\n\nexport interface GraphqlQueryOptions<\n  Operation extends keyof Operations,\n  Operations extends AllOperations,\n> {\n  /**\n   * The variables to include in the operation.\n   */\n  variables?: ApiClientRequestOptions<Operation, Operations>['variables'];\n  /**\n   * Additional headers to be sent with the request.\n   */\n  headers?: Record<string, string | number>;\n  /**\n   * The maximum number of times to retry the request if it fails with a throttling or server error.\n   */\n  retries?: number;\n  /**\n   * An optional AbortSignal to cancel the request.\n   */\n  signal?: AbortSignal;\n}\n\nexport {GraphqlClient} from './admin/graphql/client';\nexport {RestClient} from './admin/rest/client';\n\nexport interface ShopifyClients {\n  Rest: typeof RestClient;\n  Graphql: typeof GraphqlClient;\n  Storefront: typeof StorefrontClient;\n  graphqlProxy: GraphqlProxy;\n}\n", "import {logger} from '../logger';\nimport {LogSeverity} from '../types';\nimport {abstractFetch} from '../../runtime';\nimport {ConfigInterface} from '../base-types';\n\nexport function fetchRequestFactory(config: ConfigInterface) {\n  return async function fetchRequest(\n    url: string,\n    options?: RequestInit,\n  ): Promise<Response> {\n    const log = logger(config);\n    const doLog =\n      config.logger.httpRequests && config.logger.level === LogSeverity.Debug;\n\n    if (doLog) {\n      log.debug('Making HTTP request', {\n        method: options?.method || 'GET',\n        url,\n        ...(options?.body && {body: options?.body}),\n      });\n    }\n\n    const response = await abstractFetch(url, options);\n\n    if (doLog) {\n      log.debug('HTTP request completed', {\n        method: options?.method || 'GET',\n        url,\n        status: response.status,\n      });\n    }\n\n    return response;\n  };\n}\n", "import {AdapterArgs} from '../../../runtime/http/types';\n\nexport const SESSION_COOKIE_NAME = 'shopify_app_session';\nexport const STATE_COOKIE_NAME = 'shopify_app_state';\n\nexport interface AuthQuery {\n  [key: string]: string | undefined;\n  hmac?: string;\n  signature?: string;\n}\n\nexport interface BeginParams extends AdapterArgs {\n  /**\n   * The shop domain. For example: `{exampleshop}.myshopify.com`.\n   */\n  shop: string;\n  /**\n   * The path to the callback endpoint, with a leading `/`.\n   * This URL must be allowed in the Partners dashboard, or using the CLI to run your app.\n   */\n  callbackPath: string;\n  /**\n   * Defines if the session is online or offline.\n   * Learn more about [OAuth access modes](https://shopify.dev/docs/apps/auth/oauth/access-modes).\n   */\n  isOnline: boolean;\n}\n\nexport interface CallbackParams extends AdapterArgs {}\n\nexport interface AccessTokenResponse {\n  access_token: string;\n  scope: string;\n}\n\nexport interface OnlineAccessInfo {\n  /**\n   * How long the access token is valid for, in seconds.\n   */\n  expires_in: number;\n  /**\n   * The effective set of scopes for the session.\n   */\n  associated_user_scope: string;\n  /**\n   * The user associated with the access token.\n   */\n  associated_user: OnlineAccessUser;\n}\n\nexport interface OfflineAccessInfo {\n  /**\n   * How long the access token is valid for, in seconds.\n   */\n  expires_in?: number;\n}\n\nexport interface OnlineAccessUser {\n  /**\n   * The user's ID.\n   */\n  id: number;\n  /**\n   * The user's first name.\n   */\n  first_name: string;\n  /**\n   * The user's last name.\n   */\n  last_name: string;\n  /**\n   * The user's email address.\n   */\n  email: string;\n  /**\n   * Whether the user has verified their email address.\n   */\n  email_verified: boolean;\n  /**\n   * Whether the user is the account owner.\n   */\n  account_owner: boolean;\n  /**\n   * The user's locale.\n   */\n  locale: string;\n  /**\n   * Whether the user is a collaborator.\n   */\n  collaborator: boolean;\n}\n\nexport interface OnlineAccessResponse\n  extends AccessTokenResponse,\n    OnlineAccessInfo {}\n\nexport interface OfflineAccessResponse\n  extends AccessTokenResponse,\n    OfflineAccessInfo {}\n", "export type Nonce = () => string;\n\nexport function nonce(): string {\n  const length = 15;\n\n  const bytes = crypto.getRandomValues(new Uint8Array(length));\n\n  const nonce = bytes\n    .map((byte: number) => {\n      return byte % 10;\n    })\n    .join('');\n\n  return nonce;\n}\n", "/* eslint-disable no-fallthrough */\nimport {InvalidSession} from '../error';\nimport {OnlineAccessInfo} from '../auth/oauth/types';\nimport {AuthScopes} from '../auth/scopes';\n\nimport {SessionParams} from './types';\n\nconst propertiesToSave = [\n  'id',\n  'shop',\n  'state',\n  'isOnline',\n  'scope',\n  'accessToken',\n  'expires',\n  'onlineAccessInfo',\n];\n\n/**\n * Stores App information from logged in merchants so they can make authenticated requests to the Admin API.\n */\nexport class Session {\n  public static fromPropertyArray(\n    entries: [string, string | number | boolean][],\n    returnUserData = false,\n  ): Session {\n    if (!Array.isArray(entries)) {\n      throw new InvalidSession(\n        'The parameter is not an array: a Session cannot be created from this object.',\n      );\n    }\n\n    const obj = Object.fromEntries(\n      entries\n        .filter(([_key, value]) => value !== null && value !== undefined)\n        // Sanitize keys\n        .map(([key, value]) => {\n          switch (key.toLowerCase()) {\n            case 'isonline':\n              return ['isOnline', value];\n            case 'accesstoken':\n              return ['accessToken', value];\n            case 'onlineaccessinfo':\n              return ['onlineAccessInfo', value];\n            case 'userid':\n              return ['userId', value];\n            case 'firstname':\n              return ['firstName', value];\n            case 'lastname':\n              return ['lastName', value];\n            case 'accountowner':\n              return ['accountOwner', value];\n            case 'emailverified':\n              return ['emailVerified', value];\n            default:\n              return [key.toLowerCase(), value];\n          }\n        }),\n    );\n\n    const sessionData = {} as SessionParams;\n    const onlineAccessInfo = {\n      associated_user: {},\n    } as OnlineAccessInfo;\n    Object.entries(obj).forEach(([key, value]) => {\n      switch (key) {\n        case 'isOnline':\n          if (typeof value === 'string') {\n            sessionData[key] = value.toString().toLowerCase() === 'true';\n          } else if (typeof value === 'number') {\n            sessionData[key] = Boolean(value);\n          } else {\n            sessionData[key] = value;\n          }\n          break;\n        case 'scope':\n          sessionData[key] = value.toString();\n          break;\n        case 'expires':\n          sessionData[key] = value ? new Date(Number(value)) : undefined;\n          break;\n        case 'onlineAccessInfo':\n          onlineAccessInfo.associated_user.id = Number(value);\n          break;\n        case 'userId':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.id = Number(value);\n            break;\n          }\n        case 'firstName':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.first_name = String(value);\n            break;\n          }\n        case 'lastName':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.last_name = String(value);\n            break;\n          }\n        case 'email':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.email = String(value);\n            break;\n          }\n        case 'accountOwner':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.account_owner = Boolean(value);\n            break;\n          }\n        case 'locale':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.locale = String(value);\n            break;\n          }\n        case 'collaborator':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.collaborator = Boolean(value);\n            break;\n          }\n        case 'emailVerified':\n          if (returnUserData) {\n            onlineAccessInfo.associated_user.email_verified = Boolean(value);\n            break;\n          }\n        // Return any user keys as passed in\n        default:\n          sessionData[key] = value;\n      }\n    });\n    if (sessionData.isOnline) {\n      sessionData.onlineAccessInfo = onlineAccessInfo;\n    }\n    const session = new Session(sessionData);\n    return session;\n  }\n\n  /**\n   * The unique identifier for the session.\n   */\n  readonly id: string;\n  /**\n   * The Shopify shop domain, such as `example.myshopify.com`.\n   */\n  public shop: string;\n  /**\n   * The state of the session. Used for the OAuth authentication code flow.\n   */\n  public state: string;\n  /**\n   * Whether the access token in the session is online or offline.\n   */\n  public isOnline: boolean;\n  /**\n   * The desired scopes for the access token, at the time the session was created.\n   */\n  public scope?: string;\n  /**\n   * The date the access token expires.\n   */\n  public expires?: Date;\n  /**\n   * The access token for the session.\n   */\n  public accessToken?: string;\n  /**\n   * Information on the user for the session. Only present for online sessions.\n   */\n  public onlineAccessInfo?: OnlineAccessInfo;\n\n  constructor(params: SessionParams) {\n    Object.assign(this, params);\n  }\n\n  /**\n   * Whether the session is active. Active sessions have an access token that is not expired, and has has the given\n   * scopes if scopes is equal to a truthy value.\n   */\n  public isActive(\n    scopes: AuthScopes | string | string[] | undefined,\n    withinMillisecondsOfExpiry = 500,\n  ): boolean {\n    const hasAccessToken = Boolean(this.accessToken);\n    const isTokenNotExpired = !this.isExpired(withinMillisecondsOfExpiry);\n    const isScopeChanged = this.isScopeChanged(scopes);\n    return !isScopeChanged && hasAccessToken && isTokenNotExpired;\n  }\n\n  /**\n   * Whether the access token includes the given scopes if they are provided.\n   */\n  public isScopeChanged(\n    scopes: AuthScopes | string | string[] | undefined,\n  ): boolean {\n    if (typeof scopes === 'undefined') {\n      return false;\n    }\n\n    return !this.isScopeIncluded(scopes);\n  }\n\n  /**\n   * Whether the access token includes the given scopes.\n   */\n  public isScopeIncluded(scopes: AuthScopes | string | string[]): boolean {\n    const requiredScopes =\n      scopes instanceof AuthScopes ? scopes : new AuthScopes(scopes);\n    const sessionScopes = new AuthScopes(this.scope);\n\n    return sessionScopes.has(requiredScopes);\n  }\n\n  /**\n   * Whether the access token is expired.\n   */\n  public isExpired(withinMillisecondsOfExpiry = 0): boolean {\n    return Boolean(\n      this.expires &&\n        this.expires.getTime() - withinMillisecondsOfExpiry < Date.now(),\n    );\n  }\n\n  /**\n   * Converts an object with data into a Session.\n   */\n  public toObject(): SessionParams {\n    const object: SessionParams = {\n      id: this.id,\n      shop: this.shop,\n      state: this.state,\n      isOnline: this.isOnline,\n    };\n\n    if (this.scope) {\n      object.scope = this.scope;\n    }\n    if (this.expires) {\n      object.expires = this.expires;\n    }\n    if (this.accessToken) {\n      object.accessToken = this.accessToken;\n    }\n    if (this.onlineAccessInfo) {\n      object.onlineAccessInfo = this.onlineAccessInfo;\n    }\n    return object;\n  }\n\n  /**\n   * Checks whether the given session is equal to this session.\n   */\n  public equals(other: Session | undefined): boolean {\n    if (!other) return false;\n\n    const mandatoryPropsMatch =\n      this.id === other.id &&\n      this.shop === other.shop &&\n      this.state === other.state &&\n      this.isOnline === other.isOnline;\n\n    if (!mandatoryPropsMatch) return false;\n\n    const copyA = this.toPropertyArray(true);\n    copyA.sort(([k1], [k2]) => (k1 < k2 ? -1 : 1));\n\n    const copyB = other.toPropertyArray(true);\n    copyB.sort(([k1], [k2]) => (k1 < k2 ? -1 : 1));\n\n    return JSON.stringify(copyA) === JSON.stringify(copyB);\n  }\n\n  /**\n   * Converts the session into an array of key-value pairs.\n   */\n  public toPropertyArray(\n    returnUserData = false,\n  ): [string, string | number | boolean][] {\n    return (\n      Object.entries(this)\n        .filter(\n          ([key, value]) =>\n            propertiesToSave.includes(key) &&\n            value !== undefined &&\n            value !== null,\n        )\n        // Prepare values for db storage\n        .flatMap(([key, value]): [string, string | number | boolean][] => {\n          switch (key) {\n            case 'expires':\n              return [[key, value ? value.getTime() : undefined]];\n            case 'onlineAccessInfo':\n              // eslint-disable-next-line no-negated-condition\n              if (!returnUserData) {\n                return [[key, value.associated_user.id]];\n              } else {\n                return [\n                  ['userId', value?.associated_user?.id],\n                  ['firstName', value?.associated_user?.first_name],\n                  ['lastName', value?.associated_user?.last_name],\n                  ['email', value?.associated_user?.email],\n                  ['locale', value?.associated_user?.locale],\n                  ['emailVerified', value?.associated_user?.email_verified],\n                  ['accountOwner', value?.associated_user?.account_owner],\n                  ['collaborator', value?.associated_user?.collaborator],\n                ];\n              }\n            default:\n              return [[key, value]];\n          }\n        })\n        // Filter out tuples with undefined values\n        .filter(([_key, value]) => value !== undefined)\n    );\n  }\n}\n", "export function getHMACKey(key: string): Uint8Array {\n  const arrayBuffer = new Uint8Array(key.length);\n  for (let i = 0, keyLen = key.length; i < keyLen; i++) {\n    arrayBuffer[i] = key.charCodeAt(i);\n  }\n\n  return arrayBuffer;\n}\n", "import * as jose from 'jose';\n\nimport {ConfigInterface} from '../base-types';\nimport * as ShopifyErrors from '../error';\nimport {getHMACKey} from '../utils/get-hmac-key';\n\nimport {JwtPayload} from './types';\n\nconst JWT_PERMITTED_CLOCK_TOLERANCE = 10;\n\nexport interface DecodeSessionTokenOptions {\n  checkAudience?: boolean;\n}\n\nexport function decodeSessionToken(config: ConfigInterface) {\n  return async (\n    token: string,\n    {checkAudience = true}: DecodeSessionTokenOptions = {},\n  ): Promise<JwtPayload> => {\n    let payload: JwtPayload;\n    try {\n      payload = (\n        await jose.jwtVerify(token, getHMACKey(config.apiSecretKey), {\n          algorithms: ['HS256'],\n          clockTolerance: JWT_PERMITTED_CLOCK_TOLERANCE,\n        })\n      ).payload as unknown as JwtPayload;\n    } catch (error) {\n      throw new ShopifyErrors.InvalidJwtError(\n        `Failed to parse session token '${token}': ${error.message}`,\n      );\n    }\n\n    // The exp and nbf fields are validated by the JWT library\n\n    if (checkAudience && payload.aud !== config.apiKey) {\n      throw new ShopifyErrors.InvalidJwtError(\n        'Session token had invalid API key',\n      );\n    }\n\n    return payload;\n  };\n}\n", "import {ConfigInterface} from '../base-types';\nimport {SESSION_COOKIE_NAME} from '../auth/oauth/types';\nimport {\n  abstractConvertRequest,\n  Cookies,\n  NormalizedResponse,\n} from '../../runtime/http';\nimport {sanitizeShop} from '../utils/shop-validator';\nimport {logger} from '../logger';\nimport * as ShopifyErrors from '../error';\n\nimport {decodeSessionToken} from './decode-session-token';\nimport type {GetCurrentSessionIdParams} from './types';\nimport {Session} from './session';\n\nexport function getJwtSessionId(config: ConfigInterface) {\n  return (shop: string, userId: string): string => {\n    return `${sanitizeShop(config)(shop, true)}_${userId}`;\n  };\n}\n\nexport function getOfflineId(config: ConfigInterface) {\n  return (shop: string): string => {\n    return `offline_${sanitizeShop(config)(shop, true)}`;\n  };\n}\n\nexport function getCurrentSessionId(config: ConfigInterface) {\n  return async function getCurrentSessionId({\n    isOnline,\n    ...adapterArgs\n  }: GetCurrentSessionIdParams): Promise<string | undefined> {\n    const request = await abstractConvertRequest(adapterArgs);\n\n    const log = logger(config);\n\n    if (config.isEmbeddedApp) {\n      log.debug('App is embedded, looking for session id in JWT payload', {\n        isOnline,\n      });\n\n      const authHeader = request.headers.Authorization;\n      if (authHeader) {\n        const matches = (\n          typeof authHeader === 'string' ? authHeader : authHeader[0]\n        ).match(/^Bearer (.+)$/);\n        if (!matches) {\n          log.error('Missing Bearer token in authorization header', {isOnline});\n\n          throw new ShopifyErrors.MissingJwtTokenError(\n            'Missing Bearer token in authorization header',\n          );\n        }\n\n        const jwtPayload = await decodeSessionToken(config)(matches[1]);\n        const shop = jwtPayload.dest.replace(/^https:\\/\\//, '');\n\n        log.debug('Found valid JWT payload', {shop, isOnline});\n\n        if (isOnline) {\n          return getJwtSessionId(config)(shop, jwtPayload.sub);\n        } else {\n          return getOfflineId(config)(shop);\n        }\n      } else {\n        log.error(\n          'Missing Authorization header review App Bridge configuration',\n          {isOnline},\n        );\n      }\n    } else {\n      log.debug('App is not embedded, looking for session id in cookies', {\n        isOnline,\n      });\n\n      const cookies = new Cookies(request, {} as NormalizedResponse, {\n        keys: [config.apiSecretKey],\n      });\n      return cookies.getAndVerify(SESSION_COOKIE_NAME);\n    }\n\n    return undefined;\n  };\n}\n\nexport function customAppSession(config: ConfigInterface) {\n  return (shop: string): Session => {\n    return new Session({\n      id: '',\n      shop: `${sanitizeShop(config)(shop, true)}`,\n      state: '',\n      isOnline: false,\n    });\n  };\n}\n", "import {Session} from '../../session/session';\nimport {ConfigInterface} from '../../base-types';\nimport {logger} from '../../logger';\nimport {getJwtSessionId, getOfflineId} from '../../session/session-utils';\n\nimport {\n  AccessTokenResponse,\n  OnlineAccessResponse,\n  OnlineAccessInfo,\n  OfflineAccessResponse,\n} from './types';\n\nexport function createSession({\n  config,\n  accessTokenResponse,\n  shop,\n  state,\n}: {\n  config: ConfigInterface;\n  accessTokenResponse: AccessTokenResponse;\n  shop: string;\n  state: string;\n}): Session {\n  const associatedUser = (accessTokenResponse as OnlineAccessResponse)\n    .associated_user;\n  const isOnline = Boolean(associatedUser);\n\n  logger(config).info('Creating new session', {shop, isOnline});\n\n  const getSessionExpiration = (expires_in: number) =>\n    new Date(Date.now() + expires_in * 1000);\n\n  const getOnlineSessionProperties = (responseBody: OnlineAccessResponse) => {\n    const {access_token, scope, ...rest} = responseBody;\n    const sessionId = config.isEmbeddedApp\n      ? getJwtSessionId(config)(\n          shop,\n          `${(rest as OnlineAccessInfo).associated_user.id}`,\n        )\n      : crypto.randomUUID();\n\n    return {\n      id: sessionId,\n      onlineAccessInfo: rest,\n      expires: getSessionExpiration(rest.expires_in),\n    };\n  };\n\n  const getOfflineSessionProperties = (responseBody: OfflineAccessResponse) => {\n    const {expires_in} = responseBody;\n    return {\n      id: getOfflineId(config)(shop),\n      ...(expires_in && {expires: getSessionExpiration(expires_in)}),\n    };\n  };\n\n  return new Session({\n    shop,\n    state,\n    isOnline,\n    accessToken: accessTokenResponse.access_token,\n    scope: accessTokenResponse.scope,\n    ...(isOnline\n      ? getOnlineSessionProperties(accessTokenResponse as OnlineAccessResponse)\n      : getOfflineSessionProperties(\n          accessTokenResponse as OfflineAccessResponse,\n        )),\n  });\n}\n", "import {isbot} from 'isbot';\n\nimport {throwFailedRequest} from '../../clients/common';\nimport ProcessedQuery from '../../utils/processed-query';\nimport {ConfigInterface} from '../../base-types';\nimport * as ShopifyErrors from '../../error';\nimport {validateHmac} from '../../utils/hmac-validator';\nimport {sanitizeShop} from '../../utils/shop-validator';\nimport {Session} from '../../session/session';\nimport {\n  abstractConvertRequest,\n  abstractConvertIncomingResponse,\n  abstractConvertResponse,\n  abstractConvertHeaders,\n  AdapterResponse,\n  AdapterHeaders,\n  Cookies,\n  NormalizedResponse,\n  NormalizedRequest,\n} from '../../../runtime/http';\nimport {logger, ShopifyLogger} from '../../logger';\nimport {DataType} from '../../clients/types';\nimport {fetchRequestFactory} from '../../utils/fetch-request';\n\nimport {\n  SESSION_COOKIE_NAME,\n  STATE_COOKIE_NAME,\n  BeginParams,\n  CallbackParams,\n  AuthQuery,\n  AccessTokenResponse,\n} from './types';\nimport {nonce} from './nonce';\nimport {safeCompare} from './safe-compare';\nimport {createSession} from './create-session';\n\nexport type OAuthBegin = (beginParams: BeginParams) => Promise<AdapterResponse>;\n\nexport interface CallbackResponse<T = AdapterHeaders> {\n  headers: T;\n  session: Session;\n}\n\nexport type OAuthCallback = <T = AdapterHeaders>(\n  callbackParams: CallbackParams,\n) => Promise<CallbackResponse<T>>;\n\ninterface BotLog {\n  request: NormalizedRequest;\n  log: ShopifyLogger;\n  func: string;\n}\n\nconst logForBot = ({request, log, func}: BotLog) => {\n  log.debug(`Possible bot request to auth ${func}: `, {\n    userAgent: request.headers['User-Agent'],\n  });\n};\n\nexport function begin(config: ConfigInterface): OAuthBegin {\n  return async ({\n    shop,\n    callbackPath,\n    isOnline,\n    ...adapterArgs\n  }: BeginParams): Promise<AdapterResponse> => {\n    throwIfCustomStoreApp(\n      config.isCustomStoreApp,\n      'Cannot perform OAuth for private apps',\n    );\n\n    const log = logger(config);\n    log.info('Beginning OAuth', {shop, isOnline, callbackPath});\n\n    const request = await abstractConvertRequest(adapterArgs);\n    const response = await abstractConvertIncomingResponse(adapterArgs);\n\n    let userAgent = request.headers['User-Agent'];\n    if (Array.isArray(userAgent)) {\n      userAgent = userAgent[0];\n    }\n    if (isbot(userAgent)) {\n      logForBot({request, log, func: 'begin'});\n      response.statusCode = 410;\n      return abstractConvertResponse(response, adapterArgs);\n    }\n\n    const cookies = new Cookies(request, response, {\n      keys: [config.apiSecretKey],\n      secure: true,\n    });\n\n    const state = nonce();\n\n    await cookies.setAndSign(STATE_COOKIE_NAME, state, {\n      expires: new Date(Date.now() + 60000),\n      sameSite: 'lax',\n      secure: true,\n      path: callbackPath,\n    });\n\n    const scopes = config.scopes ? config.scopes.toString() : '';\n    const query = {\n      client_id: config.apiKey,\n      scope: scopes,\n      redirect_uri: `${config.hostScheme}://${config.hostName}${callbackPath}`,\n      state,\n      'grant_options[]': isOnline ? 'per-user' : '',\n    };\n    const processedQuery = new ProcessedQuery();\n    processedQuery.putAll(query);\n\n    const cleanShop = sanitizeShop(config)(shop, true)!;\n    const redirectUrl = `https://${cleanShop}/admin/oauth/authorize${processedQuery.stringify()}`;\n    response.statusCode = 302;\n    response.statusText = 'Found';\n    response.headers = {\n      ...response.headers,\n      ...cookies.response.headers!,\n      Location: redirectUrl,\n    };\n\n    log.debug(`OAuth started, redirecting to ${redirectUrl}`, {shop, isOnline});\n\n    return abstractConvertResponse(response, adapterArgs);\n  };\n}\n\nexport function callback(config: ConfigInterface): OAuthCallback {\n  return async function callback<T = AdapterHeaders>({\n    ...adapterArgs\n  }: CallbackParams): Promise<CallbackResponse<T>> {\n    throwIfCustomStoreApp(\n      config.isCustomStoreApp,\n      'Cannot perform OAuth for private apps',\n    );\n\n    const log = logger(config);\n\n    const request = await abstractConvertRequest(adapterArgs);\n\n    const query = new URL(\n      request.url,\n      `${config.hostScheme}://${config.hostName}`,\n    ).searchParams;\n    const shop = query.get('shop')!;\n\n    const response = {} as NormalizedResponse;\n    let userAgent = request.headers['User-Agent'];\n    if (Array.isArray(userAgent)) {\n      userAgent = userAgent[0];\n    }\n    if (isbot(userAgent)) {\n      logForBot({request, log, func: 'callback'});\n      throw new ShopifyErrors.BotActivityDetected(\n        'Invalid OAuth callback initiated by bot',\n      );\n    }\n\n    log.info('Completing OAuth', {shop});\n\n    const cookies = new Cookies(request, response, {\n      keys: [config.apiSecretKey],\n      secure: true,\n    });\n\n    const stateFromCookie = await cookies.getAndVerify(STATE_COOKIE_NAME);\n    cookies.deleteCookie(STATE_COOKIE_NAME);\n    if (!stateFromCookie) {\n      log.error('Could not find OAuth cookie', {shop});\n\n      throw new ShopifyErrors.CookieNotFound(\n        `Cannot complete OAuth process. Could not find an OAuth cookie for shop url: ${shop}`,\n      );\n    }\n\n    const authQuery: AuthQuery = Object.fromEntries(query.entries());\n    if (!(await validQuery({config, query: authQuery, stateFromCookie}))) {\n      log.error('Invalid OAuth callback', {shop, stateFromCookie});\n\n      throw new ShopifyErrors.InvalidOAuthError('Invalid OAuth callback.');\n    }\n\n    log.debug('OAuth request is valid, requesting access token', {shop});\n\n    const body = {\n      client_id: config.apiKey,\n      client_secret: config.apiSecretKey,\n      code: query.get('code'),\n    };\n\n    const cleanShop = sanitizeShop(config)(query.get('shop')!, true)!;\n\n    const postResponse = await fetchRequestFactory(config)(\n      `https://${cleanShop}/admin/oauth/access_token`,\n      {\n        method: 'POST',\n        body: JSON.stringify(body),\n        headers: {\n          'Content-Type': DataType.JSON,\n          Accept: DataType.JSON,\n        },\n      },\n    );\n\n    if (!postResponse.ok) {\n      throwFailedRequest(await postResponse.json(), false, postResponse);\n    }\n\n    const session: Session = createSession({\n      accessTokenResponse: await postResponse.json<AccessTokenResponse>(),\n      shop: cleanShop,\n      state: stateFromCookie,\n      config,\n    });\n\n    if (!config.isEmbeddedApp) {\n      await cookies.setAndSign(SESSION_COOKIE_NAME, session.id, {\n        expires: session.expires,\n        sameSite: 'lax',\n        secure: true,\n        path: '/',\n      });\n    }\n\n    return {\n      headers: (await abstractConvertHeaders(\n        cookies.response.headers!,\n        adapterArgs,\n      )) as T,\n      session,\n    };\n  };\n}\n\nasync function validQuery({\n  config,\n  query,\n  stateFromCookie,\n}: {\n  config: ConfigInterface;\n  query: AuthQuery;\n  stateFromCookie: string;\n}): Promise<boolean> {\n  return (\n    (await validateHmac(config)(query)) &&\n    safeCompare(query.state!, stateFromCookie)\n  );\n}\n\nfunction throwIfCustomStoreApp(\n  isCustomStoreApp: boolean,\n  message: string,\n): void {\n  if (isCustomStoreApp) {\n    throw new ShopifyErrors.PrivateAppError(message);\n  }\n}\n", "import * as ShopifyErrors from '../error';\nimport {ConfigInterface} from '../base-types';\nimport {abstractConvertRequest} from '../../runtime/http';\nimport {sanitizeHost} from '../utils/shop-validator';\n\nimport {decodeHost} from './decode-host';\nimport {GetEmbeddedAppUrlParams} from './types';\n\nexport type GetEmbeddedAppUrl = (\n  params: GetEmbeddedAppUrlParams,\n) => Promise<string>;\n\nexport type BuildEmbeddedAppUrl = (host: string) => string;\n\nexport function getEmbeddedAppUrl(config: ConfigInterface): GetEmbeddedAppUrl {\n  return async ({...adapterArgs}: GetEmbeddedAppUrlParams): Promise<string> => {\n    const request = await abstractConvertRequest(adapterArgs);\n\n    if (!request) {\n      throw new ShopifyErrors.MissingRequiredArgument(\n        'getEmbeddedAppUrl requires a request object argument',\n      );\n    }\n\n    if (!request.url) {\n      throw new ShopifyErrors.InvalidRequestError(\n        'Request does not contain a URL',\n      );\n    }\n\n    const url = new URL(request.url, `https://${request.headers.host}`);\n    const host = url.searchParams.get('host');\n\n    if (typeof host !== 'string') {\n      throw new ShopifyErrors.InvalidRequestError(\n        'Request does not contain a host query parameter',\n      );\n    }\n\n    return buildEmbeddedAppUrl(config)(host);\n  };\n}\n\nexport function buildEmbeddedAppUrl(\n  config: ConfigInterface,\n): BuildEmbeddedAppUrl {\n  return (host: string): string => {\n    sanitizeHost()(host, true);\n    const decodedHost = decodeHost(host);\n\n    return `https://${decodedHost}/apps/${config.apiKey}`;\n  };\n}\n", "import {throwFailedRequest} from '../../clients/common';\nimport {decodeSessionToken} from '../../session/decode-session-token';\nimport {sanitizeShop} from '../../utils/shop-validator';\nimport {ConfigInterface} from '../../base-types';\nimport {Session} from '../../session/session';\nimport {DataType} from '../../clients/types';\nimport {fetchRequestFactory} from '../../utils/fetch-request';\n\nimport {createSession} from './create-session';\nimport {AccessTokenResponse} from './types';\n\nexport enum RequestedTokenType {\n  OnlineAccessToken = 'urn:shopify:params:oauth:token-type:online-access-token',\n  OfflineAccessToken = 'urn:shopify:params:oauth:token-type:offline-access-token',\n}\n\nconst TokenExchangeGrantType =\n  'urn:ietf:params:oauth:grant-type:token-exchange';\nconst IdTokenType = 'urn:ietf:params:oauth:token-type:id_token';\n\nexport interface TokenExchangeParams {\n  shop: string;\n  sessionToken: string;\n  requestedTokenType: RequestedTokenType;\n}\n\nexport type TokenExchange = (\n  params: TokenExchangeParams,\n) => Promise<{session: Session}>;\n\nexport function tokenExchange(config: ConfigInterface): TokenExchange {\n  return async ({\n    shop,\n    sessionToken,\n    requestedTokenType,\n  }: TokenExchangeParams) => {\n    await decodeSessionToken(config)(sessionToken);\n\n    const body = {\n      client_id: config.apiKey,\n      client_secret: config.apiSecretKey,\n      grant_type: TokenExchangeGrantType,\n      subject_token: sessionToken,\n      subject_token_type: IdTokenType,\n      requested_token_type: requestedTokenType,\n    };\n\n    const cleanShop = sanitizeShop(config)(shop, true)!;\n\n    const postResponse = await fetchRequestFactory(config)(\n      `https://${cleanShop}/admin/oauth/access_token`,\n      {\n        method: 'POST',\n        body: JSON.stringify(body),\n        headers: {\n          'Content-Type': DataType.JSON,\n          Accept: DataType.JSON,\n        },\n      },\n    );\n\n    if (!postResponse.ok) {\n      throwFailedRequest(await postResponse.json(), false, postResponse);\n    }\n\n    return {\n      session: createSession({\n        accessTokenResponse: await postResponse.json<AccessTokenResponse>(),\n        shop: cleanShop,\n        // We need to keep this as an empty string as our template DB schemas have this required\n        state: '',\n        config,\n      }),\n    };\n  };\n}\n", "import {ConfigInterface} from '../../base-types';\nimport {throwFailedRequest} from '../../clients/common';\nimport {DataType} from '../../clients/types';\nimport {Session} from '../../session/session';\nimport {fetchRequestFactory} from '../../utils/fetch-request';\nimport {sanitizeShop} from '../../utils/shop-validator';\n\nimport {createSession} from './create-session';\nimport {AccessTokenResponse} from './types';\n\nexport interface ClientCredentialsParams {\n  shop: string;\n}\n\nconst ClientCredentialsGrantType = 'client_credentials';\n\nexport type ClientCredentials = (\n  params: ClientCredentialsParams,\n) => Promise<{session: Session}>;\n\nexport function clientCredentials(config: ConfigInterface): ClientCredentials {\n  return async ({shop}: ClientCredentialsParams) => {\n    const cleanShop = sanitizeShop(config)(shop, true)!;\n\n    const requestConfig = {\n      method: 'POST',\n      body: JSON.stringify({\n        client_id: config.apiKey,\n        client_secret: config.apiSecretKey,\n        grant_type: ClientCredentialsGrantType,\n      }),\n      headers: {\n        'Content-Type': DataType.JSON,\n        Accept: DataType.JSON,\n      },\n    };\n\n    const postResponse = await fetchRequestFactory(config)(\n      `https://${cleanShop}/admin/oauth/access_token`,\n      requestConfig,\n    );\n\n    const responseData = (await postResponse.json()) as AccessTokenResponse;\n\n    if (!postResponse.ok) {\n      throwFailedRequest(responseData, false, postResponse);\n    }\n\n    return {\n      session: createSession({\n        accessTokenResponse: responseData,\n        shop: cleanShop,\n        // We need to keep this as an empty string as our template DB schemas have this required\n        state: '',\n        config,\n      }),\n    };\n  };\n}\n", "import {ConfigInterface} from '../base-types';\n\nimport {OAuthBegin, OAuthCallback, begin, callback} from './oauth/oauth';\nimport {Nonce, nonce} from './oauth/nonce';\nimport {SafeCompare, safeCompare} from './oauth/safe-compare';\nimport {\n  getEmbeddedAppUrl,\n  buildEmbeddedAppUrl,\n  GetEmbeddedAppUrl,\n  BuildEmbeddedAppUrl,\n} from './get-embedded-app-url';\nimport {TokenExchange, tokenExchange} from './oauth/token-exchange';\nimport {ClientCredentials, clientCredentials} from './oauth/client-credentials';\n\nexport {AuthScopes} from './scopes';\n\nexport function shopifyAuth<Config extends ConfigInterface>(\n  config: Config,\n): ShopifyAuth {\n  const shopify = {\n    begin: begin(config),\n    callback: callback(config),\n    nonce,\n    safeCompare,\n    getEmbeddedAppUrl: getEmbeddedAppUrl(config),\n    buildEmbeddedAppUrl: buildEmbeddedAppUrl(config),\n    tokenExchange: tokenExchange(config),\n    clientCredentials: clientCredentials(config),\n  } as ShopifyAuth;\n\n  return shopify;\n}\n\nexport interface ShopifyAuth {\n  begin: OAuthBegin;\n  callback: OAuthCallback;\n  nonce: Nonce;\n  safeCompare: SafeCompare;\n  getEmbeddedAppUrl: GetEmbeddedAppUrl;\n  buildEmbeddedAppUrl: BuildEmbeddedAppUrl;\n  tokenExchange: TokenExchange;\n  clientCredentials: ClientCredentials;\n}\n", "import {ConfigInterface} from '../base-types';\n\nimport {decodeSessionToken} from './decode-session-token';\nimport {\n  customAppSession,\n  getCurrentSessionId,\n  getJwtSessionId,\n  getOfflineId,\n} from './session-utils';\n\nexport function shopifySession(config: ConfigInterface) {\n  return {\n    customAppSession: customAppSession(config),\n    getCurrentId: getCurrentSessionId(config),\n    getOfflineId: getOfflineId(config),\n    getJwtSessionId: getJwtSessionId(config),\n    decodeSessionToken: decodeSessionToken(config),\n  };\n}\n\nexport type ShopifySession = ReturnType<typeof shopifySession>;\n", "import {ConfigInterface} from '../base-types';\nimport {ApiVersion} from '../types';\n\nexport function versionCompatible(config: ConfigInterface) {\n  return (\n    referenceVersion: ApiVersion,\n    currentVersion: ApiVersion = config.apiVersion,\n  ): boolean => {\n    // Return true if not using a dated version\n    if (currentVersion === ApiVersion.Unstable) {\n      return true;\n    }\n    const numericVersion = (version: string) =>\n      parseInt(version.replace('-', ''), 10);\n    const current = numericVersion(currentVersion);\n    const reference = numericVersion(referenceVersion);\n    return current >= reference;\n  };\n}\n\nexport function versionPriorTo(config: ConfigInterface) {\n  return (\n    referenceVersion: ApiVersion,\n    currentVersion: ApiVersion = config.apiVersion,\n  ): boolean => {\n    return !versionCompatible(config)(referenceVersion, currentVersion);\n  };\n}\n", "import {ConfigInterface} from '../base-types';\n\nimport {sanitizeShop, sanitizeHost} from './shop-validator';\nimport {validateHmac} from './hmac-validator';\nimport {versionCompatible, versionPriorTo} from './version-compatible';\nimport {\n  shopAdminUrlToLegacyUrl,\n  legacyUrlToShopAdminUrl,\n} from './shop-admin-url-helper';\n\nexport function shopifyUtils(config: ConfigInterface) {\n  return {\n    sanitizeShop: sanitizeShop(config),\n    sanitizeHost: sanitizeHost(),\n    validateHmac: validateHmac(config),\n    versionCompatible: versionCompatible(config),\n    versionPriorTo: versionPriorTo(config),\n    shopAdminUrlToLegacyUrl,\n    legacyUrlToShopAdminUrl,\n  };\n}\n\nexport type ShopifyUtils = ReturnType<typeof shopifyUtils>;\n", "import {ValidationErrorReason, ValidationInvalid} from '../utils/types';\nimport {AdapterArgs} from '../../runtime/types';\nimport {Session} from '../session/session';\n\nexport enum DeliveryMethod {\n  Http = 'http',\n  EventBridge = 'eventbridge',\n  PubSub = 'pubsub',\n}\n\nexport type WebhookHandlerFunction = (\n  topic: string,\n  shop_domain: string,\n  body: string,\n  webhookId: string,\n  apiVersion?: string,\n  subTopic?: string,\n  context?: any,\n) => Promise<void>;\n\ninterface BaseWebhookHandler {\n  id?: string;\n  includeFields?: string[];\n  metafieldNamespaces?: string[];\n  subTopic?: string;\n  context?: any;\n}\n\nexport interface HttpWebhookHandler extends BaseWebhookHandler {\n  deliveryMethod: DeliveryMethod.Http;\n  callbackUrl: string;\n}\n\nexport interface HttpWebhookHandlerWithCallback extends HttpWebhookHandler {\n  callback: WebhookHandlerFunction;\n}\n\nexport interface EventBridgeWebhookHandler extends BaseWebhookHandler {\n  deliveryMethod: DeliveryMethod.EventBridge;\n  arn: string;\n}\n\nexport interface PubSubWebhookHandler extends BaseWebhookHandler {\n  deliveryMethod: DeliveryMethod.PubSub;\n  pubSubProject: string;\n  pubSubTopic: string;\n}\n\nexport type WebhookHandler =\n  | HttpWebhookHandler\n  | HttpWebhookHandlerWithCallback\n  | EventBridgeWebhookHandler\n  | PubSubWebhookHandler;\n\n// See https://shopify.dev/docs/api/admin-graphql/latest/enums/webhooksubscriptiontopic for available topics\nexport type WebhookRegistry<Handler extends WebhookHandler = WebhookHandler> =\n  Record<string, Handler[]>;\n\n// eslint-disable-next-line no-warning-comments\n// TODO Rethink the wording for this enum - the operations we're doing are actually \"subscribing\" and \"unsubscribing\"\n// Consider changing the values when releasing v12.0.0 when it can be safely deprecated\nexport enum WebhookOperation {\n  Create = 'create',\n  Update = 'update',\n  Delete = 'delete',\n}\n\nexport interface RegisterParams {\n  session: Session;\n}\n\nexport interface RegisterResult {\n  success: boolean;\n  deliveryMethod: DeliveryMethod;\n  result: unknown;\n  operation: WebhookOperation;\n}\n\nexport type RegisterReturn = Record<string, RegisterResult[]>;\n\ninterface WebhookHttpEndpoint {\n  __typename: 'WebhookHttpEndpoint';\n  callbackUrl: string;\n}\ninterface WebhookEventBridgeEndpoint {\n  __typename: 'WebhookEventBridgeEndpoint';\n  arn: string;\n}\ninterface WebhookPubSubEndpoint {\n  __typename: 'WebhookPubSubEndpoint';\n  pubSubProject: string;\n  pubSubTopic: string;\n}\n\ntype WebhookEndpoint =\n  | WebhookHttpEndpoint\n  | WebhookEventBridgeEndpoint\n  | WebhookPubSubEndpoint;\n\nexport interface WebhookCheckResponseNode<\n  T = {\n    endpoint: WebhookEndpoint;\n  },\n> {\n  node: {\n    id: string;\n    topic: string;\n    includeFields: string[];\n    metafieldNamespaces: string[];\n  } & T;\n}\n\nexport interface WebhookCheckResponse<T = WebhookCheckResponseNode> {\n  webhookSubscriptions: {\n    edges: T[];\n    pageInfo: {\n      endCursor: string;\n      hasNextPage: boolean;\n    };\n  };\n}\n\nexport type AddHandlersParams = Record<\n  string,\n  WebhookHandler | WebhookHandler[]\n>;\n\nexport interface WebhookProcessParams extends AdapterArgs {\n  rawBody: string;\n  context?: any;\n}\n\nexport interface WebhookValidateParams extends WebhookProcessParams {}\n\nexport const WebhookValidationErrorReason = {\n  ...ValidationErrorReason,\n  MissingHeaders: 'missing_headers',\n} as const;\n\nexport type WebhookValidationErrorReasonType =\n  (typeof WebhookValidationErrorReason)[keyof typeof WebhookValidationErrorReason];\n\nexport interface WebhookFields {\n  webhookId: string;\n  apiVersion: string;\n  domain: string;\n  hmac: string;\n  topic: string;\n  subTopic?: string;\n}\n\nexport interface WebhookValidationInvalid\n  extends Omit<ValidationInvalid, 'reason'> {\n  valid: false;\n  reason: WebhookValidationErrorReasonType;\n}\n\nexport interface WebhookValidationMissingHeaders\n  extends WebhookValidationInvalid {\n  reason: typeof WebhookValidationErrorReason.MissingHeaders;\n  missingHeaders: string[];\n}\n\nexport interface WebhookValidationValid extends WebhookFields {\n  valid: true;\n}\n\nexport type WebhookValidation =\n  | WebhookValidationValid\n  | WebhookValidationInvalid\n  | WebhookValidationMissingHeaders;\n", "import {InvalidDeliveryMethodError} from '../error';\nimport {ConfigInterface} from '../base-types';\nimport {logger} from '../logger';\n\nimport {\n  AddHandlersParams,\n  DeliveryMethod,\n  WebhookHandler,\n  WebhookRegistry,\n} from './types';\n\nexport function registry(): WebhookRegistry {\n  return {};\n}\n\nexport function topicForStorage(topic: string): string {\n  return topic.toUpperCase().replace(/\\/|\\./g, '_');\n}\n\nexport function addHandlers(\n  config: ConfigInterface,\n  webhookRegistry: WebhookRegistry,\n) {\n  return function addHandlers(handlersToAdd: AddHandlersParams) {\n    for (const [topic, handlers] of Object.entries(handlersToAdd)) {\n      const topicKey = topicForStorage(topic);\n\n      if (Array.isArray(handlers)) {\n        for (const handler of handlers) {\n          mergeOrAddHandler(config, webhookRegistry, topicKey, handler);\n        }\n      } else {\n        mergeOrAddHandler(config, webhookRegistry, topicKey, handlers);\n      }\n    }\n  };\n}\n\nexport function getTopicsAdded(webhookRegistry: WebhookRegistry) {\n  return function getTopicsAdded(): string[] {\n    return Object.keys(webhookRegistry);\n  };\n}\n\nexport function getHandlers(webhookRegistry: WebhookRegistry) {\n  return function getHandlers(topic: string): WebhookHandler[] {\n    return webhookRegistry[topicForStorage(topic)] || [];\n  };\n}\n\nexport function handlerIdentifier(\n  config: ConfigInterface,\n  handler: WebhookHandler,\n): string {\n  const prefix = handler.deliveryMethod;\n\n  switch (handler.deliveryMethod) {\n    case DeliveryMethod.Http:\n      return `${prefix}_${addHostToCallbackUrl(config, handler.callbackUrl)}`;\n    case DeliveryMethod.EventBridge:\n      return `${prefix}_${handler.arn}`;\n    case DeliveryMethod.PubSub:\n      return `${prefix}_${handler.pubSubProject}:${handler.pubSubTopic}`;\n    default:\n      throw new InvalidDeliveryMethodError(\n        `Unrecognized delivery method '${(handler as any).deliveryMethod}'`,\n      );\n  }\n}\n\nexport function addHostToCallbackUrl(\n  config: ConfigInterface,\n  callbackUrl: string,\n): string {\n  if (callbackUrl.startsWith('/')) {\n    return `${config.hostScheme}://${config.hostName}${callbackUrl}`;\n  } else {\n    return callbackUrl;\n  }\n}\n\nfunction mergeOrAddHandler(\n  config: ConfigInterface,\n  webhookRegistry: WebhookRegistry,\n  topic: string,\n  handler: WebhookHandler,\n) {\n  const log = logger(config);\n\n  handler.includeFields?.sort();\n  handler.metafieldNamespaces?.sort();\n\n  if (!(topic in webhookRegistry)) {\n    webhookRegistry[topic] = [handler];\n    return;\n  }\n\n  const identifier = handlerIdentifier(config, handler);\n\n  for (const index in webhookRegistry[topic]) {\n    if (!Object.prototype.hasOwnProperty.call(webhookRegistry[topic], index)) {\n      continue;\n    }\n\n    const existingHandler = webhookRegistry[topic][index];\n    const existingIdentifier = handlerIdentifier(config, existingHandler);\n\n    if (identifier !== existingIdentifier) {\n      continue;\n    }\n\n    if (handler.deliveryMethod === DeliveryMethod.Http) {\n      log.info(\n        `Detected multiple handlers for '${topic}', webhooks.process will call them sequentially`,\n      );\n      break;\n    } else {\n      throw new InvalidDeliveryMethodError(\n        `Can only add multiple handlers for a topic when deliveryMethod is Http. Please be sure that you used addHandler method once after creating ShopifyApi instance in your app.  Invalid handler: ${JSON.stringify(\n          handler,\n        )}`,\n      );\n    }\n  }\n\n  webhookRegistry[topic].push(handler);\n}\n", "export function queryTemplate(template: string, params: Record<string, any>) {\n  let query = template;\n\n  Object.entries(params).forEach(([key, value]) => {\n    query = query.replace(`{{${key}}}`, value);\n  });\n\n  return query;\n}\n", "import {graphqlClientClass, GraphqlClient} from '../clients/admin';\nimport {InvalidDeliveryMethodError, ShopifyError} from '../error';\nimport {logger} from '../logger';\nimport {privacyTopics} from '../types';\nimport {ConfigInterface} from '../base-types';\nimport {Session} from '../session/session';\n\nimport {addHostToCallbackUrl, getHandlers, handlerIdentifier} from './registry';\nimport {queryTemplate} from './query-template';\nimport {\n  WebhookRegistry,\n  RegisterReturn,\n  WebhookHandler,\n  WebhookCheckResponse,\n  DeliveryMethod,\n  WebhookCheckResponseNode,\n  WebhookOperation,\n  RegisterResult,\n  RegisterParams,\n} from './types';\n\ninterface RegisterTopicParams {\n  config: ConfigInterface;\n  session: Session;\n  topic: string;\n  existingHandlers: WebhookHandler[];\n  handlers: WebhookHandler[];\n}\n\ninterface RunMutationsParams {\n  config: ConfigInterface;\n  client: GraphqlClient;\n  topic: string;\n  handlers: WebhookHandler[];\n  operation: WebhookOperation;\n}\n\ninterface RunMutationParams {\n  config: ConfigInterface;\n  client: GraphqlClient;\n  topic: string;\n  handler: WebhookHandler;\n  operation: WebhookOperation;\n}\n\nexport function register(\n  config: ConfigInterface,\n  webhookRegistry: WebhookRegistry,\n) {\n  return async function register({\n    session,\n  }: RegisterParams): Promise<RegisterReturn> {\n    const log = logger(config);\n    log.info('Registering webhooks', {shop: session.shop});\n\n    const registerReturn: RegisterReturn = Object.keys(webhookRegistry).reduce(\n      (acc: RegisterReturn, topic) => {\n        acc[topic] = [];\n        return acc;\n      },\n      {},\n    );\n\n    const existingHandlers = await getExistingHandlers(config, session);\n\n    log.debug(\n      `Existing topics: [${Object.keys(existingHandlers).join(', ')}]`,\n      {shop: session.shop},\n    );\n\n    for (const topic in webhookRegistry) {\n      if (!Object.prototype.hasOwnProperty.call(webhookRegistry, topic)) {\n        continue;\n      }\n\n      if (privacyTopics.includes(topic)) {\n        continue;\n      }\n\n      registerReturn[topic] = await registerTopic({\n        config,\n        session,\n        topic,\n        existingHandlers: existingHandlers[topic] || [],\n        handlers: getHandlers(webhookRegistry)(topic),\n      });\n\n      // Remove this topic from the list of existing handlers so we have a list of leftovers\n      delete existingHandlers[topic];\n    }\n\n    // Delete any leftover handlers\n    for (const topic in existingHandlers) {\n      if (!Object.prototype.hasOwnProperty.call(existingHandlers, topic)) {\n        continue;\n      }\n\n      const GraphqlClient = graphqlClientClass({config});\n      const client = new GraphqlClient({session});\n\n      registerReturn[topic] = await runMutations({\n        config,\n        client,\n        topic,\n        handlers: existingHandlers[topic],\n        operation: WebhookOperation.Delete,\n      });\n    }\n\n    return registerReturn;\n  };\n}\n\nasync function getExistingHandlers(\n  config: ConfigInterface,\n  session: Session,\n): Promise<WebhookRegistry> {\n  const GraphqlClient = graphqlClientClass({config});\n  const client = new GraphqlClient({session});\n\n  const existingHandlers: WebhookRegistry = {};\n\n  let hasNextPage: boolean;\n  let endCursor: string | null = null;\n  do {\n    const query = buildCheckQuery(endCursor);\n\n    const response = await client.request<WebhookCheckResponse>(query);\n\n    response.data?.webhookSubscriptions?.edges.forEach(\n      (edge: WebhookCheckResponseNode) => {\n        const handler = buildHandlerFromNode(edge);\n\n        if (!existingHandlers[edge.node.topic]) {\n          existingHandlers[edge.node.topic] = [];\n        }\n\n        existingHandlers[edge.node.topic].push(handler);\n      },\n    );\n\n    endCursor = response.data?.webhookSubscriptions?.pageInfo.endCursor!;\n    hasNextPage = response.data?.webhookSubscriptions?.pageInfo.hasNextPage!;\n  } while (hasNextPage);\n\n  return existingHandlers;\n}\n\nfunction buildCheckQuery(endCursor: string | null) {\n  return queryTemplate(TEMPLATE_GET_HANDLERS, {\n    END_CURSOR: JSON.stringify(endCursor),\n  });\n}\n\nfunction buildHandlerFromNode(edge: WebhookCheckResponseNode): WebhookHandler {\n  const endpoint = edge.node.endpoint;\n\n  let handler: WebhookHandler;\n\n  switch (endpoint.__typename) {\n    case 'WebhookHttpEndpoint':\n      handler = {\n        deliveryMethod: DeliveryMethod.Http,\n        callbackUrl: endpoint.callbackUrl,\n        // This is a dummy for now because we don't really care about it\n        callback: async () => {},\n      };\n      break;\n    case 'WebhookEventBridgeEndpoint':\n      handler = {\n        deliveryMethod: DeliveryMethod.EventBridge,\n        arn: endpoint.arn,\n      };\n      break;\n    case 'WebhookPubSubEndpoint':\n      handler = {\n        deliveryMethod: DeliveryMethod.PubSub,\n        pubSubProject: endpoint.pubSubProject,\n        pubSubTopic: endpoint.pubSubTopic,\n      };\n      break;\n  }\n\n  // Set common fields\n  handler.id = edge.node.id;\n  handler.includeFields = edge.node.includeFields;\n  handler.metafieldNamespaces = edge.node.metafieldNamespaces;\n\n  // Sort the array fields to make them cheaper to compare later on\n  handler.includeFields?.sort();\n  handler.metafieldNamespaces?.sort();\n\n  return handler;\n}\n\nasync function registerTopic({\n  config,\n  session,\n  topic,\n  existingHandlers,\n  handlers,\n}: RegisterTopicParams): Promise<RegisterResult[]> {\n  let registerResults: RegisterResult[] = [];\n\n  const {toCreate, toUpdate, toDelete} = categorizeHandlers(\n    config,\n    existingHandlers,\n    handlers,\n  );\n\n  const GraphqlClient = graphqlClientClass({config});\n  const client = new GraphqlClient({session});\n\n  let operation = WebhookOperation.Create;\n  registerResults = registerResults.concat(\n    await runMutations({config, client, topic, operation, handlers: toCreate}),\n  );\n\n  operation = WebhookOperation.Update;\n  registerResults = registerResults.concat(\n    await runMutations({config, client, topic, operation, handlers: toUpdate}),\n  );\n\n  operation = WebhookOperation.Delete;\n  registerResults = registerResults.concat(\n    await runMutations({config, client, topic, operation, handlers: toDelete}),\n  );\n\n  return registerResults;\n}\n\ntype HandlersByKey = Record<string, WebhookHandler>;\n\nfunction categorizeHandlers(\n  config: ConfigInterface,\n  existingHandlers: WebhookHandler[],\n  handlers: WebhookHandler[],\n) {\n  const handlersByKey = handlers.reduce((acc: HandlersByKey, value) => {\n    acc[handlerIdentifier(config, value)] = value;\n    return acc;\n  }, {});\n  const existingHandlersByKey = existingHandlers.reduce(\n    (acc: HandlersByKey, value) => {\n      acc[handlerIdentifier(config, value)] = value;\n      return acc;\n    },\n    {},\n  );\n\n  const toCreate: HandlersByKey = {...handlersByKey};\n  const toUpdate: HandlersByKey = {};\n  const toDelete: HandlersByKey = {};\n  for (const existingKey in existingHandlersByKey) {\n    if (\n      !Object.prototype.hasOwnProperty.call(existingHandlersByKey, existingKey)\n    ) {\n      continue;\n    }\n\n    const existingHandler = existingHandlersByKey[existingKey];\n    const handler = handlersByKey[existingKey];\n\n    if (existingKey in handlersByKey) {\n      delete toCreate[existingKey];\n\n      if (!areHandlerFieldsEqual(existingHandler, handler)) {\n        toUpdate[existingKey] = handler;\n        toUpdate[existingKey].id = existingHandler.id;\n      }\n    } else {\n      toDelete[existingKey] = existingHandler;\n    }\n  }\n\n  return {\n    toCreate: Object.values(toCreate),\n    toUpdate: Object.values(toUpdate),\n    toDelete: Object.values(toDelete),\n  };\n}\nfunction areHandlerFieldsEqual(\n  arr1: WebhookHandler,\n  arr2: WebhookHandler,\n): boolean {\n  const includeFieldsEqual = arraysEqual(\n    arr1.includeFields || [],\n    arr2.includeFields || [],\n  );\n  const metafieldNamespacesEqual = arraysEqual(\n    arr1.metafieldNamespaces || [],\n    arr2.metafieldNamespaces || [],\n  );\n\n  return includeFieldsEqual && metafieldNamespacesEqual;\n}\n\nfunction arraysEqual(arr1: any[], arr2: any[]): boolean {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nasync function runMutations({\n  config,\n  client,\n  topic,\n  handlers,\n  operation,\n}: RunMutationsParams): Promise<RegisterResult[]> {\n  const registerResults: RegisterResult[] = [];\n\n  for (const handler of handlers) {\n    registerResults.push(\n      await runMutation({config, client, topic, handler, operation}),\n    );\n  }\n\n  return registerResults;\n}\n\nasync function runMutation({\n  config,\n  client,\n  topic,\n  handler,\n  operation,\n}: RunMutationParams): Promise<RegisterResult> {\n  let registerResult: RegisterResult;\n\n  logger(config).debug(`Running webhook mutation`, {topic, operation});\n\n  try {\n    const query = buildMutation(config, topic, handler, operation);\n\n    const result = await client.request(query);\n\n    registerResult = {\n      deliveryMethod: handler.deliveryMethod,\n      success: isSuccess(result, handler, operation),\n      result,\n      operation,\n    };\n  } catch (error) {\n    if (error instanceof InvalidDeliveryMethodError) {\n      registerResult = {\n        deliveryMethod: handler.deliveryMethod,\n        success: false,\n        result: {message: error.message},\n        operation,\n      };\n    } else {\n      throw error;\n    }\n  }\n\n  return registerResult;\n}\n\nfunction buildMutation(\n  config: ConfigInterface,\n  topic: string,\n  handler: WebhookHandler,\n  operation: WebhookOperation,\n): string {\n  const params: Record<string, string> = {};\n\n  let identifier: string;\n  if (handler.id) {\n    identifier = `id: \"${handler.id}\"`;\n  } else {\n    identifier = `topic: ${topic}`;\n  }\n\n  const mutationArguments = {\n    MUTATION_NAME: getMutationName(handler, operation),\n    IDENTIFIER: identifier,\n    MUTATION_PARAMS: '',\n  };\n\n  if (operation !== WebhookOperation.Delete) {\n    switch (handler.deliveryMethod) {\n      case DeliveryMethod.Http:\n        params.callbackUrl = `\"${addHostToCallbackUrl(\n          config,\n          handler.callbackUrl,\n        )}\"`;\n        break;\n      case DeliveryMethod.EventBridge:\n        params.arn = `\"${handler.arn}\"`;\n        break;\n      case DeliveryMethod.PubSub:\n        params.pubSubProject = `\"${handler.pubSubProject}\"`;\n        params.pubSubTopic = `\"${handler.pubSubTopic}\"`;\n        break;\n      default:\n        throw new InvalidDeliveryMethodError(\n          `Unrecognized delivery method '${(handler as any).deliveryMethod}'`,\n        );\n    }\n\n    if (handler.includeFields) {\n      params.includeFields = JSON.stringify(handler.includeFields);\n    }\n    if (handler.metafieldNamespaces) {\n      params.metafieldNamespaces = JSON.stringify(handler.metafieldNamespaces);\n    }\n\n    if (handler.subTopic) {\n      const subTopicString = `subTopic: \"${handler.subTopic}\",`;\n      mutationArguments.MUTATION_PARAMS = subTopicString;\n    }\n\n    const paramsString = Object.entries(params)\n      .map(([key, value]) => `${key}: ${value}`)\n      .join(', ');\n\n    mutationArguments.MUTATION_PARAMS += `webhookSubscription: {${paramsString}}`;\n  }\n\n  return queryTemplate(TEMPLATE_MUTATION, mutationArguments);\n}\n\nfunction getMutationName(\n  handler: WebhookHandler,\n  operation: WebhookOperation,\n): string {\n  switch (operation) {\n    case WebhookOperation.Create:\n      return `${getEndpoint(handler)}Create`;\n    case WebhookOperation.Update:\n      return `${getEndpoint(handler)}Update`;\n    case WebhookOperation.Delete:\n      return 'webhookSubscriptionDelete';\n    default:\n      throw new ShopifyError(`Unrecognized operation '${operation}'`);\n  }\n}\n\nfunction getEndpoint(handler: WebhookHandler): string {\n  switch (handler.deliveryMethod) {\n    case DeliveryMethod.Http:\n      return 'webhookSubscription';\n    case DeliveryMethod.EventBridge:\n      return 'eventBridgeWebhookSubscription';\n    case DeliveryMethod.PubSub:\n      return 'pubSubWebhookSubscription';\n    default:\n      throw new ShopifyError(\n        `Unrecognized delivery method '${(handler as any).deliveryMethod}'`,\n      );\n  }\n}\n\nfunction isSuccess(\n  result: any,\n  handler: WebhookHandler,\n  operation: WebhookOperation,\n): boolean {\n  const mutationName = getMutationName(handler, operation);\n\n  return Boolean(\n    result.data &&\n      result.data[mutationName] &&\n      result.data[mutationName].userErrors.length === 0,\n  );\n}\n\nexport const TEMPLATE_GET_HANDLERS = `query shopifyApiReadWebhookSubscriptions {\n  webhookSubscriptions(\n    first: 250,\n    after: {{END_CURSOR}},\n  ) {\n    edges {\n      node {\n        id\n        topic\n        includeFields\n        metafieldNamespaces\n        endpoint {\n          __typename\n          ... on WebhookHttpEndpoint {\n            callbackUrl\n          }\n          ... on WebhookEventBridgeEndpoint {\n            arn\n          }\n          ... on WebhookPubSubEndpoint {\n            pubSubProject\n            pubSubTopic\n          }\n        }\n      }\n    }\n    pageInfo {\n      endCursor\n      hasNextPage\n    }\n  }\n}`;\n\nexport const TEMPLATE_MUTATION = `\n  mutation shopifyApiCreateWebhookSubscription {\n    {{MUTATION_NAME}}(\n      {{IDENTIFIER}},\n      {{MUTATION_PARAMS}}\n    ) {\n      userErrors {\n        field\n        message\n      }\n    }\n  }\n`;\n", "import {logger} from '../logger';\nimport {validateHmacFromRequestFactory} from '../utils/hmac-validator';\nimport {HmacValidationType, ValidationErrorReason} from '../utils/types';\nimport {\n  abstractConvertRequest,\n  getHeader,\n  Headers,\n  NormalizedRequest,\n} from '../../runtime/http';\nimport {ShopifyHeader} from '../types';\nimport {ConfigInterface} from '../base-types';\n\nimport {\n  WebhookFields,\n  WebhookValidateParams,\n  WebhookValidation,\n  WebhookValidationErrorReason,\n  WebhookValidationMissingHeaders,\n  WebhookValidationValid,\n} from './types';\nimport {topicForStorage} from './registry';\n\nconst OPTIONAL_HANDLER_PROPERTIES = {\n  subTopic: ShopifyHeader.SubTopic,\n};\n\nconst HANDLER_PROPERTIES = {\n  apiVersion: ShopifyHeader.ApiVersion,\n  domain: ShopifyHeader.Domain,\n  hmac: ShopifyHeader.Hmac,\n  topic: ShopifyHeader.Topic,\n  webhookId: ShopifyHeader.WebhookId,\n  ...OPTIONAL_HANDLER_PROPERTIES,\n};\n\nexport function validateFactory(config: ConfigInterface) {\n  return async function validate({\n    rawBody,\n    ...adapterArgs\n  }: WebhookValidateParams): Promise<WebhookValidation> {\n    const request: NormalizedRequest =\n      await abstractConvertRequest(adapterArgs);\n\n    const validHmacResult = await validateHmacFromRequestFactory(config)({\n      type: HmacValidationType.Webhook,\n      rawBody,\n      ...adapterArgs,\n    });\n\n    if (!validHmacResult.valid) {\n      if (validHmacResult.reason === ValidationErrorReason.InvalidHmac) {\n        const log = logger(config);\n        await log.debug(\n          \"Webhook HMAC validation failed. Please note that events manually triggered from a store's Notifications settings will fail this validation. To test this, please use the CLI or trigger the actual event in a development store.\",\n        );\n      }\n      return validHmacResult;\n    }\n\n    return checkWebhookHeaders(request.headers);\n  };\n}\n\nfunction checkWebhookHeaders(\n  headers: Headers,\n): WebhookValidationMissingHeaders | WebhookValidationValid {\n  const missingHeaders: ShopifyHeader[] = [];\n  const entries = Object.entries(HANDLER_PROPERTIES) as [\n    keyof WebhookFields,\n    ShopifyHeader,\n  ][];\n  const headerValues = entries.reduce((acc, [property, headerName]) => {\n    const headerValue = getHeader(headers, headerName);\n    if (headerValue) {\n      acc[property] = headerValue;\n    } else if (!(property in OPTIONAL_HANDLER_PROPERTIES)) {\n      missingHeaders.push(headerName);\n    }\n\n    return acc;\n  }, {} as WebhookFields);\n\n  if (missingHeaders.length) {\n    return {\n      valid: false,\n      reason: WebhookValidationErrorReason.MissingHeaders,\n      missingHeaders,\n    };\n  } else {\n    return {\n      valid: true,\n      ...headerValues,\n      ...(headerValues.subTopic ? {subTopic: headerValues.subTopic} : {}),\n      topic: topicForStorage(headerValues.topic),\n    };\n  }\n}\n", "import {StatusCode} from '../types';\nimport {\n  abstractConvertResponse,\n  AdapterResponse,\n  isOK,\n  NormalizedResponse,\n} from '../../runtime/http';\nimport {ConfigInterface} from '../base-types';\nimport * as ShopifyErrors from '../error';\nimport {logger} from '../logger';\n\nimport {\n  DeliveryMethod,\n  HttpWebhookHandlerWithCallback,\n  WebhookProcessParams,\n  WebhookRegistry,\n  WebhookValidationErrorReason,\n  WebhookValidationInvalid,\n  WebhookValidationMissingHeaders,\n  WebhookValidationValid,\n} from './types';\nimport {validateFactory} from './validate';\n\ninterface HandlerCallResult {\n  statusCode: StatusCode;\n  errorMessage?: string;\n}\n\ninterface ErrorCallResult {\n  statusCode: StatusCode;\n  errorMessage: string;\n}\n\nconst STATUS_TEXT_LOOKUP: Record<string, string> = {\n  [StatusCode.Ok]: 'OK',\n  [StatusCode.BadRequest]: 'Bad Request',\n  [StatusCode.Unauthorized]: 'Unauthorized',\n  [StatusCode.NotFound]: 'Not Found',\n  [StatusCode.InternalServerError]: 'Internal Server Error',\n};\n\nexport function process(\n  config: ConfigInterface,\n  webhookRegistry: WebhookRegistry<HttpWebhookHandlerWithCallback>,\n) {\n  return async function process({\n    context,\n    rawBody,\n    ...adapterArgs\n  }: WebhookProcessParams): Promise<AdapterResponse> {\n    const response: NormalizedResponse = {\n      statusCode: StatusCode.Ok,\n      statusText: STATUS_TEXT_LOOKUP[StatusCode.Ok],\n      headers: {},\n    };\n\n    await logger(config).info('Receiving webhook request');\n\n    const webhookCheck = await validateFactory(config)({\n      rawBody,\n      ...adapterArgs,\n    });\n\n    let errorMessage = 'Unknown error while handling webhook';\n    if (webhookCheck.valid) {\n      const handlerResult = await callWebhookHandlers(\n        config,\n        webhookRegistry,\n        webhookCheck,\n        rawBody,\n        context,\n      );\n\n      response.statusCode = handlerResult.statusCode;\n      if (!isOK(response)) {\n        errorMessage = handlerResult.errorMessage || errorMessage;\n      }\n    } else {\n      const errorResult = await handleInvalidWebhook(config, webhookCheck);\n\n      response.statusCode = errorResult.statusCode;\n      response.statusText = STATUS_TEXT_LOOKUP[response.statusCode];\n      errorMessage = errorResult.errorMessage;\n    }\n\n    const returnResponse = await abstractConvertResponse(response, adapterArgs);\n    if (!isOK(response)) {\n      throw new ShopifyErrors.InvalidWebhookError({\n        message: errorMessage,\n        response: returnResponse,\n      });\n    }\n\n    return Promise.resolve(returnResponse);\n  };\n}\n\nasync function callWebhookHandlers(\n  config: ConfigInterface,\n  webhookRegistry: WebhookRegistry<HttpWebhookHandlerWithCallback>,\n  webhookCheck: WebhookValidationValid,\n  rawBody: string,\n  context: any,\n): Promise<HandlerCallResult> {\n  const log = logger(config);\n  const {hmac: _hmac, valid: _valid, ...loggingContext} = webhookCheck;\n\n  await log.debug(\n    'Webhook request is valid, looking for HTTP handlers to call',\n    loggingContext,\n  );\n\n  const handlers = webhookRegistry[webhookCheck.topic] || [];\n\n  const response: HandlerCallResult = {statusCode: StatusCode.Ok};\n\n  let found = false;\n  for (const handler of handlers) {\n    if (handler.deliveryMethod !== DeliveryMethod.Http) {\n      continue;\n    }\n    if (!handler.callback) {\n      response.statusCode = StatusCode.InternalServerError;\n      response.errorMessage =\n        \"Cannot call webhooks.process with a webhook handler that doesn't have a callback\";\n\n      throw new ShopifyErrors.MissingWebhookCallbackError({\n        message: response.errorMessage,\n        response,\n      });\n    }\n\n    found = true;\n\n    await log.debug('Found HTTP handler, triggering it', loggingContext);\n\n    try {\n      await handler.callback(\n        webhookCheck.topic,\n        webhookCheck.domain,\n        rawBody,\n        webhookCheck.webhookId,\n        webhookCheck.apiVersion,\n        ...(webhookCheck?.subTopic ? webhookCheck.subTopic : ''),\n        context,\n      );\n    } catch (error) {\n      response.statusCode = StatusCode.InternalServerError;\n      response.errorMessage = error.message;\n    }\n  }\n\n  if (!found) {\n    await log.debug('No HTTP handlers found', loggingContext);\n\n    response.statusCode = StatusCode.NotFound;\n    response.errorMessage = `No HTTP webhooks registered for topic ${webhookCheck.topic}`;\n  }\n\n  return response;\n}\n\nasync function handleInvalidWebhook(\n  config: ConfigInterface,\n  webhookCheck: WebhookValidationInvalid,\n): Promise<ErrorCallResult> {\n  const response: ErrorCallResult = {\n    statusCode: StatusCode.InternalServerError,\n    errorMessage: 'Unknown error while handling webhook',\n  };\n\n  switch (webhookCheck.reason) {\n    case WebhookValidationErrorReason.MissingHeaders:\n      response.statusCode = StatusCode.BadRequest;\n      response.errorMessage = `Missing one or more of the required HTTP headers to process webhooks: [${(\n        webhookCheck as WebhookValidationMissingHeaders\n      ).missingHeaders.join(', ')}]`;\n      break;\n    case WebhookValidationErrorReason.MissingBody:\n      response.statusCode = StatusCode.BadRequest;\n      response.errorMessage = 'No body was received when processing webhook';\n      break;\n    case WebhookValidationErrorReason.MissingHmac:\n      response.statusCode = StatusCode.BadRequest;\n      response.errorMessage = `Missing HMAC header in request`;\n      break;\n    case WebhookValidationErrorReason.InvalidHmac:\n      response.statusCode = StatusCode.Unauthorized;\n      response.errorMessage = `Could not validate request HMAC`;\n      break;\n  }\n\n  await logger(config).debug(\n    `Webhook request is invalid, returning ${response.statusCode}: ${response.errorMessage}`,\n  );\n\n  return response;\n}\n", "import {ConfigInterface} from '../base-types';\n\nimport {addHandlers, getTopicsAdded, getHandlers, registry} from './registry';\nimport {register} from './register';\nimport {process} from './process';\nimport {validateFactory} from './validate';\nimport {HttpWebhookHandlerWithCallback, WebhookRegistry} from './types';\n\ninterface Webhooks {\n  /**\n   * Add shop-specific webhook handlers to the library registry,\n   * allowing you to register webhooks with Shopify and process HTTP webhook requests from Shopify.\n   * In most cases, you should use app-specific webhooks:\n   *\n   * {@link https://shopify.dev/docs/apps/build/webhooks/subscribe#app-specific-vs-shop-specific-subscriptions}\n   *\n   * If you use only app-specific webhooks, you do not need to use `addHandlers`.\n   *\n   */\n  addHandlers: ReturnType<typeof addHandlers>;\n\n  /**\n   * Fetches all topics that were added to the registry.\n   *\n   * In most cases, you should use app-specific webhooks:\n   *\n   * {@link https://shopify.dev/docs/apps/build/webhooks/subscribe#app-specific-vs-shop-specific-subscriptions}\n   *\n   * If you use only app-specific webhooks, you do not need to use `getTopicsAdded`.\n   *\n   */\n  getTopicsAdded: ReturnType<typeof getTopicsAdded>;\n\n  /**\n   * Fetches the configured handlers for shop-specific webhooks for the given topic.\n   *\n   * In most cases, you should use app-specific webhooks:\n   *\n   * {@link https://shopify.dev/docs/apps/build/webhooks/subscribe#app-specific-vs-shop-specific-subscriptions}\n   *\n   * If you use only app-specific webhooks, you do not need to use `getHandlers`.\n   *\n   */\n  getHandlers: ReturnType<typeof getHandlers>;\n\n  /**\n   * Registers a webhook handler for a given topic.\n   *\n   * In most cases, you should use app-specific webhooks:\n   *\n   * {@link https://shopify.dev/docs/apps/build/webhooks/subscribe#app-specific-vs-shop-specific-subscriptions}\n   *\n   * If you use only app-specific webhooks, you do not need to use `register`.\n   *\n   */\n  register: ReturnType<typeof register>;\n\n  /**\n   * Processes a webhook request.\n   *\n   * In most cases, you should use app-specific webhooks:\n   *\n   * {@link https://shopify.dev/docs/apps/build/webhooks/subscribe#app-specific-vs-shop-specific-subscriptions}\n   *\n   * If you use only app-specific webhooks, you do not need to use `process`.\n   *\n   */\n  process: ReturnType<typeof process>;\n\n  /**\n   * Validates an incoming request for `Http` handlers.\n   *\n   * If the call is invalid, it will return a `valid` field set to `false`.\n   *\n   * `validate` can be used to validate app-specific and shop-specific webhook requests.\n   *\n   */\n  validate: ReturnType<typeof validateFactory>;\n}\n\nexport function shopifyWebhooks(config: ConfigInterface): Webhooks {\n  const webhookRegistry = registry();\n\n  return {\n    addHandlers: addHandlers(config, webhookRegistry),\n    getTopicsAdded: getTopicsAdded(webhookRegistry),\n    getHandlers: getHandlers(webhookRegistry),\n    register: register(config, webhookRegistry),\n    process: process(\n      config,\n      webhookRegistry as WebhookRegistry<HttpWebhookHandlerWithCallback>,\n    ),\n    validate: validateFactory(config),\n  };\n}\n\nexport type ShopifyWebhooks = ReturnType<typeof shopifyWebhooks>;\n", "import {BillingInterval, BillingReplacementBehavior} from '../types';\nimport {Session} from '../session/session';\nimport {FeatureEnabled, FutureFlagOptions} from '../../future/flags';\n\nexport interface BillingConfigPlan {\n  /**\n   * Amount to charge for this plan.\n   */\n  amount: number;\n  /**\n   * Currency code for this plan.\n   */\n  currencyCode: string;\n}\n\nexport interface BillingConfigOneTimePlan extends BillingConfigPlan {\n  /**\n   * Interval for this plan.\n   *\n   * Must be set to `OneTime`.\n   */\n  interval: BillingInterval.OneTime;\n}\n\nexport interface BillingConfigSubscriptionPlanDiscountAmount {\n  /**\n   * The amount to discount.\n   *\n   * Cannot be set if `percentage` is set.\n   */\n  amount: number;\n  /**\n   * The percentage to discount.\n   *\n   * Cannot be set if `amount` is set.\n   */\n  percentage?: never;\n}\n\nexport interface BillingConfigSubscriptionPlanDiscountPercentage {\n  /**\n   * The amount to discount.\n   *\n   * Cannot be set if `percentage` is set.\n   */\n  amount?: never;\n  /**\n   * The percentage to discount.\n   *\n   * Cannot be set if `amount` is set.\n   */\n  percentage: number;\n}\n\nexport interface BillingConfigSubscriptionPlanDiscount {\n  /**\n   * The number of intervals to apply the discount for.\n   */\n  durationLimitInIntervals?: number;\n  /**\n   * The discount to apply.\n   */\n  value:\n    | BillingConfigSubscriptionPlanDiscountAmount\n    | BillingConfigSubscriptionPlanDiscountPercentage;\n}\n\nexport type BillingConfigItem =\n  | BillingConfigOneTimePlan\n  | BillingConfigSubscriptionLineItemPlan;\n\n// Type this as an interface to improve TSDoc support for it.\n\n/**\n * Billing configuration options, indexed by an app-specific plan name.\n */\nexport interface BillingConfig {\n  /**\n   * An individual billing plan.\n   */\n  [plan: string]: BillingConfigItem;\n}\n\nexport type RequestConfigOverrides = Partial<BillingConfigOneTimePlan>;\n\nexport interface BillingConfigLineItem {\n  /**\n   * The amount to charge for this line item.\n   */\n  amount: number;\n  /**\n   * The currency code for this line item.\n   */\n  currencyCode: string;\n}\n\nexport interface BillingConfigRecurringLineItem extends BillingConfigLineItem {\n  /**\n   * The recurring interval for this line item.\n   *\n   * Must be either `Every30Days` or `Annual`.\n   */\n  interval: BillingInterval.Every30Days | BillingInterval.Annual;\n  /**\n   * An optional discount to apply for this line item.\n   */\n  discount?: BillingConfigSubscriptionPlanDiscount;\n}\n\nexport interface BillingConfigUsageLineItem extends BillingConfigLineItem {\n  /**\n   * The usage interval for this line item.\n   *\n   * Must be set to `Usage`.\n   */\n  interval: BillingInterval.Usage;\n  /**\n   * The capped amount or the maximum amount to be charged in the interval.\n   */\n  amount: number;\n  /**\n   * Usage terms for this line item.\n   */\n  terms: string;\n}\n\nexport interface BillingConfigSubscriptionLineItemPlan {\n  /**\n   * The replacement behavior to use for this plan.\n   */\n  replacementBehavior?: BillingReplacementBehavior;\n  /**\n   * How many trial days to give before charging for this plan.\n   */\n  trialDays?: number;\n  /**\n   * The line items for this plan.\n   */\n  lineItems: (BillingConfigRecurringLineItem | BillingConfigUsageLineItem)[];\n}\n\ntype DeepPartial<T> = T extends object\n  ? {[P in keyof T]?: DeepPartial<T[P]>}\n  : T;\nexport type RequestConfigLineItemOverrides =\n  DeepPartial<BillingConfigSubscriptionLineItemPlan>;\n\ninterface BillingCheckParamsNew {\n  /**\n   * The session to use for this check.\n   */\n  session: Session;\n  /**\n   * The plans to accept for this check.\n   */\n  plans?: string[] | string;\n  /**\n   * Whether to include charges that were created on test mode. Test shops and demo shops cannot be charged.\n   */\n  isTest?: boolean;\n}\n\ninterface BillingCheckParamsOld extends BillingCheckParamsNew {\n  /**\n   * The plans to accept for this check.\n   */\n  plans: string[] | string;\n  /**\n   * Whether to return the full response object.\n   */\n  returnObject?: boolean;\n}\n\nexport type BillingCheckParams<\n  Future extends FutureFlagOptions = FutureFlagOptions,\n> =\n  FeatureEnabled<Future, 'unstable_managedPricingSupport'> extends true\n    ? BillingCheckParamsNew\n    : BillingCheckParamsOld;\n\nexport interface BillingCheckResponseObject {\n  /**\n   * Whether the user has an active payment method.\n   */\n  hasActivePayment: boolean;\n  /**\n   * The one-time purchases the shop has.\n   */\n  oneTimePurchases: OneTimePurchase[];\n  /**\n   * The active subscriptions the shop has.\n   */\n  appSubscriptions: AppSubscription[];\n}\n\nexport type BillingCheckResponse<\n  Params extends BillingCheckParams<Future>,\n  Future extends FutureFlagOptions = FutureFlagOptions,\n> =\n  FeatureEnabled<Future, 'unstable_managedPricingSupport'> extends true\n    ? BillingCheckResponseObject\n    : Params extends BillingCheckParamsOld\n      ? Params['returnObject'] extends true\n        ? BillingCheckResponseObject\n        : boolean\n      : never;\n\ntype BillingRequestOverridesType = RequestConfigOverrides &\n  RequestConfigLineItemOverrides;\n\nexport type BillingRequestParams = {\n  /**\n   * The session to use for this request.\n   */\n  session: Session;\n  /**\n   * The plan to request.\n   */\n  plan: string;\n  /**\n   * Whether this is a test purchase.\n   */\n  isTest?: boolean;\n  /**\n   * Override the return URL after the purchase is complete.\n   */\n  returnUrl?: string;\n  /**\n   * Whether to return the full response object.\n   */\n  returnObject?: boolean;\n} & BillingRequestOverridesType;\n\nexport interface BillingRequestResponseObject {\n  /**\n   * The confirmation URL for this request.\n   */\n  confirmationUrl: string;\n  /**\n   * The one-time purchase created by this request.\n   */\n  oneTimePurchase?: OneTimePurchase;\n  /**\n   * The app subscription created by this request.\n   */\n  appSubscription?: AppSubscription;\n}\n\nexport type BillingRequestResponse<Params extends BillingRequestParams> =\n  Params['returnObject'] extends true ? BillingRequestResponseObject : string;\n\nexport interface BillingCancelParams {\n  /**\n   * The session to use for this request.\n   */\n  session: Session;\n  /**\n   * The subscription ID to cancel.\n   */\n  subscriptionId: string;\n  /**\n   * Whether to prorate the cancellation.\n   */\n  prorate?: boolean;\n  /**\n   * Whether to consider test purchases.\n   */\n  isTest?: boolean;\n}\n\nexport interface BillingSubscriptionParams {\n  /**\n   * The session to use for this request.\n   */\n  session: Session;\n}\n\nexport interface AppSubscription {\n  /**\n   * The ID of the app subscription.\n   */\n  id: string;\n  /**\n   * The name of the purchased plan.\n   */\n  name: string;\n  /**\n   * Whether this is a test subscription.\n   */\n  test: boolean;\n  /**\n   * The number of trial days for this subscription.\n   */\n  trialDays: number;\n  /**\n   * The date and time when the subscription was created.\n   */\n  createdAt: string;\n  /**\n   * The date and time when the current period ends.\n   */\n  currentPeriodEnd: string;\n  /**\n   * The return URL for this subscription.\n   */\n  returnUrl: string;\n\n  /*\n   * The line items for this plan.\n   */\n  lineItems: ActiveSubscriptionLineItem[];\n\n  /*\n   * The status of the subscription. [ACTIVE, CANCELLED, PENDING, DECLINED, EXPIRED, FROZEN, ACCEPTED]\n   */\n  status:\n    | 'ACTIVE'\n    | 'CANCELLED'\n    | 'PENDING'\n    | 'DECLINED'\n    | 'EXPIRED'\n    | 'FROZEN'\n    | 'ACCEPTED';\n}\n\nexport interface ActiveSubscriptions {\n  activeSubscriptions: AppSubscription[];\n}\n\nexport interface ActiveSubscriptionLineItem {\n  /*\n   * The ID of the line item.\n   */\n  id: string;\n  /*\n   * The details of the plan.\n   */\n  plan: AppPlan;\n}\n\nexport interface RecurringAppPlan {\n  /*\n   * The interval for this plan is charged on.\n   */\n  interval: BillingInterval.Every30Days | BillingInterval.Annual;\n  /*\n   * The price of the plan.\n   */\n  price: Money;\n  /*\n   * The discount applied to the plan.\n   */\n  discount: AppPlanDiscount;\n}\n\nexport interface UsageAppPlan {\n  /*\n   * The total usage records for interval.\n   */\n  balanceUsed: Money;\n  /*\n   * The capped amount prevents the merchant from being charged for any usage over that amount during a billing period.\n   */\n  cappedAmount: Money;\n  /*\n   * The terms and conditions for app usage pricing.\n   */\n  terms: string;\n}\n\nexport interface Money {\n  amount: number;\n  currencyCode: string;\n}\n\nexport interface AppPlanDiscount {\n  /*\n   * The total number of intervals the discount applies to.\n   */\n  durationLimitInIntervals: number;\n  /*\n   * The remaining number of intervals the discount applies to.\n   */\n  remainingDurationInIntervals: number;\n  /*\n   * The price after the discount is applied.\n   */\n  priceAfterDiscount: Money;\n  /*\n   * The value of the discount applied every billing interval.\n   */\n  value: AppPlanDiscountAmount;\n}\n\nexport interface AppSubscriptionLineItemUpdatePayload {\n  userErrors: string[];\n  confirmationUrl: string;\n  appSubscription: AppSubscription;\n}\n\nexport type UpdateCappedAmountConfirmation = Omit<\n  AppSubscriptionLineItemUpdatePayload,\n  'userErrors'\n>;\n\ntype AppPlanDiscountAmount =\n  | BillingConfigSubscriptionPlanDiscountAmount\n  | BillingConfigSubscriptionPlanDiscountPercentage;\n\nexport interface AppPlan {\n  /*\n   * The pricing details of the plan.\n   */\n  pricingDetails: RecurringAppPlan | UsageAppPlan;\n}\nexport interface OneTimePurchase {\n  /**\n   * The ID of the one-time purchase.\n   */\n  id: string;\n  /**\n   * The name of the purchased plan.\n   */\n  name: string;\n  /**\n   * Whether this is a test purchase.\n   */\n  test: boolean;\n  /*\n   * The status of the subscription. [ACTIVE, CANCELLED, PENDING, DECLINED, EXPIRED, FROZEN, ACCEPTED]\n   */\n  status:\n    | 'ACTIVE'\n    | 'CANCELLED'\n    | 'PENDING'\n    | 'DECLINED'\n    | 'EXPIRED'\n    | 'FROZEN'\n    | 'ACCEPTED';\n}\n\nexport interface BillingCreateUsageRecordParams {\n  /**\n   * The session to use for this request.\n   */\n  session: Session;\n  /**\n   * The description of the usage record.\n   */\n  description: string;\n  /**\n   * The price and currency of the usage record.\n   */\n  price: {\n    /**\n     * The amount to charge for this usage record.\n     */\n    amount: number;\n    /**\n     * The currency code for this usage record.\n     */\n    currencyCode: string;\n  };\n  /**\n   * The subscription line item ID to associate the usage record with.\n   */\n  subscriptionLineItemId?: string;\n  /**\n   * The idempotency key for this request.\n   */\n  idempotencyKey?: string;\n  /**\n   * Whether this is a test charge.\n   * */\n  isTest?: boolean;\n}\n\nexport interface UsageRecord {\n  /**\n   * The ID of the usage record.\n   */\n  id: string;\n  /**\n   * The description of the usage record.\n   */\n  description: string;\n  /**\n   * The price and currency of the usage record.\n   */\n  price: {\n    /**\n     * The amount to charge for this usage record.\n     */\n    amount: number;\n    /**\n     * The currency code for this usage record.\n     */\n    currencyCode: string;\n  };\n  /**\n   * The subscription line item associated with the usage record.\n   */\n  plan: ActiveSubscriptionLineItem;\n  /**\n   * The idempotency key for this request.\n   */\n  idempotencyKey?: string;\n  /**\n   * The subscription line item associated with the usage record.\n   */\n  subscriptionLineItem: AppSubscriptionLineItem;\n}\n\nexport interface AppSubscriptionLineItem {\n  /**\n   * The ID of the subscription line item.\n   */\n  id: string;\n  /**\n   * The plan associated with the subscription line item.\n   */\n  plan: AppPlan;\n}\n\nexport interface BillingUpdateUsageCappedAmountParams {\n  /**\n   * The session to use for this request.\n   */\n  session: Session;\n  /**\n   * The subscription line item ID to update.\n   */\n  subscriptionLineItemId: string;\n  /**\n   * The maximum charge for the usage billing plan.\n   */\n  cappedAmount: {\n    /**\n     * The amount to update.\n     */\n    amount: number;\n    /**\n     * The currency code to update.\n     */\n    currencyCode: string;\n  };\n}\n\ninterface OneTimePurchases {\n  oneTimePurchases: {\n    edges: {\n      node: OneTimePurchase;\n    }[];\n    pageInfo: {\n      endCursor: string;\n      hasNextPage: boolean;\n    };\n  };\n}\n\nexport type CurrentAppInstallation = OneTimePurchases & ActiveSubscriptions;\n\nexport interface CurrentAppInstallations {\n  currentAppInstallation?: CurrentAppInstallation;\n}\n\nexport interface RequestResponse {\n  userErrors: string[];\n  confirmationUrl: string;\n}\n\ninterface AppSubscriptionCreate {\n  userErrors: string[];\n  confirmationUrl: string;\n  appSubscription: AppSubscription;\n}\n\ninterface AppPurchaseOneTimeCreate {\n  userErrors: string[];\n  confirmationUrl: string;\n  oneTimePurchase: OneTimePurchase;\n}\n\nexport interface RecurringPaymentResponse {\n  appSubscriptionCreate?: AppSubscriptionCreate;\n}\n\nexport interface SinglePaymentResponse {\n  appPurchaseOneTimeCreate?: AppPurchaseOneTimeCreate;\n}\n\nexport type RequestResponseData =\n  | AppSubscriptionCreate\n  | AppPurchaseOneTimeCreate;\n\nexport interface SubscriptionResponse {\n  currentAppInstallation?: ActiveSubscriptions;\n}\n\nexport interface CancelResponse {\n  appSubscriptionCancel?: {\n    appSubscription: AppSubscription;\n    userErrors: string[];\n  };\n}\n\nexport interface UsageRecordCreateResponse {\n  appUsageRecordCreate?: {\n    appUsageRecord: UsageRecord;\n    userErrors: string[];\n  };\n}\n\nexport interface BillingUpdateUsageCappedAmountResponse {\n  appSubscriptionLineItemUpdate?: AppSubscriptionLineItemUpdatePayload;\n}\n\nexport type BillingCheck<Future extends FutureFlagOptions> = <\n  Params extends BillingCheckParams<Future>,\n>(\n  params: Params,\n) => Promise<BillingCheckResponse<Params, Future>>;\n\nexport type BillingRequest = <Params extends BillingRequestParams>(\n  params: Params,\n) => Promise<BillingRequestResponse<Params>>;\n\nexport type BillingCancel = (\n  params: BillingCancelParams,\n) => Promise<AppSubscription>;\n\nexport type BillingSubscriptions = (\n  params: BillingSubscriptionParams,\n) => Promise<ActiveSubscriptions>;\n\nexport type BillingCreateUsageRecord = (\n  params: BillingCreateUsageRecordParams,\n) => Promise<UsageRecord>;\n\nexport type BillingUpdateUsageCappedAmount = (\n  params: BillingUpdateUsageCappedAmountParams,\n) => Promise<UpdateCappedAmountConfirmation>;\n\nexport interface ShopifyBilling<Future extends FutureFlagOptions> {\n  check: BillingCheck<Future>;\n  request: BillingRequest;\n  cancel: BillingCancel;\n  subscriptions: BillingSubscriptions;\n  createUsageRecord: BillingCreateUsageRecord;\n  updateUsageCappedAmount: BillingUpdateUsageCappedAmount;\n}\n\nexport const APP_SUBSCRIPTION_FRAGMENT = `\n  fragment AppSubscriptionFragment on AppSubscription {\n    id\n    name\n    test\n    status\n    trialDays\n    createdAt\n    currentPeriodEnd\n    returnUrl\n    lineItems {\n      id\n      plan {\n        pricingDetails {\n          ... on AppRecurringPricing {\n            price {\n              amount\n              currencyCode\n            }\n            interval\n            discount {\n              durationLimitInIntervals\n              remainingDurationInIntervals\n              priceAfterDiscount {\n                amount\n              }\n              value {\n                ... on AppSubscriptionDiscountAmount {\n                  amount {\n                    amount\n                    currencyCode\n                  }\n                }\n                ... on AppSubscriptionDiscountPercentage {\n                  percentage\n                }\n              }\n            }\n          }\n          ... on AppUsagePricing {\n            balanceUsed {\n              amount\n              currencyCode\n            }\n            cappedAmount {\n              amount\n              currencyCode\n            }\n            terms\n          }\n        }\n      }\n    }\n  }\n`;\n", "import {ActiveSubscriptionLineItem} from './types';\n\n/**\n * Converts string amounts to numbers in Money type objects\n */\nexport function convertMoneyAmount(data: any) {\n  if (!data) return data;\n\n  convertAppUsagePricingMoney(data);\n  convertAppRecurringPricingMoney(data);\n  convertAppDiscountMoney(data);\n\n  return data;\n}\n\nexport function convertAppRecurringPricingMoney(data: any): void {\n  if (!data) return;\n\n  if (data.price?.amount && typeof data.price.amount === 'string') {\n    data.price.amount = parseFloat(data.price.amount);\n  }\n}\n\nexport function convertAppDiscountMoney(data: any): void {\n  if (!data) return;\n\n  if (\n    data.discount?.priceAfterDiscount?.amount &&\n    typeof data.discount.priceAfterDiscount.amount === 'string'\n  ) {\n    data.discount.priceAfterDiscount.amount = parseFloat(\n      data.discount.priceAfterDiscount.amount,\n    );\n  }\n\n  if (\n    data.discount?.value?.amount?.amount &&\n    typeof data.discount.value.amount.amount === 'string'\n  ) {\n    data.discount.value.amount.amount = parseFloat(\n      data.discount.value.amount.amount,\n    );\n  }\n}\n\nexport function convertAppUsagePricingMoney(data: any): void {\n  if (!data) return;\n\n  if (data.balanceUsed?.amount && typeof data.balanceUsed.amount === 'string') {\n    data.balanceUsed.amount = parseFloat(data.balanceUsed.amount);\n  }\n\n  if (\n    data.cappedAmount?.amount &&\n    typeof data.cappedAmount.amount === 'string'\n  ) {\n    data.cappedAmount.amount = parseFloat(data.cappedAmount.amount);\n  }\n}\n\n/**\n * Converts Money amounts in line items\n */\nexport function convertLineItems(lineItems: ActiveSubscriptionLineItem[]) {\n  return lineItems.map((item) => {\n    if (item.plan?.pricingDetails) {\n      item.plan.pricingDetails = convertMoneyAmount(item.plan.pricingDetails);\n    }\n    return item;\n  });\n}\n", "import {FutureFlagOptions} from '../../future/flags';\nimport {ConfigInterface} from '../base-types';\nimport {graphqlClientClass, GraphqlClient} from '../clients/admin';\nimport {BillingError} from '../error';\n\nimport {\n  AppSubscription,\n  BillingCheck,\n  BillingCheckParams,\n  BillingCheckResponse,\n  BillingCheckResponseObject,\n  CurrentAppInstallation,\n  CurrentAppInstallations,\n  OneTimePurchase,\n  APP_SUBSCRIPTION_FRAGMENT,\n} from './types';\nimport {convertLineItems} from './utils';\n\ninterface SubscriptionMeetsCriteriaParams {\n  subscription: AppSubscription;\n  isTest?: boolean;\n  plans?: string | string[];\n}\n\ninterface PurchaseMeetsCriteriaParams {\n  purchase: OneTimePurchase;\n  isTest?: boolean;\n  plans?: string | string[];\n}\n\ninterface InternalParams {\n  client: GraphqlClient;\n  isTest?: boolean;\n  plans?: string | string[];\n}\n\nexport function check<\n  Config extends ConfigInterface,\n  Future extends FutureFlagOptions = Config['future'],\n>(config: Config): BillingCheck<Future> {\n  return async function check<Params extends BillingCheckParams<Future>>(\n    params: Params,\n  ): Promise<BillingCheckResponse<Params, Future>> {\n    if (!config.future?.unstable_managedPricingSupport && !config.billing) {\n      throw new BillingError({\n        message: 'Attempted to look for purchases without billing configs',\n        errorData: [],\n      });\n    }\n\n    const {session, isTest = true, plans} = params;\n    const returnObject =\n      (params as BillingCheckParams<{unstable_managedPricingSupport: false}>)\n        .returnObject ?? false;\n\n    const GraphqlClient = graphqlClientClass({config});\n    const client = new GraphqlClient({session});\n\n    const payments = await assessPayments({client, isTest, plans});\n\n    if (config.future?.unstable_managedPricingSupport || returnObject) {\n      return payments as BillingCheckResponse<Params, Future>;\n    } else {\n      return payments.hasActivePayment as BillingCheckResponse<Params, Future>;\n    }\n  };\n}\n\nexport async function assessPayments({\n  client,\n  isTest,\n  plans,\n}: InternalParams): Promise<BillingCheckResponseObject> {\n  const returnValue: BillingCheckResponseObject = {\n    hasActivePayment: false,\n    oneTimePurchases: [],\n    appSubscriptions: [],\n  };\n\n  let installation: CurrentAppInstallation;\n  let endCursor: string | null = null;\n  do {\n    const currentInstallations = await client.request<CurrentAppInstallations>(\n      HAS_PAYMENTS_QUERY,\n      {variables: {endCursor}},\n    );\n\n    installation = currentInstallations.data?.currentAppInstallation!;\n    installation.activeSubscriptions.forEach((subscription) => {\n      if (subscriptionMeetsCriteria({subscription, isTest, plans})) {\n        returnValue.hasActivePayment = true;\n        if (subscription.lineItems) {\n          subscription.lineItems = convertLineItems(subscription.lineItems);\n        }\n        returnValue.appSubscriptions.push(subscription);\n      }\n    });\n    installation.oneTimePurchases.edges.forEach(({node: purchase}) => {\n      if (purchaseMeetsCriteria({purchase, isTest, plans})) {\n        returnValue.hasActivePayment = true;\n        returnValue.oneTimePurchases.push(purchase);\n      }\n    });\n\n    endCursor = installation.oneTimePurchases.pageInfo.endCursor;\n  } while (installation?.oneTimePurchases.pageInfo.hasNextPage);\n\n  return returnValue;\n}\n\nfunction subscriptionMeetsCriteria({\n  subscription,\n  isTest,\n  plans,\n}: SubscriptionMeetsCriteriaParams): boolean {\n  return (\n    (typeof plans === 'undefined' || plans.includes(subscription.name)) &&\n    (isTest || !subscription.test)\n  );\n}\n\nfunction purchaseMeetsCriteria({\n  purchase,\n  isTest,\n  plans,\n}: PurchaseMeetsCriteriaParams): boolean {\n  return (\n    (typeof plans === 'undefined' || plans.includes(purchase.name)) &&\n    (isTest || !purchase.test) &&\n    purchase.status === 'ACTIVE'\n  );\n}\n\nconst HAS_PAYMENTS_QUERY = `\n  ${APP_SUBSCRIPTION_FRAGMENT}\n  query appSubscription($endCursor: String) {\n    currentAppInstallation {\n      activeSubscriptions {\n        ...AppSubscriptionFragment\n      }\n      oneTimePurchases(first: 250, sortKey: CREATED_AT, after: $endCursor) {\n        edges {\n          node {\n            id\n            name\n            test\n            status\n          }\n        }\n        pageInfo {\n          hasNextPage\n          endCursor\n        }\n      }\n    }\n  }\n`;\n", "import {ConfigInterface, ConfigParams} from '../base-types';\nimport {BillingInterval} from '../types';\nimport {BillingError} from '../error';\nimport {buildEmbeddedAppUrl} from '../auth/get-embedded-app-url';\nimport {GraphqlClient, graphqlClientClass} from '../clients/admin';\nimport {hashString} from '../../runtime/crypto';\nimport {HashFormat} from '../../runtime/crypto/types';\nimport {FutureFlagOptions} from '../../future/flags';\n\nimport {\n  BillingConfigOneTimePlan,\n  BillingRequestParams,\n  BillingRequestResponse,\n  RecurringPaymentResponse,\n  RequestResponseData,\n  SinglePaymentResponse,\n  BillingConfigSubscriptionLineItemPlan,\n  RequestConfigLineItemOverrides,\n  BillingRequest,\n  APP_SUBSCRIPTION_FRAGMENT,\n} from './types';\n\nconst RECURRING_PURCHASE_MUTATION = `\n  ${APP_SUBSCRIPTION_FRAGMENT}\n  mutation AppSubscriptionCreate(\n    $name: String!\n    $returnUrl: URL!\n    $test: Boolean\n    $trialDays: Int\n    $replacementBehavior: AppSubscriptionReplacementBehavior\n    $lineItems: [AppSubscriptionLineItemInput!]!\n  ) {\n    appSubscriptionCreate(\n      name: $name\n      returnUrl: $returnUrl\n      test: $test\n      trialDays: $trialDays\n      replacementBehavior: $replacementBehavior\n      lineItems: $lineItems\n    ) {\n      appSubscription {\n        ...AppSubscriptionFragment\n      }\n      confirmationUrl\n      userErrors {\n        field\n        message\n      }\n    }\n  }\n`;\n\nconst ONE_TIME_PURCHASE_MUTATION = `\n  mutation test(\n    $name: String!\n    $price: MoneyInput!\n    $returnUrl: URL!\n    $test: Boolean\n  ) {\n    appPurchaseOneTimeCreate(\n      name: $name\n      price: $price\n      returnUrl: $returnUrl\n      test: $test\n    ) {\n      appPurchaseOneTime {\n        id\n        name\n        test\n      }\n      confirmationUrl\n      userErrors {\n        field\n        message\n      }\n    }\n  }\n`;\n\ninterface RequestInternalParams {\n  client: GraphqlClient;\n  plan: string;\n  returnUrl: string;\n  isTest: boolean;\n}\n\ninterface RequestOneTimePaymentInternalParams extends RequestInternalParams {\n  billingConfig: BillingConfigOneTimePlan;\n}\n\ninterface RequestSubscriptionParams extends RequestInternalParams {\n  billingConfig: BillingConfigSubscriptionLineItemPlan;\n}\n\nexport function request<\n  Config extends ConfigInterface<Params>,\n  Params extends ConfigParams<any, Future>,\n  Future extends FutureFlagOptions,\n>(config: Config): BillingRequest {\n  return async function <Params extends BillingRequestParams>({\n    session,\n    plan,\n    isTest = true,\n    returnUrl: returnUrlParam,\n    returnObject = false,\n    ...overrides\n  }: Params): Promise<BillingRequestResponse<Params>> {\n    if (!config.billing || !config.billing[plan]) {\n      throw new BillingError({\n        message: `Could not find plan ${plan} in billing settings`,\n        errorData: [],\n      });\n    }\n\n    const billingConfig = {\n      ...config.billing[plan],\n    };\n    const filteredOverrides = Object.fromEntries(\n      Object.entries(overrides).filter(([_key, value]) => value !== undefined),\n    );\n\n    const cleanShopName = session.shop.replace('.myshopify.com', '');\n    const embeddedAppUrl = buildEmbeddedAppUrl(config)(\n      hashString(`admin.shopify.com/store/${cleanShopName}`, HashFormat.Base64),\n    );\n\n    const appUrl = `${config.hostScheme}://${config.hostName}?shop=${session.shop}`;\n\n    // if provided a return URL, use it, otherwise use the embedded app URL or hosted app URL\n    const returnUrl =\n      returnUrlParam || (config.isEmbeddedApp ? embeddedAppUrl : appUrl);\n\n    const GraphqlClient = graphqlClientClass({config});\n    const client = new GraphqlClient({session});\n\n    function isLineItemPlan(\n      billingConfig: any,\n    ): billingConfig is BillingConfigSubscriptionLineItemPlan {\n      return 'lineItems' in billingConfig;\n    }\n\n    function isOneTimePlan(\n      billingConfig: any,\n    ): billingConfig is BillingConfigOneTimePlan {\n      return billingConfig.interval === BillingInterval.OneTime;\n    }\n\n    let data: RequestResponseData;\n    if (isLineItemPlan(billingConfig)) {\n      const mergedBillingConfigs = mergeBillingConfigs(\n        billingConfig,\n        filteredOverrides,\n      );\n      const mutationRecurringResponse = await requestSubscriptionPayment({\n        billingConfig: mergedBillingConfigs,\n        plan,\n        client,\n        returnUrl,\n        isTest,\n      });\n\n      data = mutationRecurringResponse.appSubscriptionCreate!;\n    } else if (isOneTimePlan(billingConfig)) {\n      const mutationOneTimeResponse = await requestSinglePayment({\n        billingConfig: {...billingConfig, ...filteredOverrides},\n        plan,\n        client,\n        returnUrl,\n        isTest,\n      });\n      data = mutationOneTimeResponse.appPurchaseOneTimeCreate!;\n    } else {\n      throw new BillingError({\n        message: `Invalid billing configuration for plan ${plan}. Must be either a one-time plan or a subscription plan with line items.`,\n        errorData: [],\n      });\n    }\n\n    if (data.userErrors?.length) {\n      throw new BillingError({\n        message: 'Error while billing the store',\n        errorData: data.userErrors,\n      });\n    }\n\n    if (returnObject) {\n      return data as Omit<\n        RequestResponseData,\n        'userErrors'\n      > as BillingRequestResponse<Params>;\n    } else {\n      return data.confirmationUrl as BillingRequestResponse<Params>;\n    }\n  };\n}\n\nasync function requestSubscriptionPayment({\n  billingConfig,\n  plan,\n  client,\n  returnUrl,\n  isTest,\n}: RequestSubscriptionParams): Promise<RecurringPaymentResponse> {\n  const lineItems = billingConfig.lineItems.map((item) => {\n    if (\n      item.interval === BillingInterval.Every30Days ||\n      item.interval === BillingInterval.Annual\n    ) {\n      const appRecurringPricingDetails: any = {\n        interval: item.interval,\n        price: {\n          amount: item.amount,\n          currencyCode: item.currencyCode,\n        },\n      };\n\n      if (item.discount) {\n        appRecurringPricingDetails.discount = {\n          durationLimitInIntervals: item.discount.durationLimitInIntervals,\n          value: {\n            amount: item.discount.value.amount,\n            percentage: item.discount.value.percentage,\n          },\n        };\n      }\n\n      return {\n        plan: {\n          appRecurringPricingDetails,\n        },\n      };\n    } else if (item.interval === BillingInterval.Usage) {\n      const appUsagePricingDetails = {\n        terms: item.terms,\n        cappedAmount: {\n          amount: item.amount,\n          currencyCode: item.currencyCode,\n        },\n      };\n\n      return {\n        plan: {\n          appUsagePricingDetails,\n        },\n      };\n    } else {\n      throw new BillingError({\n        message: 'Invalid interval provided',\n        errorData: [item],\n      });\n    }\n  });\n\n  const mutationResponse = await client.request<RecurringPaymentResponse>(\n    RECURRING_PURCHASE_MUTATION,\n    {\n      variables: {\n        name: plan,\n        trialDays: billingConfig.trialDays,\n        replacementBehavior: billingConfig.replacementBehavior,\n        returnUrl,\n        test: isTest,\n        lineItems,\n      },\n    },\n  );\n\n  if (mutationResponse.errors) {\n    throw new BillingError({\n      message: 'Error while billing the store',\n      errorData: mutationResponse.errors,\n    });\n  }\n\n  return mutationResponse.data!;\n}\n\nasync function requestSinglePayment({\n  billingConfig,\n  plan,\n  client,\n  returnUrl,\n  isTest,\n}: RequestOneTimePaymentInternalParams): Promise<SinglePaymentResponse> {\n  const mutationResponse = await client.request<SinglePaymentResponse>(\n    ONE_TIME_PURCHASE_MUTATION,\n    {\n      variables: {\n        name: plan,\n        returnUrl,\n        test: isTest,\n        price: {\n          amount: billingConfig.amount,\n          currencyCode: billingConfig.currencyCode,\n        },\n      },\n    },\n  );\n\n  if (mutationResponse.errors) {\n    throw new BillingError({\n      message: 'Error while billing the store',\n      errorData: mutationResponse.errors,\n    });\n  }\n\n  return mutationResponse.data!;\n}\n\nfunction mergeBillingConfigs(\n  billingConfig: BillingConfigSubscriptionLineItemPlan,\n  overrides: RequestConfigLineItemOverrides,\n): BillingConfigSubscriptionLineItemPlan {\n  const mergedConfig = {...billingConfig, ...overrides};\n  const mergedLineItems = [];\n\n  if (billingConfig.lineItems && overrides.lineItems) {\n    for (const i of billingConfig.lineItems) {\n      let found = false;\n\n      for (const j of overrides.lineItems) {\n        if (i.interval === j!.interval) {\n          mergedLineItems.push({...i, ...j});\n          found = true;\n          break;\n        }\n      }\n\n      if (!found) {\n        mergedLineItems.push(i);\n      }\n    }\n\n    mergedConfig.lineItems = mergedLineItems;\n  }\n\n  return mergedConfig as BillingConfigSubscriptionLineItemPlan;\n}\n", "import {ConfigInterface} from '../base-types';\nimport {graphqlClientClass} from '../clients/admin';\nimport {BillingError, GraphqlQueryError} from '../error';\n\nimport {\n  AppSubscription,\n  BillingCancel,\n  BillingCancelParams,\n  CancelResponse,\n  APP_SUBSCRIPTION_FRAGMENT,\n} from './types';\n\nconst CANCEL_MUTATION = `\n  ${APP_SUBSCRIPTION_FRAGMENT}\n  mutation appSubscriptionCancel($id: ID!, $prorate: Boolean) {\n    appSubscriptionCancel(id: $id, prorate: $prorate) {\n      appSubscription {\n        ...AppSubscriptionFragment\n      }\n      userErrors {\n        field\n        message\n      }\n    }\n  }\n`;\n\nexport function cancel(config: ConfigInterface): BillingCancel {\n  return async function (\n    subscriptionInfo: BillingCancelParams,\n  ): Promise<AppSubscription> {\n    const {session, subscriptionId, prorate = true} = subscriptionInfo;\n\n    const GraphqlClient = graphqlClientClass({config});\n    const client = new GraphqlClient({session});\n\n    try {\n      const response = await client.request<CancelResponse>(CANCEL_MUTATION, {\n        variables: {id: subscriptionId, prorate},\n      });\n\n      if (response.data?.appSubscriptionCancel?.userErrors.length) {\n        throw new BillingError({\n          message: 'Error while canceling a subscription',\n          errorData: response.data?.appSubscriptionCancel?.userErrors,\n        });\n      }\n\n      return response.data?.appSubscriptionCancel?.appSubscription!;\n    } catch (error) {\n      if (error instanceof GraphqlQueryError) {\n        throw new BillingError({\n          message: error.message,\n          errorData: error.response?.errors,\n        });\n      } else {\n        throw error;\n      }\n    }\n  };\n}\n", "import {BillingError} from '../error';\nimport {ConfigInterface} from '../base-types';\nimport {graphqlClientClass} from '../clients/admin';\n\nimport {\n  ActiveSubscriptions,\n  BillingSubscriptionParams,\n  BillingSubscriptions,\n  SubscriptionResponse,\n  APP_SUBSCRIPTION_FRAGMENT,\n} from './types';\nimport {convertLineItems} from './utils';\n\nconst SUBSCRIPTION_QUERY = `\n${APP_SUBSCRIPTION_FRAGMENT}\nquery appSubscription {\n  currentAppInstallation {\n    activeSubscriptions {\n      ...AppSubscriptionFragment\n    }\n  }\n}\n`;\n\nexport function subscriptions(config: ConfigInterface): BillingSubscriptions {\n  return async function ({\n    session,\n  }: BillingSubscriptionParams): Promise<ActiveSubscriptions> {\n    if (!config.future?.unstable_managedPricingSupport && !config.billing) {\n      throw new BillingError({\n        message: 'Attempted to look for purchases without billing configs',\n        errorData: [],\n      });\n    }\n\n    const GraphqlClient = graphqlClientClass({config});\n    const client = new GraphqlClient({session});\n\n    const response =\n      await client.request<SubscriptionResponse>(SUBSCRIPTION_QUERY);\n\n    if (!response.data?.currentAppInstallation?.activeSubscriptions) {\n      return {activeSubscriptions: []};\n    }\n\n    const activeSubscriptions =\n      response.data.currentAppInstallation.activeSubscriptions;\n    activeSubscriptions.forEach((subscription) => {\n      if (subscription.lineItems) {\n        subscription.lineItems = convertLineItems(subscription.lineItems);\n      }\n    });\n\n    return {\n      activeSubscriptions,\n    };\n  };\n}\n", "import {ConfigInterface} from '../base-types';\nimport {BillingError, GraphqlQueryError} from '../error';\nimport {GraphqlClient, graphqlClientClass} from '../clients/admin';\n\nimport {\n  AppSubscription,\n  BillingCreateUsageRecord,\n  BillingCreateUsageRecordParams,\n  UsageRecord,\n  UsageRecordCreateResponse,\n  Money,\n} from './types';\nimport {assessPayments} from './check';\nimport {convertAppRecurringPricingMoney, convertAppUsagePricingMoney} from './utils';\ninterface InternalParams {\n  client: GraphqlClient;\n  isTest?: boolean;\n}\n\ninterface CreateUsageRecordVariables {\n  description: string;\n  price: Money;\n  subscriptionLineItemId: string;\n  idempotencyKey?: string;\n}\n\nconst CREATE_USAGE_RECORD_MUTATION = `\nmutation appUsageRecordCreate($description: String!, $price: MoneyInput!, $subscriptionLineItemId: ID!) {\n  appUsageRecordCreate(description: $description, price: $price, subscriptionLineItemId: $subscriptionLineItemId) {\n    userErrors {\n      field\n      message\n    }\n    appUsageRecord {\n      id\n      description\n      idempotencyKey\n      price {\n        amount\n        currencyCode\n      }\n      subscriptionLineItem {\n        id\n        plan {\n          pricingDetails {\n            ... on AppUsagePricing {\n              balanceUsed {\n                amount\n                currencyCode\n              }\n              cappedAmount {\n                amount\n                currencyCode\n              }\n              terms\n            }\n          }\n        }\n      }\n    }\n  }\n}\n`;\n\nexport function createUsageRecord(\n  config: ConfigInterface,\n): BillingCreateUsageRecord {\n  return async function createUsageRecord(\n    usageRecordInfo: BillingCreateUsageRecordParams,\n  ): Promise<UsageRecord> {\n    const {\n      session,\n      subscriptionLineItemId,\n      description,\n      price,\n      idempotencyKey,\n      isTest = true,\n    } = usageRecordInfo;\n\n    const GraphqlClient = graphqlClientClass({config});\n    const client = new GraphqlClient({session});\n\n    // If a subscription line item ID is not passed, we will query Shopify\n    // for an active usage subscription line item ID\n    const usageSubscriptionLineItemId = subscriptionLineItemId\n      ? subscriptionLineItemId\n      : await getUsageRecordSubscriptionLineItemId({client, isTest});\n\n    const variables: CreateUsageRecordVariables = {\n      description,\n      price,\n      subscriptionLineItemId: usageSubscriptionLineItemId,\n    };\n    if (idempotencyKey) {\n      variables.idempotencyKey = idempotencyKey;\n    }\n\n    try {\n      const response = await client.request<UsageRecordCreateResponse>(\n        CREATE_USAGE_RECORD_MUTATION,\n        {\n          variables,\n        },\n      );\n      if (response.data?.appUsageRecordCreate?.userErrors.length) {\n        throw new BillingError({\n          message: 'Error while creating a usage record',\n          errorData: response.data?.appUsageRecordCreate?.userErrors,\n        });\n      }\n\n      const appUsageRecord = response.data?.appUsageRecordCreate?.appUsageRecord!;\n      convertAppRecurringPricingMoney(appUsageRecord.price);\n      convertAppUsagePricingMoney(appUsageRecord.subscriptionLineItem.plan.pricingDetails);\n\n      return appUsageRecord;\n    } catch (error) {\n      if (error instanceof GraphqlQueryError) {\n        throw new BillingError({\n          message: error.message,\n          errorData: error.response?.errors,\n        });\n      } else {\n        throw error;\n      }\n    }\n  };\n}\n\nasync function getUsageRecordSubscriptionLineItemId({\n  client,\n  isTest,\n}: InternalParams): Promise<string> {\n  const payments = await assessPayments({client, isTest});\n\n  if (!payments.hasActivePayment) {\n    throw new BillingError({\n      message: 'No active payment found',\n      errorData: [],\n    });\n  }\n  if (!payments.appSubscriptions.length) {\n    throw new BillingError({\n      message: 'No active subscriptions found',\n      errorData: [],\n    });\n  }\n  if (payments.appSubscriptions) {\n    const usageSubscriptionLineItemId = getUsageLineItemId(\n      payments.appSubscriptions,\n    );\n    return usageSubscriptionLineItemId;\n  }\n  throw new BillingError({\n    message: 'Unable to find active subscription line item',\n    errorData: [],\n  });\n}\n\nfunction getUsageLineItemId(subscriptions: AppSubscription[]): string {\n  for (const subscription of subscriptions) {\n    // An app can have only one active subscription\n    if (subscription.status === 'ACTIVE' && subscription.lineItems) {\n      // An app can have only one usage subscription line item\n      for (const lineItem of subscription.lineItems) {\n        if ('balanceUsed' in lineItem.plan.pricingDetails) {\n          return lineItem.id;\n        }\n      }\n    }\n  }\n\n  throw new BillingError({\n    message: 'No active usage subscription found',\n    errorData: [],\n  });\n}\n", "import {BillingError, GraphqlQueryError} from '../error';\nimport {ConfigInterface} from '../base-types';\nimport {graphqlClientClass} from '../clients/admin';\n\nimport {\n  BillingUpdateUsageCappedAmount,\n  BillingUpdateUsageCappedAmountParams,\n  BillingUpdateUsageCappedAmountResponse,\n  UpdateCappedAmountConfirmation,\n  APP_SUBSCRIPTION_FRAGMENT,\n} from './types';\nimport {convertLineItems} from './utils';\n\nconst UPDATE_USAGE_CAPPED_AMOUNT_MUTATION = `\n${APP_SUBSCRIPTION_FRAGMENT}\nmutation appSubscriptionLineItemUpdate($cappedAmount: MoneyInput!, $id: ID!) {\n  appSubscriptionLineItemUpdate(cappedAmount: $cappedAmount, id: $id) {\n    userErrors {\n      field\n      message\n    }\n    confirmationUrl\n    appSubscription {\n      ...AppSubscriptionFragment\n    }\n  }\n}\n`;\n\nexport function updateUsageCappedAmount(\n  config: ConfigInterface,\n): BillingUpdateUsageCappedAmount {\n  return async function updateUsageCappedAmount(\n    params: BillingUpdateUsageCappedAmountParams,\n  ): Promise<UpdateCappedAmountConfirmation> {\n    if (!config.billing) {\n      throw new BillingError({\n        message: 'Attempted to update line item without billing configs',\n        errorData: [],\n      });\n    }\n\n    const {\n      session,\n      subscriptionLineItemId,\n      cappedAmount: {amount, currencyCode},\n    } = params;\n\n    const GraphqlClient = graphqlClientClass({config});\n    const client = new GraphqlClient({session});\n\n    try {\n      const response =\n        await client.request<BillingUpdateUsageCappedAmountResponse>(\n          UPDATE_USAGE_CAPPED_AMOUNT_MUTATION,\n          {\n            variables: {\n              id: subscriptionLineItemId,\n              cappedAmount: {\n                amount,\n                currencyCode,\n              },\n            },\n          },\n        );\n\n      if (response.data?.appSubscriptionLineItemUpdate?.userErrors.length) {\n        throw new BillingError({\n          message: 'Error while updating usage subscription capped amount',\n          errorData: response.data?.appSubscriptionLineItemUpdate?.userErrors,\n        });\n      }\n\n      const appSubscription =\n        response.data?.appSubscriptionLineItemUpdate?.appSubscription!;\n      if (appSubscription && appSubscription.lineItems) {\n        appSubscription.lineItems = convertLineItems(appSubscription.lineItems);\n      }\n\n      return {\n        confirmationUrl:\n          response.data?.appSubscriptionLineItemUpdate?.confirmationUrl!,\n        appSubscription,\n      };\n    } catch (error) {\n      if (error instanceof GraphqlQueryError) {\n        throw new BillingError({\n          message: error.message,\n          errorData: error.response?.errors,\n        });\n      }\n\n      throw error;\n    }\n  };\n}\n", "import {ConfigInterface} from '../base-types';\nimport {FutureFlagOptions} from '../../future/flags';\n\nimport {check} from './check';\nimport {request} from './request';\nimport {cancel} from './cancel';\nimport {subscriptions} from './subscriptions';\nimport {createUsageRecord} from './create-usage-record';\nimport {updateUsageCappedAmount} from './update-usage-subscription-capped-amount';\nimport {ShopifyBilling} from './types';\n\nexport type {ShopifyBilling} from './types';\n\nexport function shopifyBilling<Future extends FutureFlagOptions>(\n  config: ConfigInterface,\n): ShopifyBilling<Future> {\n  return {\n    check: check(config),\n    request: request(config),\n    cancel: cancel(config),\n    subscriptions: subscriptions(config),\n    createUsageRecord: createUsageRecord(config),\n    updateUsageCappedAmount: updateUsageCappedAmount(config),\n  };\n}\n", "import {\n  HmacValidationType,\n  ValidationInvalid,\n  ValidationValid,\n  ValidateParams,\n} from '../utils/types';\nimport {validateHmacFromRequestFactory} from '../utils/hmac-validator';\nimport {ConfigInterface} from '../base-types';\n\nexport function validateFactory(config: ConfigInterface) {\n  return async function validate({\n    rawBody,\n    ...adapterArgs\n  }: ValidateParams): Promise<ValidationInvalid | ValidationValid> {\n    return validateHmacFromRequestFactory(config)({\n      type: HmacValidationType.Flow,\n      rawBody,\n      ...adapterArgs,\n    });\n  };\n}\n", "import {ConfigInterface} from '../base-types';\n\nimport {validateFactory} from './validate';\n\nexport function shopifyFlow(config: ConfigInterface) {\n  return {\n    validate: validateFactory(config),\n  };\n}\n\nexport type ShopifyFlow = ReturnType<typeof shopifyFlow>;\n", "import {ConfigInterface} from '../base-types';\nimport {validateHmacFromRequestFactory} from '../utils/hmac-validator';\nimport {\n  HmacValidationType,\n  ValidateParams,\n  ValidationInvalid,\n  ValidationValid,\n} from '../utils/types';\n\nexport function validateFactory(config: ConfigInterface) {\n  return async function validate({\n    rawBody,\n    ...adapterArgs\n  }: ValidateParams): Promise<ValidationInvalid | ValidationValid> {\n    return validateHmacFromRequestFactory(config)({\n      type: HmacValidationType.FulfillmentService,\n      rawBody,\n      ...adapterArgs,\n    });\n  };\n}\n", "import {ConfigInterface} from '../base-types';\n\nimport {validateFactory} from './validate';\n\nexport function fulfillmentService(config: ConfigInterface) {\n  return {\n    validate: validateFactory(config),\n  };\n}\n\nexport type FulfillmentService = ReturnType<typeof fulfillmentService>;\n", "import {loadRestResources} from '../rest/load-rest-resources';\nimport {ShopifyRestResources} from '../rest/types';\nimport {abstractRuntimeString} from '../runtime/platform';\nimport {FutureFlagOptions, logDisabledFutureFlags} from '../future/flags';\n\nimport {ConfigParams, ConfigInterface} from './base-types';\nimport {validateConfig} from './config';\nimport {clientClasses, ShopifyClients} from './clients';\nimport {shopifyAuth, ShopifyAuth} from './auth';\nimport {shopifySession, ShopifySession} from './session';\nimport {shopifyUtils, ShopifyUtils} from './utils';\nimport {shopifyWebhooks, ShopifyWebhooks} from './webhooks';\nimport {shopifyBilling, ShopifyBilling} from './billing';\nimport {logger, ShopifyLogger} from './logger';\nimport {SHOPIFY_API_LIBRARY_VERSION} from './version';\nimport {restClientClass} from './clients/admin/rest/client';\nimport {ShopifyFlow, shopifyFlow} from './flow';\nimport {FulfillmentService, fulfillmentService} from './fulfillment-service';\n\nexport * from './error';\nexport * from './session/classes';\n\nexport * from '../rest/types';\nexport * from './types';\nexport * from './base-types';\nexport * from './auth/types';\nexport * from './billing/types';\nexport * from './clients/types';\nexport * from './session/types';\nexport * from './webhooks/types';\nexport * from './utils/types';\n\nexport interface Shopify<\n  Params extends ConfigParams = ConfigParams,\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n  Future extends FutureFlagOptions = FutureFlagOptions,\n> {\n  config: ConfigInterface<Params>;\n  clients: ShopifyClients;\n  auth: ShopifyAuth;\n  session: ShopifySession;\n  utils: ShopifyUtils;\n\n  /**\n   * Functions for working with webhooks.\n   *\n   * Most of these functions are used for interacting with shop-specific webhooks.\n   * Unless your app needs different webhooks for different shops, we recommend using app-specific webhooks instead:\n   *\n   * {@link https://shopify.dev/docs/apps/build/webhooks/subscribe#app-specific-subscriptions}\n   *\n   * If you use only app-specific webhooks, the only function you will need is `shopify.webhooks.validate`.\n   */\n  webhooks: ShopifyWebhooks;\n  billing: ShopifyBilling<Future>;\n  logger: ShopifyLogger;\n  rest: Resources;\n  flow: ShopifyFlow;\n  fulfillmentService: FulfillmentService;\n}\n\nexport function shopifyApi<\n  Params extends ConfigParams<Resources, Future>,\n  Resources extends ShopifyRestResources,\n  Future extends FutureFlagOptions,\n>({\n  future,\n  restResources,\n  ...config\n}: {future?: Future; restResources?: Resources} & Params): Shopify<\n  Params,\n  Resources,\n  Future\n> {\n  const libConfig = {...config, future, restResources};\n  const validatedConfig = validateConfig(libConfig);\n\n  const shopify = {\n    config: validatedConfig,\n    clients: clientClasses(validatedConfig),\n    auth: shopifyAuth(validatedConfig),\n    session: shopifySession(validatedConfig),\n    utils: shopifyUtils(validatedConfig),\n    webhooks: shopifyWebhooks(validatedConfig),\n    billing: shopifyBilling(validatedConfig),\n    flow: shopifyFlow(validatedConfig),\n    fulfillmentService: fulfillmentService(validatedConfig),\n    logger: logger(validatedConfig),\n    rest: {} as Resources,\n  };\n\n  if (restResources) {\n    shopify.rest = loadRestResources({\n      resources: restResources,\n      config: validatedConfig,\n      RestClient: restClientClass({config: validatedConfig}),\n    });\n  }\n\n  shopify.logger\n    .info(\n      `version ${SHOPIFY_API_LIBRARY_VERSION}, environment ${abstractRuntimeString()}`,\n    )\n    .catch((err) => console.log(err));\n\n  logDisabledFutureFlags(validatedConfig, shopify.logger);\n\n  return shopify as Shopify<Params, Resources, Future>;\n}\n", "import {HeadersArgs} from '@remix-run/server-runtime';\n\nexport function headersBoundary(headers: HeadersArgs): Headers {\n  const {parentHeaders, loaderHeaders, actionHeaders, errorHeaders} = headers;\n\n  if (errorHeaders && Array.from(errorHeaders.entries()).length > 0) {\n    return errorHeaders;\n  }\n\n  return new Headers([\n    ...(parentHeaders ? Array.from(parentHeaders.entries()) : []),\n    ...(loaderHeaders ? Array.from(loaderHeaders.entries()) : []),\n    ...(actionHeaders ? Array.from(actionHeaders.entries()) : []),\n  ]);\n}\n", "export function errorBoundary(error: any) {\n  if (\n    error.constructor.name === 'ErrorResponse' ||\n    error.constructor.name === 'ErrorResponseImpl'\n  ) {\n    return (\n      <div\n        dangerouslySetInnerHTML={{__html: error.data || 'Handling response'}}\n      />\n    );\n  }\n\n  throw error;\n}\n", "import {headersBoundary} from './headers';\nimport {errorBoundary} from './error';\n\n/**\n * A collection of functions that handle the necessary code for error boundaries in routes using authenticate.admin.\n */\nexport const boundary = {\n  /**\n   * A function that handles errors or thrown responses.\n   *\n   * @example\n   * <caption>Catching errors in a route</caption>\n   * ```ts\n   * // /app/routes/admin/widgets.ts\n   * import { boundary } from \"@shopify/shopify-app-remix/server\";\n   *\n   * export function ErrorBoundary() {\n   *   return boundary.error(useRouteError());\n   * }\n   * ```\n   */\n  error: errorBoundary,\n\n  /**\n   * A function that sets the appropriate document response headers.\n   *\n   * @example\n   * <caption>Catching errors in a route</caption>\n   * ```ts\n   * // /app/routes/admin/widgets.ts\n   * import { boundary } from \"@shopify/shopify-app-remix/server\";\n   *\n   * export const headers = (headersArgs) => {\n   *   return boundary.headers(headersArgs);\n   * };\n   * ```\n   */\n  headers: headersBoundary,\n};\n", "export const SHOPIFY_REMIX_LIBRARY_VERSION = '4.0.1';\n", "import type {BasicParams} from '../../types';\n\nimport type {RegisterWebhooksOptions} from './types';\n\nexport function registerWebhooksFactory({api, logger}: BasicParams) {\n  return async function registerWebhooks({session}: RegisterWebhooksOptions) {\n    return api.webhooks\n      .register({session})\n      .then((response) => {\n        Object.entries(response).forEach(([topic, topicResults]) => {\n          topicResults.forEach(({success, ...rest}) => {\n            if (success) {\n              logger.debug('Registered webhook', {\n                topic,\n                shop: session.shop,\n                operation: rest.operation,\n              });\n            } else {\n              logger.error('Failed to register webhook', {\n                topic,\n                shop: session.shop,\n                result: JSON.stringify(rest.result),\n              });\n            }\n          });\n        });\n\n        return response;\n      })\n      .catch((error) => {\n        const graphQLErrors: {extensions: {code?: string}}[] =\n          error.body?.errors?.graphQLErrors || [];\n\n        const throttled = graphQLErrors.find(\n          ({extensions: {code}}) => code === 'THROTTLED',\n        );\n\n        if (throttled) {\n          logger.error('Failed to register webhooks', {\n            shop: session.shop,\n            error: JSON.stringify(error),\n          });\n        } else {\n          throw error;\n        }\n      });\n  };\n}\n", "import {BasicParams} from '../../types';\nimport {REAUTH_URL_HEADER} from '../const';\n\nexport interface EnsureCORSFunction {\n  (response: Response): Response;\n}\n\nexport function ensureCORSHeadersFactory(\n  params: BasicParams,\n  request: Request,\n  corsHeaders: string[] = [],\n): EnsureCORSFunction {\n  const {logger, config} = params;\n\n  return function ensureCORSHeaders(response) {\n    const origin = request.headers.get('Origin');\n    if (origin && origin !== config.appUrl) {\n      logger.debug(\n        'Request comes from a different origin, adding CORS headers',\n      );\n\n      const corsHeadersSet = new Set([\n        'Authorization',\n        'Content-Type',\n        ...corsHeaders,\n      ]);\n\n      response.headers.set('Access-Control-Allow-Origin', '*');\n      response.headers.set(\n        'Access-Control-Allow-Headers',\n        [...corsHeadersSet].join(', '),\n      );\n      response.headers.set('Access-Control-Expose-Headers', REAUTH_URL_HEADER);\n    }\n\n    return response;\n  };\n}\n", "import {redirect} from '@remix-run/server-runtime';\n\nimport {BasicParams} from '../../../types';\n\nexport const redirectToBouncePage = (params: BasicParams, url: URL): never => {\n  const {config} = params;\n\n  // Make sure we always point to the configured app URL so it also works behind reverse proxies (that alter the Host\n  // header).\n  const searchParams = url.searchParams;\n  searchParams.delete('id_token');\n  searchParams.set(\n    'shopify-reload',\n    `${config.appUrl}${url.pathname}?${searchParams.toString()}`,\n  );\n\n  // eslint-disable-next-line no-warning-comments\n  // TODO Make sure this works on chrome without a tunnel (weird HTTPS redirect issue)\n  // https://github.com/orgs/Shopify/projects/6899/views/1?pane=issue&itemId=28376650\n  throw redirect(\n    `${config.auth.patchSessionTokenPath}?${searchParams.toString()}`,\n  );\n};\n", "import {redirectToBouncePage} from '../admin/helpers/redirect-to-bounce-page';\nimport {RETRY_INVALID_SESSION_HEADER} from '../const';\nimport {BasicParams} from '../../types';\n\ninterface RespondToInvalidSessionTokenParams {\n  params: BasicParams;\n  request: Request;\n  retryRequest?: boolean;\n}\n\nexport function respondToInvalidSessionToken({\n  params,\n  request,\n  retryRequest = false,\n}: RespondToInvalidSessionTokenParams) {\n  const {api, logger, config} = params;\n\n  const isDocumentRequest = !request.headers.get('authorization');\n  if (isDocumentRequest) {\n    return redirectToBouncePage({api, logger, config}, new URL(request.url));\n  }\n\n  throw new Response(undefined, {\n    status: 401,\n    statusText: 'Unauthorized',\n    headers: retryRequest ? RETRY_INVALID_SESSION_HEADER : {},\n  });\n}\n", "export function getShopFromRequest(request: Request) {\n  const url = new URL(request.url);\n  return url.searchParams.get('shop')!;\n}\n", "import {JwtPayload} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../types';\n\nimport {respondToInvalidSessionToken} from './respond-to-invalid-session-token';\nimport {getShopFromRequest} from './get-shop-from-request';\n\ninterface ValidateSessionTokenOptions {\n  checkAudience?: boolean;\n  retryRequest?: boolean;\n}\n\nexport async function validateSessionToken(\n  params: BasicParams,\n  request: Request,\n  token: string,\n  {checkAudience = true, retryRequest = true}: ValidateSessionTokenOptions = {},\n): Promise<JwtPayload> {\n  const {api, logger} = params;\n  const shop = getShopFromRequest(request);\n  logger.debug('Validating session token', {shop});\n\n  try {\n    const payload = await api.session.decodeSessionToken(token, {\n      checkAudience,\n    });\n    logger.debug('Session token is valid - validated', {\n      shop,\n      payload: JSON.stringify(payload),\n    });\n\n    return payload;\n  } catch (error) {\n    logger.debug(`Failed to validate session token: ${error.message}`, {\n      shop,\n    });\n\n    throw respondToInvalidSessionToken({params, request, retryRequest});\n  }\n}\n", "const SESSION_TOKEN_PARAM = 'id_token';\n\nexport function getSessionTokenHeader(request: Request): string | undefined {\n  return request.headers.get('authorization')?.replace('Bearer ', '');\n}\n\nexport function getSessionTokenFromUrlParam(request: Request): string | null {\n  const url = new URL(request.url);\n\n  return url.searchParams.get(SESSION_TOKEN_PARAM);\n}\n", "import {isbot} from 'isbot';\n\nimport type {BasicParams} from '../../types';\n\nconst SHOPIFY_POS_USER_AGENT = /Shopify POS\\//;\nconst SHOPIFY_MOBILE_USER_AGENT = /Shopify Mobile\\//;\n\nconst SHOPIFY_USER_AGENTS = [SHOPIFY_POS_USER_AGENT, SHOPIFY_MOBILE_USER_AGENT];\n\nexport function respondToBotRequest(\n  {logger}: BasicParams,\n  request: Request,\n): void | never {\n  const userAgent = request.headers.get('User-Agent') ?? '';\n\n  // We call isbot below to prevent good (self-identifying) bots from triggering auth requests, but there are some\n  // Shopify-specific cases we want to allow that are identified as bots by isbot.\n  if (SHOPIFY_USER_AGENTS.some((agent) => agent.test(userAgent))) {\n    logger.debug('Request is from a Shopify agent, allow');\n    return;\n  }\n\n  if (isbot(userAgent)) {\n    logger.debug('Request is from a bot, skipping auth');\n    throw new Response(undefined, {status: 410, statusText: 'Gone'});\n  }\n}\n", "import {BasicParams} from '../../types';\n\nimport {ensureCORSHeadersFactory} from './ensure-cors-headers';\n\nexport function respondToOptionsRequest(\n  params: BasicParams,\n  request: Request,\n  corsHeaders?: string[],\n) {\n  if (request.method === 'OPTIONS') {\n    const ensureCORSHeaders = ensureCORSHeadersFactory(\n      params,\n      request,\n      corsHeaders,\n    );\n\n    throw ensureCORSHeaders(\n      new Response(null, {\n        status: 204,\n        headers: {\n          'Access-Control-Max-Age': '7200',\n        },\n      }),\n    );\n  }\n}\n", "import type {BasicParams} from '../../../types';\n\nexport async function beginAuth(\n  params: BasicParams,\n  request: Request,\n  isOnline: boolean,\n  shop: string,\n): Promise<never> {\n  const {api, config} = params;\n\n  throw await api.auth.begin({\n    shop,\n    callbackPath: config.auth.callbackPath,\n    isOnline,\n    rawRequest: request,\n  });\n}\n", "import {redirect} from '@remix-run/server-runtime';\n\nimport type {BasicParams} from '../../../types';\n\nexport function redirectWithExitIframe(\n  params: BasicParams,\n  request: Request,\n  shop: string,\n): never {\n  const {api, config} = params;\n  const url = new URL(request.url);\n\n  const queryParams = url.searchParams;\n\n  const host = api.utils.sanitizeHost(queryParams.get('host')!);\n\n  queryParams.set('shop', shop);\n\n  let destination = `${config.auth.path}?shop=${shop}`;\n\n  if (host) {\n    queryParams.set('host', host);\n    destination = `${destination}&host=${host}`;\n  }\n  queryParams.set('exitIframe', destination);\n\n  throw redirect(`${config.auth.exitIframePath}?${queryParams.toString()}`);\n}\n", "import {REAUTH_URL_HEADER} from '../../const';\n\nexport function redirectWithAppBridgeHeaders(redirectUri: string): never {\n  throw new Response(undefined, {\n    status: 401,\n    statusText: 'Unauthorized',\n    headers: getAppBridgeHeaders(redirectUri),\n  });\n}\n\nexport function getAppBridgeHeaders(url: string) {\n  return new Headers({[REAUTH_URL_HEADER]: url});\n}\n", "import type {BasicParams} from '../../../types';\n\nimport {beginAuth} from './begin-auth';\nimport {redirectWithExitIframe} from './redirect-with-exitiframe';\nimport {redirectWithAppBridgeHeaders} from './redirect-with-app-bridge-headers';\n\nexport async function redirectToAuthPage(\n  params: BasicParams,\n  request: Request,\n  shop: string,\n  isOnline = false,\n): Promise<never> {\n  const {config} = params;\n\n  const url = new URL(request.url);\n  const isEmbeddedRequest = url.searchParams.get('embedded') === '1';\n  const isXhrRequest = request.headers.get('authorization');\n\n  if (isXhrRequest) {\n    const redirectUri = new URL(config.auth.path, config.appUrl);\n    redirectUri.searchParams.set('shop', shop);\n    redirectWithAppBridgeHeaders(redirectUri.toString());\n  } else if (isEmbeddedRequest) {\n    redirectWithExitIframe(params, request, shop);\n  } else {\n    throw await beginAuth(params, request, isOnline, shop);\n  }\n}\n", "import {Session} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../types';\n\nexport async function invalidateAccessToken(\n  params: BasicParams,\n  session: Session,\n): Promise<void> {\n  const {logger, config} = params;\n\n  logger.debug(`Invalidating access token for session - ${session.id}`, {\n    shop: session.shop,\n  });\n\n  session.accessToken = undefined;\n  await config.sessionStorage!.storeSession(session);\n}\n", "import {HttpResponseError, Session} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../../types';\nimport {redirectToAuthPage} from '../helpers';\nimport {invalidateAccessToken} from '../../helpers';\n\nimport type {CancelBillingOptions} from './types';\n\nexport function cancelBillingFactory(\n  params: BasicParams,\n  request: Request,\n  session: Session,\n) {\n  return async function cancelBilling(options: CancelBillingOptions) {\n    const {api, logger} = params;\n\n    logger.debug('Cancelling billing', {shop: session.shop, ...options});\n\n    try {\n      return await api.billing.cancel({\n        session,\n        subscriptionId: options.subscriptionId,\n        isTest: options.isTest,\n        prorate: options.prorate,\n      });\n    } catch (error) {\n      if (error instanceof HttpResponseError && error.response.code === 401) {\n        logger.debug('API token was invalid, redirecting to OAuth', {\n          shop: session.shop,\n        });\n        await invalidateAccessToken(params, session);\n        throw await redirectToAuthPage(params, request, session.shop);\n      } else {\n        throw error;\n      }\n    }\n  };\n}\n", "import {\n  BillingCheckResponseObject,\n  HttpResponseError,\n  Session,\n} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../../types';\nimport type {AppConfigArg} from '../../../config-types';\nimport {redirectToAuthPage} from '../helpers';\nimport {invalidateAccessToken} from '../../helpers';\n\nimport type {RequireBillingOptions} from './types';\n\nexport function requireBillingFactory<Config extends AppConfigArg>(\n  params: BasicParams,\n  request: Request,\n  session: Session,\n) {\n  const {api, logger} = params;\n\n  return async function requireBilling(options: RequireBillingOptions<Config>) {\n    const logContext = {\n      shop: session.shop,\n      plans: options.plans,\n      isTest: options.isTest,\n    };\n\n    logger.debug('Checking billing for the shop', logContext);\n\n    let data: BillingCheckResponseObject;\n    try {\n      data = await api.billing.check({\n        session,\n        plans: options.plans as string[],\n        isTest: options.isTest,\n        returnObject: true,\n      });\n    } catch (error) {\n      if (error instanceof HttpResponseError && error.response.code === 401) {\n        logger.debug('API token was invalid, redirecting to OAuth', logContext);\n\n        await invalidateAccessToken(params, session);\n        throw await redirectToAuthPage(params, request, session.shop);\n      } else {\n        throw error;\n      }\n    }\n\n    if (!data.hasActivePayment) {\n      logger.debug('Billing check failed', logContext);\n      throw await options.onFailure(new Error('Billing check failed'));\n    }\n\n    logger.debug('Billing check succeeded', logContext);\n\n    return data;\n  };\n}\n", "import {redirect} from '@remix-run/server-runtime';\n\nimport {BasicParams} from '../../../types';\nimport {getAppBridgeHeaders} from '../helpers';\n\nexport function redirectOutOfApp(\n  params: BasicParams,\n  request: Request,\n  url: string,\n  shop: string,\n): never {\n  const {config, logger} = params;\n\n  logger.debug('Redirecting out of app', {shop, url});\n\n  const requestUrl = new URL(request.url);\n  const isEmbeddedRequest = requestUrl.searchParams.get('embedded') === '1';\n  const isXhrRequest = request.headers.get('authorization');\n\n  if (isXhrRequest) {\n    // eslint-disable-next-line no-warning-comments\n    // TODO Check this with the beta flag disabled (with the bounce page)\n    // Remix is not including the X-Shopify-API-Request-Failure-Reauthorize-Url when throwing a Response\n    // https://github.com/remix-run/remix/issues/5356\n    throw new Response(undefined, {\n      status: 401,\n      statusText: 'Unauthorized',\n      headers: getAppBridgeHeaders(url),\n    });\n  } else if (isEmbeddedRequest) {\n    const params = new URLSearchParams({\n      shop,\n      host: requestUrl.searchParams.get('host')!,\n      exitIframe: url,\n    });\n\n    throw redirect(`${config.auth.exitIframePath}?${params.toString()}`);\n  } else {\n    // This will only ever happen for non-embedded apps, because the authenticator will stop before reaching this point\n    throw redirect(url);\n  }\n}\n", "import {\n  BillingRequestResponseObject,\n  HttpResponseError,\n  Session,\n} from '@shopify/shopify-api';\n\nimport {AppConfigArg} from '../../../config-types';\nimport {BasicParams} from '../../../types';\nimport {redirectToAuthPage} from '../helpers';\nimport {invalidateAccessToken} from '../../helpers';\n\nimport {redirectOutOfApp} from './helpers';\nimport type {RequestBillingOptions} from './types';\n\nexport function requestBillingFactory<Config extends AppConfigArg>(\n  params: BasicParams,\n  request: Request,\n  session: Session,\n) {\n  return async function requestBilling({\n    plan,\n    isTest,\n    returnUrl,\n    ...overrides\n  }: RequestBillingOptions<Config>): Promise<never> {\n    const {api, logger} = params;\n\n    logger.info('Requesting billing', {\n      shop: session.shop,\n      plan,\n      isTest,\n      returnUrl,\n    });\n\n    let result: BillingRequestResponseObject;\n    try {\n      result = await api.billing.request({\n        plan: plan as string,\n        session,\n        isTest,\n        returnUrl,\n        returnObject: true,\n        ...overrides,\n      });\n    } catch (error) {\n      if (error instanceof HttpResponseError && error.response.code === 401) {\n        logger.debug('API token was invalid, redirecting to OAuth', {\n          shop: session.shop,\n        });\n        await invalidateAccessToken(params, session);\n        throw await redirectToAuthPage(params, request, session.shop);\n      } else {\n        throw error;\n      }\n    }\n\n    throw redirectOutOfApp(\n      params,\n      request,\n      result.confirmationUrl,\n      session.shop,\n    );\n  };\n}\n", "import {HttpResponseError, Session} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../../types';\nimport {redirectToAuthPage} from '../helpers';\nimport type {AppConfigArg} from '../../../config-types';\nimport {invalidateAccessToken} from '../../helpers';\n\nimport type {CheckBillingOptions} from './types';\n\nexport function checkBillingFactory<Config extends AppConfigArg>(\n  params: BasicParams,\n  request: Request,\n  session: Session,\n) {\n  return async function checkBilling(\n    options: CheckBillingOptions<Config> = {},\n  ) {\n    const {api, logger} = params;\n\n    logger.debug('Checking billing plans', {shop: session.shop, ...options});\n\n    try {\n      return await api.billing.check({\n        session,\n        plans: options.plans as string[],\n        isTest: options.isTest,\n        returnObject: true,\n      });\n    } catch (error) {\n      if (error instanceof HttpResponseError && error.response.code === 401) {\n        logger.debug('API token was invalid, redirecting to OAuth', {\n          shop: session.shop,\n        });\n        await invalidateAccessToken(params, session);\n        throw await redirectToAuthPage(params, request, session.shop);\n      } else {\n        throw error;\n      }\n    }\n  };\n}\n", "import {HttpResponseError, Session} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../../types';\nimport {redirectToAuthPage} from '../helpers';\nimport {invalidateAccessToken} from '../../helpers';\n\nimport type {CreateUsageRecordOptions} from './types';\n\nexport function createUsageRecordFactory(\n  params: BasicParams,\n  request: Request,\n  session: Session,\n) {\n  return async function createUsageRecord(options: CreateUsageRecordOptions) {\n    const {api, logger} = params;\n\n    logger.debug('Create usage record', {shop: session.shop, ...options});\n\n    try {\n      return await api.billing.createUsageRecord({\n        ...options,\n        session,\n      });\n    } catch (error) {\n      if (error instanceof HttpResponseError && error.response.code === 401) {\n        logger.debug('API token was invalid, redirecting to OAuth', {\n          shop: session.shop,\n        });\n        await invalidateAccessToken(params, session);\n        throw await redirectToAuthPage(params, request, session.shop);\n      } else {\n        throw error;\n      }\n    }\n  };\n}\n", "import {\n  HttpResponseError,\n  Session,\n  UpdateCappedAmountConfirmation,\n} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../../types';\nimport {redirectToAuthPage} from '../helpers';\nimport {invalidateAccessToken} from '../../helpers';\n\nimport {UpdateUsageCappedAmountOptions} from './types';\nimport {redirectOutOfApp} from './helpers';\n\nexport function updateUsageCappedAmountFactory(\n  params: BasicParams,\n  request: Request,\n  session: Session,\n) {\n  return async function updateUsageCappedAmount(\n    options: UpdateUsageCappedAmountOptions,\n  ): Promise<never> {\n    const {api, logger} = params;\n\n    logger.debug('Updating usage subscription capped amount', {\n      shop: session.shop,\n      ...options,\n    });\n\n    let result: UpdateCappedAmountConfirmation;\n    try {\n      result = await api.billing.updateUsageCappedAmount({\n        session,\n        subscriptionLineItemId: options.subscriptionLineItemId,\n        cappedAmount: options.cappedAmount,\n      });\n    } catch (error) {\n      if (error instanceof HttpResponseError && error.response.code === 401) {\n        logger.debug('API token was invalid, redirecting to OAuth', {\n          shop: session.shop,\n        });\n        await invalidateAccessToken(params, session);\n        throw await redirectToAuthPage(params, request, session.shop);\n      } else {\n        throw error;\n      }\n    }\n\n    throw redirectOutOfApp(\n      params,\n      request,\n      result.confirmationUrl,\n      session.shop,\n    );\n  };\n}\n", "import {AdminOperations} from '@shopify/admin-api-client';\n\nimport {GraphQLClient} from '../types';\n\nimport {AdminClientOptions} from './types';\n\n// eslint-disable-next-line no-warning-comments\n// TODO: This is actually just a call through to the Shopify API client, but with a different API. We should eventually\n// move this over to the library layer.\nexport function graphqlClientFactory({\n  params,\n  handleClientError,\n  session,\n}: AdminClientOptions): GraphQLClient<AdminOperations> {\n  return async function query(operation, options) {\n    const client = new params.api.clients.Graphql({\n      session,\n      apiVersion: options?.apiVersion,\n    });\n\n    try {\n      // We convert the incoming response to a Response object to bring this client closer to the Remix client.\n      const apiResponse = await client.request(operation, {\n        variables: options?.variables,\n        retries: options?.tries ? options.tries - 1 : 0,\n        headers: options?.headers,\n        signal: options?.signal,\n      });\n\n      return new Response(JSON.stringify(apiResponse));\n    } catch (error) {\n      if (handleClientError) {\n        throw await handleClientError({error, params, session});\n      }\n\n      throw error;\n    }\n  };\n}\n", "import {Session} from '@shopify/shopify-api';\n\nimport {BasicParams} from '../../types';\n\nimport {graphqlClientFactory} from './graphql';\nimport type {AdminApiContext} from './types';\n\ninterface AdminClientOptions {\n  params: BasicParams;\n  session: Session;\n  handleClientError?: (error: any) => Promise<void>;\n}\n\nexport function adminClientFactory({\n  params,\n  handleClientError,\n  session,\n}: AdminClientOptions): AdminApiContext {\n  return {\n    graphql: graphqlClientFactory({params, session, handleClientError}),\n  };\n}\n", "import {Session} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../../types';\nimport {\n  AdminApiContext,\n  HandleAdminClientError,\n  adminClientFactory,\n} from '../../../clients/admin';\n\nexport function createAdminApiContext(\n  session: Session,\n  params: BasicParams,\n  handleClientError: HandleAdminClientError,\n): AdminApiContext {\n  return adminClientFactory({\n    session,\n    params,\n    handleClientError,\n  });\n}\n", "import {redirect} from '@remix-run/server-runtime';\n\nimport type {BasicParams} from '../../../types';\n\nexport async function redirectToShopifyOrAppRoot(\n  request: Request,\n  params: BasicParams,\n  responseHeaders?: Headers,\n): Promise<never> {\n  const {api} = params;\n  const url = new URL(request.url);\n\n  const host = api.utils.sanitizeHost(url.searchParams.get('host')!)!;\n  const shop = api.utils.sanitizeShop(url.searchParams.get('shop')!)!;\n\n  const redirectUrl = api.config.isEmbeddedApp\n    ? await api.auth.getEmbeddedAppUrl({rawRequest: request})\n    : `/?shop=${shop}&host=${encodeURIComponent(host)}`;\n\n  throw redirect(redirectUrl, {headers: responseHeaders});\n}\n", "import {BasicParams} from '../../../types';\n\nimport {redirectToShopifyOrAppRoot} from './redirect-to-shopify-or-app-root';\n\nexport const ensureAppIsEmbeddedIfRequired = async (\n  params: BasicParams,\n  request: Request,\n) => {\n  const {api, logger, config} = params;\n  const url = new URL(request.url);\n\n  const shop = url.searchParams.get('shop')!;\n\n  if (api.config.isEmbeddedApp && url.searchParams.get('embedded') !== '1') {\n    logger.debug('App is not embedded, redirecting to Shopify', {shop});\n    await redirectToShopifyOrAppRoot(request, {api, logger, config});\n  }\n};\n", "import {BasicParams} from '../../../types';\n\nimport {redirectToBouncePage} from './redirect-to-bounce-page';\n\nconst SESSION_TOKEN_PARAM = 'id_token';\n\nexport const ensureSessionTokenSearchParamIfRequired = async (\n  params: BasicParams,\n  request: Request,\n) => {\n  const {api, logger} = params;\n  const url = new URL(request.url);\n\n  const shop = url.searchParams.get('shop')!;\n  const searchParamSessionToken = url.searchParams.get(SESSION_TOKEN_PARAM);\n  const isEmbedded = url.searchParams.get('embedded') === '1';\n\n  if (api.config.isEmbeddedApp && isEmbedded && !searchParamSessionToken) {\n    logger.debug(\n      'Missing session token in search params, going to bounce page',\n      {shop},\n    );\n    redirectToBouncePage(params, url);\n  }\n};\n", "import type {BasicParams} from '../../types';\n\nexport type AddDocumentResponseHeadersFunction = (\n  request: Request,\n  headers: Headers,\n) => void;\n\nexport function addDocumentResponseHeadersFactory(\n  params: BasicParams,\n): AddDocumentResponseHeadersFunction {\n  const {api, config} = params;\n\n  return function (request: Request, headers: Headers) {\n    const {searchParams} = new URL(request.url);\n    const shop = api.utils.sanitizeShop(searchParams.get('shop')!);\n\n    addDocumentResponseHeaders(headers, config.isEmbeddedApp, shop);\n  };\n}\n\nexport function addDocumentResponseHeaders(\n  headers: Headers,\n  isEmbeddedApp: boolean,\n  shop: string | null | undefined,\n) {\n  if (shop) {\n    headers.set(\n      'Link',\n      '<https://cdn.shopify.com/shopifycloud/app-bridge.js>; rel=\"preload\"; as=\"script\";',\n    );\n  }\n\n  if (isEmbeddedApp) {\n    if (shop) {\n      headers.set(\n        'Content-Security-Policy',\n        `frame-ancestors https://${shop} https://admin.shopify.com https://*.spin.dev https://admin.myshopify.io https://admin.shop.dev;`,\n      );\n    }\n  } else {\n    headers.set('Content-Security-Policy', `frame-ancestors 'none';`);\n  }\n}\n", "import {ShopifyError} from '@shopify/shopify-api';\n\ninterface Options {\n  requireSSL?: boolean;\n  throwOnInvalid?: boolean;\n}\n\ntype SanitizedRedirectUrl<OptionsArg extends Options> =\n  OptionsArg['throwOnInvalid'] extends false ? URL | undefined : URL;\n\nconst FILE_URI_MATCH = /\\/\\/\\//;\nconst INVALID_RELATIVE_URL = /[/\\\\][/\\\\]/;\nconst WHITESPACE_CHARACTER = /\\s/;\nconst VALID_PROTOCOLS = ['https:', 'http:'];\n\nfunction isSafe(\n  domain: string,\n  redirectUrl: unknown,\n  requireSSL: boolean | undefined = true,\n): redirectUrl is string {\n  if (typeof redirectUrl !== 'string') {\n    return false;\n  }\n\n  if (\n    FILE_URI_MATCH.test(redirectUrl) ||\n    WHITESPACE_CHARACTER.test(redirectUrl)\n  ) {\n    return false;\n  }\n\n  let url: URL;\n\n  try {\n    url = new URL(redirectUrl, domain);\n  } catch (error) {\n    return false;\n  }\n\n  if (INVALID_RELATIVE_URL.test(url.pathname)) {\n    return false;\n  }\n\n  if (!VALID_PROTOCOLS.includes(url.protocol)) {\n    return false;\n  }\n\n  if (requireSSL && url.protocol !== 'https:') {\n    return false;\n  }\n\n  return true;\n}\n\nexport function sanitizeRedirectUrl<OptionsArg extends Options>(\n  domain: string,\n  redirectUrl: unknown,\n  options: OptionsArg = {} as OptionsArg,\n): SanitizedRedirectUrl<OptionsArg> {\n  if (isSafe(domain, redirectUrl, options.requireSSL)) {\n    return new URL(redirectUrl, domain) as SanitizedRedirectUrl<OptionsArg>;\n  } else if (options.throwOnInvalid === false) {\n    return undefined as SanitizedRedirectUrl<OptionsArg>;\n  } else {\n    throw new ShopifyError('Invalid URL. Refusing to redirect');\n  }\n}\n", "import {BasicParams} from '../../../types';\nimport {appBridgeUrl} from '../../helpers/app-bridge-url';\nimport {addDocumentResponseHeaders} from '../../helpers/add-response-headers';\n\nimport {sanitizeRedirectUrl} from './validate-redirect-url';\n\nimport type {RedirectTarget} from '.';\n\nexport interface RedirectToOptions {\n  url: string | URL;\n  target?: RedirectTarget;\n}\n\nexport function renderAppBridge(\n  {config}: BasicParams,\n  request: Request,\n  redirectTo?: RedirectToOptions,\n): never {\n  let redirectToScript = '';\n  if (redirectTo) {\n    const destination = sanitizeRedirectUrl(config.appUrl, redirectTo.url);\n\n    const target = redirectTo.target ?? '_top';\n\n    redirectToScript = `<script>window.open(${JSON.stringify(\n      destination.toString(),\n    )}, ${JSON.stringify(target)})</script>`;\n  }\n\n  const responseHeaders = new Headers({\n    'content-type': 'text/html;charset=utf-8',\n  });\n  addDocumentResponseHeaders(\n    responseHeaders,\n    config.isEmbeddedApp,\n    new URL(request.url).searchParams.get('shop'),\n  );\n\n  throw new Response(\n    `\n      <script data-api-key=\"${config.apiKey}\" src=\"${appBridgeUrl()}\"></script>\n      ${redirectToScript}\n    `,\n    {headers: responseHeaders},\n  );\n}\n", "import {\n  TypedResponse,\n  redirect as remixRedirect,\n} from '@remix-run/server-runtime';\n\nimport {BasicParams} from '../../../types';\nimport {getSessionTokenHeader} from '../../helpers/get-session-token-header';\n\nimport {renderAppBridge} from './render-app-bridge';\nimport {redirectWithAppBridgeHeaders} from './redirect-with-app-bridge-headers';\n\nexport type RedirectTarget = '_self' | '_parent' | '_top' | '_blank';\nexport type RedirectInit = number | (ResponseInit & {target?: RedirectTarget});\nexport type RedirectFunction = (\n  url: string,\n  init?: RedirectInit,\n) => TypedResponse<never>;\n\ninterface ParseURLOptions {\n  params: BasicParams;\n  url: string;\n  base: string;\n  shop: string;\n  init: RedirectInit;\n}\n\ninterface ParsedURL {\n  url: URL;\n  target: RedirectTarget;\n}\n\nexport function redirectFactory(\n  params: BasicParams,\n  request: Request,\n  shop: string,\n): RedirectFunction {\n  const {config, logger} = params;\n\n  return function redirect(url, init: RedirectInit) {\n    const {searchParams} = new URL(request.url);\n    const {url: parsedUrl, target} = parseURL({\n      params,\n      url,\n      base: config.appUrl,\n      shop,\n      init,\n    });\n\n    logger.debug('Redirecting', {shop, url: parsedUrl.toString()});\n\n    const isSameOrigin = parsedUrl.origin === config.appUrl;\n    if (isSameOrigin || url.startsWith('/')) {\n      searchParams.forEach((value, key) => {\n        if (!parsedUrl.searchParams.has(key)) {\n          parsedUrl.searchParams.set(key, value);\n        }\n      });\n    }\n\n    if (target === '_self') {\n      if (isBounceRequest(request)) {\n        throw renderAppBridge(params, request, {\n          url: parsedUrl.toString(),\n          target,\n        });\n      } else {\n        return remixRedirect(parsedUrl.toString(), init);\n      }\n    } else if (isDataRequest(request)) {\n      throw redirectWithAppBridgeHeaders(parsedUrl.toString());\n    } else if (isEmbeddedRequest(request)) {\n      throw renderAppBridge(params, request, {\n        url: parsedUrl.toString(),\n        target,\n      });\n    }\n    return remixRedirect(url, init);\n  };\n}\n\nfunction isBounceRequest(request: Request) {\n  return (\n    Boolean(getSessionTokenHeader(request)) &&\n    request.headers.has('X-Shopify-Bounce')\n  );\n}\n\nfunction isDataRequest(request: Request) {\n  const isGet = request.method === 'GET';\n  const sessionTokenHeader = Boolean(getSessionTokenHeader(request));\n\n  return (\n    sessionTokenHeader &&\n    !isBounceRequest(request) &&\n    (!isEmbeddedRequest(request) || !isGet)\n  );\n}\n\nfunction isEmbeddedRequest(request: Request) {\n  const {searchParams} = new URL(request.url);\n\n  return searchParams.get('embedded') === '1';\n}\n\nfunction parseURL({params, base, init, shop, url}: ParseURLOptions): ParsedURL {\n  let target: RedirectTarget | undefined =\n    typeof init !== 'number' && init?.target ? init.target : undefined;\n\n  if (isAdminRemotePath(url)) {\n    const {config} = params;\n\n    const adminPath = getAdminRemotePath(url);\n    const cleanShopName = shop.replace('.myshopify.com', '');\n\n    if (!target) {\n      target = config.isEmbeddedApp ? '_parent' : '_self';\n    }\n\n    return {\n      url: new URL(\n        `https://admin.shopify.com/store/${cleanShopName}${adminPath}`,\n      ),\n      target,\n    };\n  } else {\n    return {\n      url: new URL(url, base),\n      target: target ?? '_self',\n    };\n  }\n}\n\nconst ADMIN_REGEX = /^shopify:\\/*admin\\//i;\n\nfunction isAdminRemotePath(url: string) {\n  return ADMIN_REGEX.test(url);\n}\n\nfunction getAdminRemotePath(url: string | URL) {\n  const parsedUrl = removeRestrictedParams(new URL(url)).href;\n  return parsedUrl.replace(ADMIN_REGEX, '/');\n}\n\nconst embeddedFrameParamsToRemove = [\n  'hmac',\n  'locale',\n  'protocol',\n  'session',\n  'id_token',\n  'shop',\n  'timestamp',\n  'host',\n  'embedded',\n  // sent when clicking rel=\"home\" nav item\n  'appLoadId',\n];\n\nfunction removeRestrictedParams(url: URL | string) {\n  const newUrl = new URL(url);\n  embeddedFrameParamsToRemove.forEach((param) =>\n    newUrl.searchParams.delete(param),\n  );\n  return newUrl;\n}\n", "import {redirect} from '@remix-run/server-runtime';\n\nimport {BasicParams} from '../../../types';\n\nexport function validateShopAndHostParams(\n  params: BasicParams,\n  request: Request,\n) {\n  const {api, config, logger} = params;\n\n  if (config.isEmbeddedApp) {\n    const url = new URL(request.url);\n    const shop = api.utils.sanitizeShop(url.searchParams.get('shop')!);\n    if (!shop) {\n      logger.debug('Missing or invalid shop, redirecting to login path', {\n        shop,\n      });\n      throw redirectToLoginPath(request, params);\n    }\n\n    const host = api.utils.sanitizeHost(url.searchParams.get('host')!);\n    if (!host) {\n      logger.debug('Invalid host, redirecting to login path', {\n        shop,\n        host: url.searchParams.get('host'),\n      });\n      throw redirectToLoginPath(request, params);\n    }\n  }\n}\n\nfunction redirectToLoginPath(request: Request, params: BasicParams): never {\n  const {config, logger} = params;\n\n  const {pathname} = new URL(request.url);\n  if (pathname === config.auth.loginPath) {\n    const message =\n      `Detected call to shopify.authenticate.admin() from configured login path ` +\n      `('${config.auth.loginPath}'), please make sure to call shopify.login() from that route instead.`;\n\n    logger.debug(message);\n    throw new Response(message, {status: 500});\n  }\n\n  throw redirect(config.auth.loginPath);\n}\n", "import {redirect as remixRedirect} from '@remix-run/server-runtime';\n\nimport type {BasicParams} from '../../../types';\n\nimport {redirectWithAppBridgeHeaders} from './redirect-with-app-bridge-headers';\n\nexport async function redirectToInstallPage(\n  params: BasicParams,\n  shop: string,\n  optionalScopes: string[] = [],\n): Promise<never> {\n  const installUrl = buildInstallUrl(params, shop, optionalScopes);\n  if (params.config.isEmbeddedApp) {\n    throw redirectWithAppBridgeHeaders(installUrl);\n  } else {\n    throw remixRedirect(installUrl);\n  }\n}\n\nfunction buildInstallUrl(\n  params: BasicParams,\n  shop: string,\n  optionalScopes: string[] = [],\n) {\n  const baseInstallUrl = buildBaseInstallUrl(params, shop);\n  baseInstallUrl.search = buildParamsInstallUrl(\n    params,\n    optionalScopes,\n  ).toString();\n  return baseInstallUrl.href;\n}\n\nfunction buildBaseInstallUrl({api}: BasicParams, shop: string) {\n  const cleanShop = api.utils.sanitizeShop(shop, true);\n  return new URL(`https://${cleanShop}/admin/oauth/install`);\n}\n\nfunction buildParamsInstallUrl(\n  {config}: BasicParams,\n  optionalScopes: string[] = [],\n) {\n  const optionalScopesParam =\n    optionalScopes && optionalScopes.length > 0\n      ? {optional_scopes: optionalScopes.join(',')}\n      : undefined;\n\n  const query = {\n    client_id: config.apiKey,\n    scope: config.scopes?.toString() || '',\n    ...optionalScopesParam,\n  };\n  return new URLSearchParams(query);\n}\n", "import {AdminApiContext} from '../../../../clients';\n\nexport interface FetchScopesDetailResponse {\n  app: {\n    requestedAccessScopes: {\n      handle: string;\n    }[];\n    optionalAccessScopes: {\n      handle: string;\n    }[];\n    installation: {\n      accessScopes: {\n        handle: string;\n      }[];\n    };\n  };\n}\n\nconst FETCH_SCOPES_DETAIL_QUERY = `#graphql\nquery FetchAccessScopes{\n  app {\n    requestedAccessScopes {\n      handle\n    }\n    optionalAccessScopes {\n      handle\n    }\n    installation {\n      accessScopes {\n        handle\n      }\n    }\n  }\n}`;\n\nexport async function fetchScopeDetail(\n  admin: AdminApiContext,\n): Promise<FetchScopesDetailResponse> {\n  const fetchScopeDetailResult = await admin.graphql(FETCH_SCOPES_DETAIL_QUERY);\n\n  const resultContent = await fetchScopeDetailResult.json();\n  return resultContent.data;\n}\n", "import {AuthScopes, Session} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../../types';\nimport {redirectToInstallPage} from '../helpers/redirect-to-install-page';\nimport {AdminApiContext} from '../../../clients';\n\nimport {fetchScopeDetail} from './client/fetch-scopes-details';\n\nexport function requestScopesFactory(\n  params: BasicParams,\n  session: Session,\n  admin: AdminApiContext,\n) {\n  return async function requestScopes(scopes: string[]) {\n    const {logger} = params;\n\n    logger.debug('Requesting optional scopes: ', {shop: session.shop, scopes});\n\n    if (scopes.length === 0) return;\n    if (await alreadyGranted(scopes, admin)) return;\n\n    throw await redirectToInstallPage(params, session.shop, scopes);\n  };\n\n  async function alreadyGranted(scopes: string[], admin: AdminApiContext) {\n    const scopesDetail = await fetchScopeDetail(admin);\n    const grantedScopes = scopesDetail.app.installation.accessScopes.map(\n      (scope) => scope.handle,\n    );\n    return new AuthScopes(grantedScopes).has(scopes);\n  }\n}\n", "import {AuthScopes, Session} from '@shopify/shopify-api';\n\nimport {AdminApiContext} from '../../../clients';\nimport type {BasicParams} from '../../../types';\n\nimport {ScopesDetail} from './types';\nimport {\n  FetchScopesDetailResponse,\n  fetchScopeDetail,\n} from './client/fetch-scopes-details';\n\nexport function queryScopesFactory(\n  params: BasicParams,\n  session: Session,\n  admin: AdminApiContext,\n) {\n  return async function queryScopes() {\n    const {logger} = params;\n\n    logger.debug('Querying scopes details: ', {\n      shop: session.shop,\n    });\n\n    const scopesDetail = await fetchScopeDetail(admin);\n    return mapFetchScopeDetail(scopesDetail);\n  };\n}\n\nexport function mapFetchScopeDetail(\n  scopesDetailResponse: FetchScopesDetailResponse,\n): ScopesDetail {\n  const appInformation = scopesDetailResponse.app;\n\n  const granted = new AuthScopes(\n    appInformation.installation.accessScopes.map((scope) => scope.handle),\n  ).toArray(true);\n\n  const required = new AuthScopes(\n    appInformation.requestedAccessScopes.map((scope) => scope.handle),\n  ).toArray(true);\n\n  const optional = new AuthScopes(\n    appInformation.optionalAccessScopes.map((scope) => scope.handle),\n  ).toArray(true);\n\n  return {\n    granted,\n    required,\n    optional,\n  };\n}\n", "import {AdminApiContext} from '../../../../clients';\n\nexport interface RevokeScopesResponse {\n  revoked: {\n    handle: string;\n  }[];\n  userErrors: {\n    field: string;\n    message: string;\n  }[];\n}\n\nconst REVOKE_SCOPE_MUTATION = `#graphql\nmutation AppRevokeAccessScopes($scopes: [String!]!) {\n  appRevokeAccessScopes(scopes: $scopes){\n    revoked {\n      handle\n    }\n    userErrors {\n      field\n      message\n    }\n  }\n}`;\n\nexport async function revokeScopes(\n  admin: AdminApiContext,\n  scopes: string[],\n): Promise<RevokeScopesResponse> {\n  const revokeScopesResult = await admin.graphql(REVOKE_SCOPE_MUTATION, {\n    variables: {\n      scopes,\n    },\n  });\n\n  const resultContent = await revokeScopesResult.json();\n  return resultContent.data.appRevokeAccessScopes;\n}\n", "import {Session} from '@shopify/shopify-api';\n\nimport {AdminApiContext} from '../../../clients';\nimport type {BasicParams} from '../../../types';\n\nimport {revokeScopes} from './client/revoke-scopes';\n\nexport function revokeScopesFactory(\n  params: BasicParams,\n  session: Session,\n  admin: AdminApiContext,\n) {\n  return async function revoke(scopes: string[]) {\n    const {logger} = params;\n\n    await validateScopes(scopes);\n\n    logger.debug('Revoke scopes: ', {\n      shop: session.shop,\n      scopes,\n    });\n\n    const revokeScopesResult = await revokeScopes(admin, scopes);\n    if (revokeScopesResult.userErrors?.length > 0) {\n      logger.error('Failed to revoke scopes: ', {\n        shop: session.shop,\n        errors: revokeScopesResult.userErrors,\n      });\n\n      throw new Response(JSON.stringify(revokeScopesResult.userErrors), {\n        status: 422,\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n    }\n\n    return {\n      revoked: revokeScopesResult.revoked.map((scope) => scope.handle),\n    };\n  };\n}\n\nasync function validateScopes(scopes: string[]) {\n  if (!scopes || scopes.length === 0) {\n    throw new Response('No scopes provided', {status: 400});\n  }\n}\n", "import {Session} from '@shopify/shopify-api';\n\nimport {BasicParams} from '../../../types';\nimport {AdminApiContext} from '../../../clients';\n\nimport {ScopesApiContext} from './types';\nimport {requestScopesFactory} from './request';\nimport {queryScopesFactory} from './query';\nimport {revokeScopesFactory} from './revoke';\n\nexport function scopesApiFactory(\n  params: BasicParams,\n  session: Session,\n  admin: AdminApiContext,\n): ScopesApiContext {\n  return {\n    query: queryScopesFactory(params, session, admin),\n    request: requestScopesFactory(params, session, admin),\n    revoke: revokeScopesFactory(params, session, admin),\n  };\n}\n", "import {JwtPayload, Session} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../types';\nimport type {AppConfigArg} from '../../config-types';\nimport {\n  getSessionTokenHeader,\n  ensureCORSHeadersFactory,\n  getSessionTokenFromUrlParam,\n  respondToBotRequest,\n  respondToOptionsRequest,\n  validateSessionToken,\n  getShopFromRequest,\n} from '../helpers';\n\nimport {\n  cancelBillingFactory,\n  requestBillingFactory,\n  requireBillingFactory,\n  checkBillingFactory,\n  createUsageRecordFactory,\n  updateUsageCappedAmountFactory,\n} from './billing';\nimport type {\n  AdminContext,\n  AuthenticateAdmin,\n  EmbeddedAdminContext,\n  NonEmbeddedAdminContext,\n} from './types';\nimport {\n  createAdminApiContext,\n  ensureAppIsEmbeddedIfRequired,\n  ensureSessionTokenSearchParamIfRequired,\n  redirectFactory,\n  renderAppBridge,\n  validateShopAndHostParams,\n} from './helpers';\nimport {AuthorizationStrategy} from './strategies/types';\nimport {scopesApiFactory} from './scope/factory';\n\nexport interface SessionTokenContext {\n  shop: string;\n  sessionId?: string;\n  sessionToken?: string;\n  payload?: JwtPayload;\n}\n\ninterface AuthStrategyParams extends BasicParams {\n  strategy: AuthorizationStrategy;\n}\n\nexport function authStrategyFactory<ConfigArg extends AppConfigArg>({\n  strategy,\n  ...params\n}: AuthStrategyParams): AuthenticateAdmin<ConfigArg> {\n  const {api, logger, config} = params;\n\n  async function respondToBouncePageRequest(request: Request) {\n    const url = new URL(request.url);\n\n    if (url.pathname === config.auth.patchSessionTokenPath) {\n      logger.debug('Rendering bounce page', {\n        shop: getShopFromRequest(request),\n      });\n      throw renderAppBridge({config, logger, api}, request);\n    }\n  }\n\n  async function respondToExitIframeRequest(request: Request) {\n    const url = new URL(request.url);\n\n    if (url.pathname === config.auth.exitIframePath) {\n      const destination = url.searchParams.get('exitIframe')!;\n\n      logger.debug('Rendering exit iframe page', {\n        shop: getShopFromRequest(request),\n        destination,\n      });\n      throw renderAppBridge({config, logger, api}, request, {url: destination});\n    }\n  }\n\n  type AdminContextBase =\n    | EmbeddedAdminContext<ConfigArg>\n    | NonEmbeddedAdminContext<ConfigArg>;\n\n  function createContext(\n    request: Request,\n    session: Session,\n    authStrategy: AuthorizationStrategy,\n    sessionToken?: JwtPayload,\n  ): AdminContext<ConfigArg> {\n    let context: AdminContextBase = {\n      admin: createAdminApiContext(\n        session,\n        params,\n        authStrategy.handleClientError(request),\n      ),\n      billing: {\n        require: requireBillingFactory(params, request, session),\n        check: checkBillingFactory(params, request, session),\n        request: requestBillingFactory(params, request, session),\n        cancel: cancelBillingFactory(params, request, session),\n        createUsageRecord: createUsageRecordFactory(params, request, session),\n        updateUsageCappedAmount: updateUsageCappedAmountFactory(\n          params,\n          request,\n          session,\n        ),\n      },\n\n      session,\n      cors: ensureCORSHeadersFactory(params, request),\n    };\n\n    context = addEmbeddedFeatures(context, request, session, sessionToken);\n    context = addScopesFeatures(context);\n\n    return context as AdminContext<ConfigArg>;\n  }\n\n  function addEmbeddedFeatures(\n    context: AdminContextBase,\n    request: Request,\n    session: Session,\n    sessionToken?: JwtPayload,\n  ) {\n    if (config.isEmbeddedApp) {\n      return {\n        ...context,\n        sessionToken,\n        redirect: redirectFactory(params, request, session.shop),\n      };\n    }\n    return context;\n  }\n\n  function addScopesFeatures(context: AdminContextBase) {\n    return {\n      ...context,\n      scopes: scopesApiFactory(params, context.session, context.admin),\n    };\n  }\n\n  return async function authenticateAdmin(request: Request) {\n    try {\n      respondToBotRequest(params, request);\n      respondToOptionsRequest(params, request);\n      await respondToBouncePageRequest(request);\n      await respondToExitIframeRequest(request);\n      await strategy.respondToOAuthRequests(request);\n\n      // If this is a valid request, but it doesn't have a session token header, this is a document request. We need to\n      // ensure we're embedded if needed and we have the information needed to load the session.\n      if (!getSessionTokenHeader(request)) {\n        validateShopAndHostParams(params, request);\n        await ensureAppIsEmbeddedIfRequired(params, request);\n        await ensureSessionTokenSearchParamIfRequired(params, request);\n      }\n\n      logger.info('Authenticating admin request', {\n        shop: getShopFromRequest(request),\n      });\n\n      const {payload, shop, sessionId, sessionToken} =\n        await getSessionTokenContext(params, request);\n\n      logger.debug('Loading session from storage', {shop, sessionId});\n      const existingSession = sessionId\n        ? await config.sessionStorage!.loadSession(sessionId)\n        : undefined;\n\n      const session = await strategy.authenticate(request, {\n        session: existingSession,\n        sessionToken,\n        shop,\n      });\n\n      return createContext(request, session, strategy, payload);\n    } catch (errorOrResponse) {\n      if (errorOrResponse instanceof Response) {\n        logger.debug('Authenticate returned a response', {\n          shop: getShopFromRequest(request),\n        });\n        ensureCORSHeadersFactory(params, request)(errorOrResponse);\n      }\n\n      throw errorOrResponse;\n    }\n  };\n}\n\nasync function getSessionTokenContext(\n  params: BasicParams,\n  request: Request,\n): Promise<SessionTokenContext> {\n  const {api, config, logger} = params;\n\n  const headerSessionToken = getSessionTokenHeader(request);\n  const searchParamSessionToken = getSessionTokenFromUrlParam(request);\n  const sessionToken = (headerSessionToken || searchParamSessionToken)!;\n\n  logger.debug('Attempting to authenticate session token', {\n    shop: getShopFromRequest(request),\n    sessionToken: JSON.stringify({\n      header: headerSessionToken,\n      search: searchParamSessionToken,\n    }),\n  });\n\n  if (config.isEmbeddedApp) {\n    const payload = await validateSessionToken(params, request, sessionToken);\n    const dest = new URL(payload.dest);\n    const shop = dest.hostname;\n\n    logger.debug('Session token is valid - authenticated', {shop, payload});\n    const sessionId = config.useOnlineTokens\n      ? api.session.getJwtSessionId(shop, payload.sub)\n      : api.session.getOfflineId(shop);\n\n    return {shop, payload, sessionId, sessionToken};\n  }\n\n  const url = new URL(request.url);\n  const shop = url.searchParams.get('shop')!;\n\n  const sessionId = await api.session.getCurrentId({\n    isOnline: config.useOnlineTokens,\n    rawRequest: request,\n  });\n\n  return {shop, sessionId, payload: undefined, sessionToken};\n}\n", "import {HttpResponseError} from '@shopify/shopify-api';\n\nimport type {HandleAdminClientError} from '../../../clients/admin/types';\nimport {HandleClientErrorOptions} from '../strategies/types';\n\nexport function handleClientErrorFactory({\n  request,\n  onError,\n}: HandleClientErrorOptions): HandleAdminClientError {\n  return async function handleClientError({\n    error,\n    params,\n    session,\n  }): Promise<never> {\n    if (error instanceof HttpResponseError !== true) {\n      params.logger.debug(\n        `Got a response error from the API: ${error.message}`,\n        {shop: session.shop},\n      );\n      throw error;\n    }\n\n    params.logger.debug(\n      `Got an HTTP response error from the API: ${error.message}`,\n      {\n        shop: session.shop,\n        code: error.response.code,\n        statusText: error.response.statusText,\n        body: JSON.stringify(error.response.body),\n      },\n    );\n\n    if (onError) {\n      await onError({request, session, error});\n    }\n\n    // forward a minimal copy of the upstream HTTP response instead of an Error:\n    throw new Response(JSON.stringify(error.response.body), {\n      status: error.response.code,\n      headers: {\n        'Content-Type': error.response.headers!['Content-Type'] as string,\n      },\n    });\n  };\n}\n", "import {AppDistribution, BasicParams} from '../../types';\n\nexport async function createOrLoadOfflineSession(\n  shop: string,\n  {api, config, logger}: BasicParams,\n) {\n  if (config.distribution === AppDistribution.ShopifyAdmin) {\n    logger.debug('Creating custom app session from configured access token', {\n      shop,\n    });\n    return api.session.customAppSession(shop);\n  } else {\n    logger.debug('Loading offline session from session storage', {shop});\n    const offlineSessionId = api.session.getOfflineId(shop);\n    const session = await config.sessionStorage!.loadSession(offlineSessionId);\n\n    return session;\n  }\n}\n", "import {WebhookValidationErrorReason} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../types';\nimport {adminClientFactory} from '../../clients';\nimport {handleClientErrorFactory} from '../admin/helpers';\nimport {createOrLoadOfflineSession} from '../helpers';\n\nimport type {\n  AuthenticateWebhook,\n  WebhookContext,\n  WebhookContextWithoutSession,\n} from './types';\n\nexport function authenticateWebhookFactory<Topics extends string>(\n  params: BasicParams,\n): AuthenticateWebhook<Topics> {\n  const {api, logger} = params;\n\n  return async function authenticate(\n    request: Request,\n  ): Promise<WebhookContext<Topics>> {\n    if (request.method !== 'POST') {\n      logger.debug(\n        'Received a non-POST request for a webhook. Only POST requests are allowed.',\n        {url: request.url, method: request.method},\n      );\n      throw new Response(undefined, {\n        status: 405,\n        statusText: 'Method not allowed',\n      });\n    }\n\n    const rawBody = await request.text();\n\n    const check = await api.webhooks.validate({\n      rawBody,\n      rawRequest: request,\n    });\n\n    if (!check.valid) {\n      if (check.reason === WebhookValidationErrorReason.InvalidHmac) {\n        logger.debug('Webhook HMAC validation failed', check);\n        throw new Response(undefined, {\n          status: 401,\n          statusText: 'Unauthorized',\n        });\n      } else {\n        logger.debug('Webhook validation failed', check);\n        throw new Response(undefined, {status: 400, statusText: 'Bad Request'});\n      }\n    }\n    const session = await createOrLoadOfflineSession(check.domain, params);\n    const webhookContext: WebhookContextWithoutSession<Topics> = {\n      apiVersion: check.apiVersion,\n      shop: check.domain,\n      topic: check.topic as Topics,\n      webhookId: check.webhookId,\n      payload: JSON.parse(rawBody),\n      subTopic: check.subTopic || undefined,\n      session: undefined,\n      admin: undefined,\n    };\n\n    if (!session) {\n      return webhookContext;\n    }\n\n    const admin = adminClientFactory({\n      params,\n      session,\n      handleClientError: handleClientErrorFactory({request}),\n    });\n\n    return {\n      ...webhookContext,\n      session,\n      admin,\n    };\n  };\n}\n", "import {compare} from 'compare-versions';\nimport {FeatureDeprecatedError, Shopify} from '@shopify/shopify-api';\n\nimport {SHOPIFY_REMIX_LIBRARY_VERSION} from './version';\n\n// eslint-disable-next-line no-warning-comments\n// TODO This has been copied from shopify-app-express, it should be extracted into a shared package\n// https://github.com/orgs/Shopify/projects/6899/views/1?pane=issue&itemId=28358070\nexport function overrideLogger(logger: Shopify['logger']): Shopify['logger'] {\n  const baseContext = {package: 'shopify-app'};\n\n  const warningFunction: Shopify['logger']['warning'] = (\n    message,\n    context = {},\n  ) => logger.warning(message, {...baseContext, ...context});\n\n  function deprecated(warningFunction: Shopify['logger']['warning']) {\n    return function (version: string, message: string): Promise<void> {\n      if (compare(SHOPIFY_REMIX_LIBRARY_VERSION, version, '>=')) {\n        throw new FeatureDeprecatedError(\n          `Feature was deprecated in version ${version}`,\n        );\n      }\n\n      return warningFunction(`[Deprecated | ${version}] ${message}`);\n    };\n  }\n\n  return {\n    ...logger,\n    log: (severity, message, context = {}) =>\n      logger.log(severity, message, {...baseContext, ...context}),\n    debug: (message, context = {}) =>\n      logger.debug(message, {...baseContext, ...context}),\n    info: (message, context = {}) =>\n      logger.info(message, {...baseContext, ...context}),\n    warning: warningFunction,\n    error: (message, context = {}) =>\n      logger.error(message, {...baseContext, ...context}),\n    deprecated: deprecated(warningFunction),\n  };\n}\n", "import {redirect} from '@remix-run/server-runtime';\n\nimport {BasicParams, LoginError, LoginErrorType} from '../../types';\n\nexport function loginFactory(params: BasicParams) {\n  const {api, config, logger} = params;\n\n  return async function login(request: Request): Promise<LoginError | never> {\n    const url = new URL(request.url);\n    const shopParam = url.searchParams.get('shop');\n\n    if (request.method === 'GET' && !shopParam) {\n      return {};\n    }\n\n    const shop: string | null =\n      shopParam || ((await request.formData()).get('shop') as string);\n\n    if (!shop) {\n      logger.debug('Missing shop parameter', {shop});\n      return {shop: LoginErrorType.MissingShop};\n    }\n\n    const shopWithoutProtocol = shop\n      .replace(/^https?:\\/\\//, '')\n      .replace(/\\/$/, '');\n    const shopWithDomain =\n      shop?.indexOf('.') === -1\n        ? `${shopWithoutProtocol}.myshopify.com`\n        : shopWithoutProtocol;\n    const sanitizedShop = api.utils.sanitizeShop(shopWithDomain);\n\n    if (!sanitizedShop) {\n      logger.debug('Invalid shop parameter', {shop});\n      return {shop: LoginErrorType.InvalidShop};\n    }\n\n    const authPath = `${config.appUrl}${config.auth.path}?shop=${sanitizedShop}`;\n\n    const adminPath = api.utils.legacyUrlToShopAdminUrl(sanitizedShop);\n    const installPath = `https://${adminPath}/oauth/install?client_id=${config.apiKey}`;\n\n    const shouldInstall =\n      config.isEmbeddedApp && config.future.unstable_newEmbeddedAuthStrategy;\n    const redirectUrl = shouldInstall ? installPath : authPath;\n\n    logger.info(`Redirecting login request to ${redirectUrl}`, {\n      shop: sanitizedShop,\n    });\n\n    throw redirect(redirectUrl);\n  };\n}\n", "import {ShopifyError} from '@shopify/shopify-api';\n\nexport class SessionNotFoundError extends ShopifyError {}\n", "import {createOrLoadOfflineSession} from '../../authenticate/helpers/create-or-load-offline-session';\nimport {SessionNotFoundError} from '../../errors';\nimport {BasicParams} from '../../types';\nimport {adminClientFactory} from '../../clients/admin';\n\nimport {UnauthenticatedAdminContext} from './types';\n\nexport function unauthenticatedAdminContextFactory(params: BasicParams) {\n  return async (shop: string): Promise<UnauthenticatedAdminContext> => {\n    const session = await createOrLoadOfflineSession(shop, params);\n\n    if (!session) {\n      throw new SessionNotFoundError(\n        `Could not find a session for shop ${shop} when creating unauthenticated admin context`,\n      );\n    }\n\n    return {\n      session,\n      admin: adminClientFactory({params, session}),\n    };\n  };\n}\n", "import {BasicParams} from '../../../types';\nimport {\n  respondToBotRequest,\n  respondToOptionsRequest,\n  getSessionTokenHeader,\n  validateSessionToken,\n  ensureCORSHeadersFactory,\n  getShopFromRequest,\n} from '../../helpers';\n\nimport {AuthenticateExtension, ExtensionContext} from './types';\n\nexport function authenticateExtensionFactory(\n  params: BasicParams,\n  requestType: string,\n): AuthenticateExtension {\n  return async function authenticateExtension(\n    request,\n    options = {},\n  ): Promise<ExtensionContext> {\n    const {logger} = params;\n\n    const corsHeaders = options.corsHeaders ?? [];\n\n    respondToBotRequest(params, request);\n    respondToOptionsRequest(params, request, corsHeaders);\n\n    const sessionTokenHeader = getSessionTokenHeader(request);\n\n    logger.info(`Authenticating ${requestType} request`, {\n      shop: getShopFromRequest(request),\n    });\n\n    if (!sessionTokenHeader) {\n      logger.debug('Request did not contain a session token', {\n        shop: getShopFromRequest(request),\n      });\n      throw new Response(undefined, {\n        status: 401,\n        statusText: 'Unauthorized',\n      });\n    }\n\n    return {\n      sessionToken: await validateSessionToken(\n        params,\n        request,\n        sessionTokenHeader,\n        {checkAudience: false, retryRequest: false},\n      ),\n      cors: ensureCORSHeadersFactory(params, request, corsHeaders),\n    };\n  };\n}\n", "import type {BasicParams} from '../../../types';\nimport {authenticateExtensionFactory} from '../extension/authenticate';\n\nimport type {AuthenticateCheckout} from './types';\n\nexport function authenticateCheckoutFactory(\n  params: BasicParams,\n): AuthenticateCheckout {\n  return authenticateExtensionFactory(\n    params,\n    'checkout',\n  ) as AuthenticateCheckout;\n}\n", "import {Session} from '@shopify/shopify-api';\n\nimport {BasicParams} from '../../types';\n\nimport type {StorefrontContext} from '.';\n\nexport function storefrontClientFactory({\n  params,\n  session,\n}: {\n  params: BasicParams;\n  session: Session;\n}): StorefrontContext {\n  const {api} = params;\n\n  return {\n    graphql: async (query, options = {}) => {\n      const client = new api.clients.Storefront({\n        session,\n        apiVersion: options.apiVersion,\n      });\n\n      const apiResponse = await client.request(query, {\n        variables: options?.variables,\n        retries: options?.tries ? options.tries - 1 : 0,\n        headers: options?.headers,\n      });\n\n      return new Response(JSON.stringify(apiResponse));\n    },\n  };\n}\n", "import {adminClientFactory, storefrontClientFactory} from '../../../clients';\nimport {BasicParams} from '../../../types';\n\nimport {\n  AppProxyContext,\n  AppProxyContextWithSession,\n  AuthenticateAppProxy,\n  LiquidResponseFunction,\n} from './types';\n\nexport function authenticateAppProxyFactory(\n  params: BasicParams,\n): AuthenticateAppProxy {\n  const {api, config, logger} = params;\n\n  return async function authenticate(\n    request: Request,\n  ): Promise<AppProxyContext | AppProxyContextWithSession> {\n    const url = new URL(request.url);\n    const shop = url.searchParams.get('shop')!;\n    logger.info('Authenticating app proxy request', {shop});\n\n    if (!(await validateAppProxyHmac(params, url))) {\n      logger.info('App proxy request has invalid signature', {shop});\n      throw new Response(undefined, {\n        status: 400,\n        statusText: 'Bad Request',\n      });\n    }\n\n    const sessionId = api.session.getOfflineId(shop);\n    const session = await config.sessionStorage!.loadSession(sessionId);\n\n    if (!session) {\n      logger.debug('Could not find offline session, returning empty context', {\n        shop,\n        ...Object.fromEntries(url.searchParams.entries()),\n      });\n\n      const context: AppProxyContext = {\n        liquid,\n        session: undefined,\n        admin: undefined,\n        storefront: undefined,\n      };\n\n      return context;\n    }\n\n    const context: AppProxyContextWithSession = {\n      liquid,\n      session,\n      admin: adminClientFactory({params, session}),\n      storefront: storefrontClientFactory({params, session}),\n    };\n\n    return context;\n  };\n}\n\nconst liquid: LiquidResponseFunction = (body, initAndOptions) => {\n  const processedBody = processLiquidBody(body);\n\n  if (typeof initAndOptions !== 'object') {\n    return new Response(processedBody, {\n      status: initAndOptions || 200,\n      headers: {\n        'Content-Type': 'application/liquid',\n      },\n    });\n  }\n\n  const {layout, ...responseInit} = initAndOptions || {};\n  const responseBody =\n    layout === false ? `{% layout none %} ${processedBody}` : processedBody;\n\n  const headers = new Headers(responseInit.headers);\n  headers.set('Content-Type', 'application/liquid');\n\n  return new Response(responseBody, {\n    ...responseInit,\n    headers,\n  });\n};\n\nasync function validateAppProxyHmac(\n  params: BasicParams,\n  url: URL,\n): Promise<boolean> {\n  const {api, logger} = params;\n\n  try {\n    let searchParams = new URLSearchParams(url.search);\n    if (!searchParams.get('index')) {\n      searchParams.delete('index');\n    }\n\n    let isValid = await api.utils.validateHmac(\n      Object.fromEntries(searchParams.entries()),\n      {signator: 'appProxy'},\n    );\n\n    if (!isValid) {\n      const cleanPath = url.pathname\n        .replace(/^\\//, '')\n        .replace(/\\/$/, '')\n        .replaceAll('/', '.');\n      const data = `routes%2F${cleanPath}`;\n\n      searchParams = new URLSearchParams(\n        `?_data=${data}&${searchParams.toString().replace(/^\\?/, '')}`,\n      );\n\n      isValid = await api.utils.validateHmac(\n        Object.fromEntries(searchParams.entries()),\n        {signator: 'appProxy'},\n      );\n\n      if (!isValid) {\n        const searchParams = new URLSearchParams(\n          `?_data=${data}._index&${url.search.replace(/^\\?/, '')}`,\n        );\n\n        isValid = await api.utils.validateHmac(\n          Object.fromEntries(searchParams.entries()),\n          {signator: 'appProxy'},\n        );\n      }\n    }\n\n    return isValid;\n  } catch (error) {\n    const shop = url.searchParams.get('shop')!;\n    logger.info(error.message, {shop});\n    throw new Response(undefined, {status: 400, statusText: 'Bad Request'});\n  }\n}\n\nfunction processLiquidBody(body: string) {\n  return (\n    body\n      // Add trailing slashes to relative form action URLs\n      .replaceAll(\n        /<(form[^>]+)action=\"(\\/[^\"?]+)(\\?[^\"]+)?\">/g,\n        '<$1action=\"$2/$3\">',\n      )\n      // Add trailing slashes to relative link href URLs\n      .replaceAll(/<(a[^>]+)href=\"(\\/[^\"?]+)(\\?[^\"]+)?\">/g, '<$1href=\"$2/$3\">')\n  );\n}\n", "import {BasicParams} from '../../../types';\nimport {authenticateExtensionFactory} from '../extension/authenticate';\n\nimport {AuthenticateCustomerAccount} from './types';\n\nexport function authenticateCustomerAccountFactory(\n  params: BasicParams,\n): AuthenticateCustomerAccount {\n  return authenticateExtensionFactory(\n    params,\n    'customer account',\n  ) as AuthenticateCustomerAccount;\n}\n", "import {BasicParams} from '../../../types';\nimport {authenticateExtensionFactory} from '../extension/authenticate';\n\nimport type {AuthenticatePOS} from './types';\n\nexport function authenticatePOSFactory(params: BasicParams): AuthenticatePOS {\n  return authenticateExtensionFactory(params, 'pos') as AuthenticatePOS;\n}\n", "import {BasicParams} from '../../types';\n\nimport {authenticateCheckoutFactory} from './checkout/authenticate';\nimport {authenticateAppProxyFactory} from './appProxy/authenticate';\nimport {authenticateCustomerAccountFactory} from './customer-account/authenticate';\nimport {AuthenticatePublic} from './types';\nimport {authenticatePOSFactory} from './pos/authenticate';\n\nexport function authenticatePublicFactory(params: BasicParams) {\n  const authenticateCheckout = authenticateCheckoutFactory(params);\n  const authenticateAppProxy = authenticateAppProxyFactory(params);\n  const authenticateCustomerAccount =\n    authenticateCustomerAccountFactory(params);\n  const authenticatePOS = authenticatePOSFactory(params);\n\n  const context: AuthenticatePublic = {\n    checkout: authenticateCheckout,\n    appProxy: authenticateAppProxy,\n    customerAccount: authenticateCustomerAccount,\n    pos: authenticatePOS,\n  };\n\n  return context;\n}\n", "import {createOrLoadOfflineSession} from '../../authenticate/helpers/create-or-load-offline-session';\nimport {SessionNotFoundError} from '../../errors';\nimport {BasicParams} from '../../types';\nimport {storefrontClientFactory} from '../../clients/storefront';\n\nimport {\n  UnauthenticatedStorefrontContext,\n  GetUnauthenticatedStorefrontContext,\n} from './types';\n\nexport function unauthenticatedStorefrontContextFactory(\n  params: BasicParams,\n): GetUnauthenticatedStorefrontContext {\n  return async (shop: string): Promise<UnauthenticatedStorefrontContext> => {\n    const session = await createOrLoadOfflineSession(shop, params);\n\n    if (!session) {\n      throw new SessionNotFoundError(\n        `Could not find a session for shop ${shop} when creating unauthenticated storefront context`,\n      );\n    }\n\n    return {\n      session,\n      storefront: storefrontClientFactory({params, session}),\n    };\n  };\n}\n", "import {Session} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../../types';\nimport {AuthorizationStrategy} from '../strategies/types';\n\nimport {createAdminApiContext} from './create-admin-api-context';\n\nexport async function triggerAfterAuthHook(\n  params: BasicParams,\n  session: Session,\n  request: Request,\n  authStrategy: AuthorizationStrategy,\n) {\n  const {config, logger} = params;\n  if (config.hooks.afterAuth) {\n    logger.info('Running afterAuth hook', {shop: session.shop});\n\n    const admin = createAdminApiContext(\n      session,\n      params,\n      authStrategy.handleClientError(request),\n    );\n\n    await config.hooks.afterAuth({\n      session,\n      admin,\n    });\n  }\n}\n", "import {\n  CookieNotFound,\n  GraphqlQueryError,\n  HttpResponseError,\n  InvalidHmacError,\n  InvalidOAuthError,\n  Session,\n  Shopify,\n} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../../types';\nimport {\n  beginAuth,\n  handleClientErrorFactory,\n  redirectToAuthPage,\n  redirectToShopifyOrAppRoot,\n  redirectWithExitIframe,\n  triggerAfterAuthHook,\n  validateShopAndHostParams,\n} from '../helpers';\nimport {AppConfig, AppConfigArg} from '../../../config-types';\nimport {getSessionTokenHeader} from '../../helpers';\nimport {HandleAdminClientError} from '../../../clients';\nimport type {\n  ApiConfigWithFutureFlags,\n  ApiFutureFlags,\n} from '../../../future/flags';\n\nimport {AuthorizationStrategy, SessionContext, OnErrorOptions} from './types';\n\nexport class AuthCodeFlowStrategy<Config extends AppConfigArg>\n  implements AuthorizationStrategy\n{\n  protected api: Shopify<\n    ApiConfigWithFutureFlags<Config['future']>,\n    ApiFutureFlags<Config['future']>\n  >;\n\n  protected config: AppConfig;\n  protected logger: Shopify['logger'];\n\n  public constructor({api, config, logger}: BasicParams) {\n    this.api = api;\n    this.config = config;\n    this.logger = logger;\n  }\n\n  public async respondToOAuthRequests(request: Request): Promise<void | never> {\n    const {api, config} = this;\n\n    const url = new URL(request.url);\n    const isAuthRequest = url.pathname === config.auth.path;\n    const isAuthCallbackRequest = url.pathname === config.auth.callbackPath;\n\n    if (isAuthRequest || isAuthCallbackRequest) {\n      const shop = api.utils.sanitizeShop(url.searchParams.get('shop')!);\n      if (!shop) throw new Response('Shop param is invalid', {status: 400});\n\n      if (isAuthRequest) {\n        throw await this.handleAuthBeginRequest(request, shop);\n      } else {\n        throw await this.handleAuthCallbackRequest(request, shop);\n      }\n    }\n\n    if (!getSessionTokenHeader(request)) {\n      // This is a document request that doesn't contain a session token. We check if the app is installed.\n      // If the app isn't installed, we initiate the OAuth auth code flow.\n      // Requests with a header can only happen after the app is installed.\n      await this.ensureInstalledOnShop(request);\n    }\n  }\n\n  public async authenticate(\n    request: Request,\n    sessionContext: SessionContext,\n  ): Promise<Session | never> {\n    const {api, config, logger} = this;\n\n    const {shop, session} = sessionContext;\n\n    if (!session) {\n      logger.debug('No session found, redirecting to OAuth', {shop});\n      await redirectToAuthPage({config, logger, api}, request, shop);\n    } else if (!session.isActive(config.scopes)) {\n      logger.debug(\n        'Found a session, but it has expired, redirecting to OAuth',\n        {shop},\n      );\n      await redirectToAuthPage({config, logger, api}, request, shop);\n    }\n\n    logger.debug('Found a valid session', {shop});\n\n    return session!;\n  }\n\n  public handleClientError(request: Request): HandleAdminClientError {\n    const {api, config, logger} = this;\n    return handleClientErrorFactory({\n      request,\n      onError: async ({session, error}: OnErrorOptions) => {\n        if (error.response.code === 401) {\n          throw await redirectToAuthPage(\n            {api, config, logger},\n            request,\n            session.shop,\n          );\n        }\n      },\n    });\n  }\n\n  private async ensureInstalledOnShop(request: Request) {\n    const {api, config, logger} = this;\n\n    validateShopAndHostParams({api, config, logger}, request);\n\n    const url = new URL(request.url);\n    let shop = url.searchParams.get('shop');\n\n    // Ensure app is installed\n    logger.debug('Ensuring app is installed on shop', {shop});\n\n    if (!(await this.hasValidOfflineId(request))) {\n      logger.info(\"Could not find a shop, can't authenticate request\");\n      throw new Response(undefined, {\n        status: 400,\n        statusText: 'Bad Request',\n      });\n    }\n\n    const offlineSession = await this.getOfflineSession(request);\n    const isEmbedded = url.searchParams.get('embedded') === '1';\n\n    if (!offlineSession) {\n      logger.info(\"Shop hasn't installed app yet, redirecting to OAuth\", {\n        shop,\n      });\n      if (isEmbedded) {\n        redirectWithExitIframe({api, config, logger}, request, shop!);\n      } else {\n        throw await beginAuth({api, config, logger}, request, false, shop!);\n      }\n    }\n\n    shop = shop || offlineSession.shop;\n\n    if (config.isEmbeddedApp && !isEmbedded) {\n      try {\n        logger.debug('Ensuring offline session is valid before embedding', {\n          shop,\n        });\n        await this.testSession(offlineSession);\n\n        logger.debug('Offline session is still valid, embedding app', {shop});\n      } catch (error) {\n        await this.handleInvalidOfflineSession(error, request, shop);\n      }\n    }\n  }\n\n  private async handleAuthBeginRequest(\n    request: Request,\n    shop: string,\n  ): Promise<never> {\n    const {api, config, logger} = this;\n\n    logger.info('Handling OAuth begin request', {shop});\n\n    // If we're loading from an iframe, we need to break out of it\n    if (\n      config.isEmbeddedApp &&\n      request.headers.get('Sec-Fetch-Dest') === 'iframe'\n    ) {\n      logger.debug('Auth request in iframe detected, exiting iframe', {shop});\n      throw redirectWithExitIframe({api, config, logger}, request, shop);\n    } else {\n      throw await beginAuth({api, config, logger}, request, false, shop);\n    }\n  }\n\n  private async handleAuthCallbackRequest(\n    request: Request,\n    shop: string,\n  ): Promise<never> {\n    const {api, config, logger} = this;\n\n    logger.info('Handling OAuth callback request', {shop});\n\n    try {\n      const {session, headers: responseHeaders} = await api.auth.callback({\n        rawRequest: request,\n      });\n\n      await config.sessionStorage!.storeSession(session);\n\n      if (config.useOnlineTokens && !session.isOnline) {\n        logger.info('Requesting online access token for offline session', {\n          shop,\n        });\n        await beginAuth({api, config, logger}, request, true, shop);\n      }\n\n      logger.debug('Request is valid, loaded session from OAuth callback', {\n        shop: session.shop,\n        isOnline: session.isOnline,\n      });\n\n      await triggerAfterAuthHook({api, config, logger}, session, request, this);\n\n      throw await redirectToShopifyOrAppRoot(\n        request,\n        {api, config, logger},\n        responseHeaders,\n      );\n    } catch (error) {\n      if (error instanceof Response) throw error;\n\n      throw await this.oauthCallbackError(error, request, shop);\n    }\n  }\n\n  private async getOfflineSession(\n    request: Request,\n  ): Promise<Session | undefined> {\n    const offlineId = await this.getOfflineSessionId(request);\n    return this.config.sessionStorage!.loadSession(offlineId!);\n  }\n\n  private async hasValidOfflineId(request: Request) {\n    return Boolean(await this.getOfflineSessionId(request));\n  }\n\n  private async getOfflineSessionId(\n    request: Request,\n  ): Promise<string | undefined> {\n    const {api} = this;\n    const url = new URL(request.url);\n    const shop = url.searchParams.get('shop');\n\n    return shop\n      ? api.session.getOfflineId(shop)\n      : api.session.getCurrentId({isOnline: false, rawRequest: request});\n  }\n\n  private async testSession(session: Session): Promise<void> {\n    const {api} = this;\n\n    const client = new api.clients.Graphql({\n      session,\n    });\n\n    await client.request(`#graphql\n      query shopifyAppShopName {\n        shop {\n          name\n        }\n      }\n    `);\n  }\n\n  private async oauthCallbackError(\n    error: Error,\n    request: Request,\n    shop: string,\n  ) {\n    const {logger} = this;\n    logger.error('Error during OAuth callback', {shop, error: error.message});\n\n    if (error instanceof CookieNotFound) {\n      return this.handleAuthBeginRequest(request, shop);\n    }\n\n    if (\n      error instanceof InvalidHmacError ||\n      error instanceof InvalidOAuthError\n    ) {\n      return new Response(undefined, {\n        status: 400,\n        statusText: 'Invalid OAuth Request',\n      });\n    }\n\n    return new Response(undefined, {\n      status: 500,\n      statusText: 'Internal Server Error',\n    });\n  }\n\n  private async handleInvalidOfflineSession(\n    error: Error,\n    request: Request,\n    shop: string,\n  ) {\n    const {api, logger, config} = this;\n    if (error instanceof HttpResponseError) {\n      if (error.response.code === 401) {\n        logger.info('Shop session is no longer valid, redirecting to OAuth', {\n          shop,\n        });\n        throw await beginAuth({api, config, logger}, request, false, shop);\n      } else {\n        const message = JSON.stringify(error.response.body, null, 2);\n        logger.error(`Unexpected error during session validation: ${message}`, {\n          shop,\n        });\n\n        throw new Response(undefined, {\n          status: error.response.code,\n          statusText: error.response.statusText,\n        });\n      }\n    } else if (error instanceof GraphqlQueryError) {\n      const context: Record<string, string> = {shop};\n      if (error.response) {\n        context.response = JSON.stringify(error.body);\n      }\n\n      logger.error(\n        `Unexpected error during session validation: ${error.message}`,\n        context,\n      );\n\n      throw new Response(undefined, {\n        status: 500,\n        statusText: 'Internal Server Error',\n      });\n    }\n  }\n}\n", "import {\n  HttpResponseError,\n  InvalidJwtError,\n  RequestedTokenType,\n  Session,\n  Shopify,\n} from '@shopify/shopify-api';\n\nimport {AppConfig, AppConfigArg} from '../../../config-types';\nimport {BasicParams} from '../../../types';\nimport {\n  respondToInvalidSessionToken,\n  invalidateAccessToken,\n  getShopFromRequest,\n} from '../../helpers';\nimport {handleClientErrorFactory, triggerAfterAuthHook} from '../helpers';\nimport {HandleAdminClientError} from '../../../clients';\nimport type {\n  ApiConfigWithFutureFlags,\n  ApiFutureFlags,\n} from '../../../future/flags';\n\nimport {AuthorizationStrategy, SessionContext, OnErrorOptions} from './types';\n\nexport class TokenExchangeStrategy<Config extends AppConfigArg>\n  implements AuthorizationStrategy\n{\n  protected api: Shopify<\n    ApiConfigWithFutureFlags<Config['future']>,\n    ApiFutureFlags<Config['future']>\n  >;\n\n  protected config: AppConfig;\n  protected logger: Shopify['logger'];\n\n  public constructor({api, config, logger}: BasicParams<Config['future']>) {\n    this.api = api;\n    this.config = config;\n    this.logger = logger;\n  }\n\n  public async respondToOAuthRequests(_request: Request): Promise<void> {}\n\n  public async authenticate(\n    request: Request,\n    sessionContext: SessionContext,\n  ): Promise<Session> {\n    const {api, config, logger} = this;\n    const {shop, session, sessionToken} = sessionContext;\n\n    if (!sessionToken) throw new InvalidJwtError();\n\n    if (!session || !session.isActive(undefined)) {\n      logger.info('No valid session found', {shop});\n      logger.info('Requesting offline access token', {shop});\n      const {session: offlineSession} = await this.exchangeToken({\n        request,\n        sessionToken,\n        shop,\n        requestedTokenType: RequestedTokenType.OfflineAccessToken,\n      });\n\n      await config.sessionStorage!.storeSession(offlineSession);\n\n      let newSession = offlineSession;\n\n      if (config.useOnlineTokens) {\n        logger.info('Requesting online access token', {shop});\n        const {session: onlineSession} = await this.exchangeToken({\n          request,\n          sessionToken,\n          shop,\n          requestedTokenType: RequestedTokenType.OnlineAccessToken,\n        });\n\n        await config.sessionStorage!.storeSession(onlineSession);\n        newSession = onlineSession;\n      }\n\n      logger.debug('Request is valid, loaded session from session token', {\n        shop: newSession.shop,\n        isOnline: newSession.isOnline,\n      });\n\n      try {\n        await this.handleAfterAuthHook(\n          {api, config, logger},\n          newSession,\n          request,\n          sessionToken,\n        );\n      } catch (errorOrResponse) {\n        if (errorOrResponse instanceof Response) {\n          throw errorOrResponse;\n        }\n\n        throw new Response(undefined, {\n          status: 500,\n          statusText: 'Internal Server Error',\n        });\n      }\n\n      return newSession;\n    }\n\n    return session!;\n  }\n\n  public handleClientError(request: Request): HandleAdminClientError {\n    const {api, config, logger} = this;\n    return handleClientErrorFactory({\n      request,\n      onError: async ({session, error}: OnErrorOptions) => {\n        if (error.response.code === 401) {\n          logger.debug('Responding to invalid access token', {\n            shop: getShopFromRequest(request),\n          });\n          await invalidateAccessToken({config, api, logger}, session);\n\n          respondToInvalidSessionToken({\n            params: {config, api, logger},\n            request,\n          });\n        }\n      },\n    });\n  }\n\n  private async exchangeToken({\n    request,\n    shop,\n    sessionToken,\n    requestedTokenType,\n  }: {\n    request: Request;\n    shop: string;\n    sessionToken: string;\n    requestedTokenType: RequestedTokenType;\n  }): Promise<{session: Session}> {\n    const {api, config, logger} = this;\n\n    try {\n      return await api.auth.tokenExchange({\n        sessionToken,\n        shop,\n        requestedTokenType,\n      });\n    } catch (error) {\n      if (\n        error instanceof InvalidJwtError ||\n        (error instanceof HttpResponseError &&\n          error.response.code === 400 &&\n          error.response.body?.error === 'invalid_subject_token')\n      ) {\n        throw respondToInvalidSessionToken({\n          params: {api, config, logger},\n          request,\n          retryRequest: true,\n        });\n      }\n\n      throw new Response(undefined, {\n        status: 500,\n        statusText: 'Internal Server Error',\n      });\n    }\n  }\n\n  private async handleAfterAuthHook(\n    params: BasicParams,\n    session: Session,\n    request: Request,\n    sessionToken: string,\n  ) {\n    const {config} = params;\n    await config.idempotentPromiseHandler.handlePromise({\n      promiseFunction: () => {\n        return triggerAfterAuthHook(params, session, request, this);\n      },\n      identifier: sessionToken,\n    });\n  }\n}\n", "import {Session, Shopify, ShopifyError} from '@shopify/shopify-api';\n\nimport {AppConfig, AppConfigArg} from '../../../config-types';\nimport {BasicParams} from '../../../types';\nimport {ApiConfigWithFutureFlags, ApiFutureFlags} from '../../../future/flags';\nimport {HandleAdminClientError} from '../../../clients';\nimport {handleClientErrorFactory} from '../helpers';\nimport {getShopFromRequest} from '../../helpers';\n\nimport {AuthorizationStrategy, OnErrorOptions, SessionContext} from './types';\n\nexport class MerchantCustomAuth<Config extends AppConfigArg>\n  implements AuthorizationStrategy\n{\n  protected api: Shopify<\n    ApiConfigWithFutureFlags<Config['future']>,\n    ApiFutureFlags<Config['future']>\n  >;\n\n  protected config: AppConfig;\n  protected logger: Shopify['logger'];\n\n  public constructor({api, config, logger}: BasicParams<Config['future']>) {\n    this.api = api;\n    this.config = config;\n    this.logger = logger;\n  }\n\n  public async respondToOAuthRequests(request: Request): Promise<void> {\n    this.logger.debug('Skipping OAuth request for merchant custom app', {\n      shop: getShopFromRequest(request),\n    });\n  }\n\n  public async authenticate(\n    _request: Request,\n    sessionContext: SessionContext,\n  ): Promise<Session | never> {\n    const {shop} = sessionContext;\n\n    this.logger.debug(\n      'Building session from configured access token for merchant custom app',\n      {shop},\n    );\n    const session = this.api.session.customAppSession(shop);\n\n    return session;\n  }\n\n  public handleClientError(request: Request): HandleAdminClientError {\n    return handleClientErrorFactory({\n      request,\n      onError: async ({error}: OnErrorOptions) => {\n        if (error.response.code === 401) {\n          this.logger.info(\n            'Request failed with 401. Review your API credentials or generate new tokens. https://shopify.dev/docs/apps/build/authentication-authorization/access-token-types/generate-app-access-tokens-admin#rotating-api-credentials-for-admin-created-apps ',\n          );\n          throw new ShopifyError(\n            'Unauthorized: Access token has been revoked.',\n          );\n        }\n      },\n    });\n  }\n}\n", "export interface IdempotentHandlePromiseParams {\n  promiseFunction: () => Promise<any>;\n  identifier: string;\n}\n\nconst IDENTIFIER_TTL_MS = 60000;\n\nexport class IdempotentPromiseHandler {\n  protected identifiers: Map<string, number>;\n\n  constructor() {\n    this.identifiers = new Map<string, number>();\n  }\n\n  async handlePromise({\n    promiseFunction,\n    identifier,\n  }: IdempotentHandlePromiseParams): Promise<any> {\n    try {\n      if (this.isPromiseRunnable(identifier)) {\n        await promiseFunction();\n      }\n    } finally {\n      this.clearStaleIdentifiers();\n    }\n\n    return Promise.resolve();\n  }\n\n  private isPromiseRunnable(identifier: string) {\n    if (!this.identifiers.has(identifier)) {\n      this.identifiers.set(identifier, Date.now());\n      return true;\n    }\n    return false;\n  }\n\n  private async clearStaleIdentifiers() {\n    this.identifiers.forEach((date, identifier, map) => {\n      if (Date.now() - date > IDENTIFIER_TTL_MS) {\n        map.delete(identifier);\n      }\n    });\n  }\n}\n", "import {adminClientFactory} from '../../clients/admin';\nimport {BasicParams} from '../../types';\n\nimport type {AuthenticateFlow, FlowContext} from './types';\n\nexport function authenticateFlowFactory(params: BasicParams): AuthenticateFlow {\n  const {api, config, logger} = params;\n\n  return async function authenticate(request: Request): Promise<FlowContext> {\n    logger.info('Authenticating flow request');\n\n    if (request.method !== 'POST') {\n      logger.debug(\n        'Received a non-POST request for flow. Only POST requests are allowed.',\n        {url: request.url, method: request.method},\n      );\n      throw new Response(undefined, {\n        status: 405,\n        statusText: 'Method not allowed',\n      });\n    }\n\n    const rawBody = await request.text();\n    const result = await api.flow.validate({\n      rawBody,\n      rawRequest: request,\n    });\n\n    if (!result.valid) {\n      logger.error('Received an invalid flow request', {reason: result.reason});\n\n      throw new Response(undefined, {\n        status: 400,\n        statusText: 'Bad Request',\n      });\n    }\n\n    const payload = JSON.parse(rawBody);\n\n    logger.debug('Flow request is valid, looking for an offline session', {\n      shop: payload.shopify_domain,\n    });\n\n    const sessionId = api.session.getOfflineId(payload.shopify_domain);\n    const session = await config.sessionStorage!.loadSession(sessionId);\n\n    if (!session) {\n      logger.info('Flow request could not find session', {\n        shop: payload.shopify_domain,\n      });\n      throw new Response(undefined, {\n        status: 400,\n        statusText: 'Bad Request',\n      });\n    }\n\n    logger.debug('Found a session for the flow request', {shop: session.shop});\n\n    return {\n      session,\n      payload,\n      admin: adminClientFactory({params, session}),\n    };\n  };\n}\n", "import {ShopifyHeader} from '@shopify/shopify-api';\n\nimport {adminClientFactory} from '../../clients/admin';\nimport {BasicParams} from '../../types';\nimport {createOrLoadOfflineSession} from '../helpers';\n\nimport type {\n  AuthenticateFulfillmentService,\n  FulfillmentServiceContext,\n} from './types';\n\nexport function authenticateFulfillmentServiceFactory(\n  params: BasicParams,\n): AuthenticateFulfillmentService {\n  const {api, logger} = params;\n\n  return async function authenticate(\n    request: Request,\n  ): Promise<FulfillmentServiceContext> {\n    logger.info('Authenticating fulfillment service request');\n\n    if (request.method !== 'POST') {\n      logger.debug(\n        'Received a non-POST request for fulfillment service. Only POST requests are allowed.',\n        {url: request.url, method: request.method},\n      );\n      throw new Response(undefined, {\n        status: 405,\n        statusText: 'Method not allowed',\n      });\n    }\n\n    const rawBody = await request.text();\n    const result = await api.fulfillmentService.validate({\n      rawBody,\n      rawRequest: request,\n    });\n\n    if (!result.valid) {\n      logger.error('Received an invalid fulfillment service request', {\n        reason: result.reason,\n      });\n\n      throw new Response(undefined, {\n        status: 400,\n        statusText: 'Bad Request',\n      });\n    }\n\n    const payload = JSON.parse(rawBody);\n    const shop = request.headers.get(ShopifyHeader.Domain) || '';\n\n    logger.debug(\n      'Fulfillment service request is valid, looking for an offline session',\n      {\n        shop,\n      },\n    );\n\n    const session = await createOrLoadOfflineSession(shop, params);\n\n    if (!session) {\n      logger.info('Fulfillment service request could not find session', {\n        shop,\n      });\n      throw new Response(undefined, {\n        status: 400,\n        statusText: 'Bad Request',\n      });\n    }\n\n    logger.debug('Found a session for the fulfillment service request', {\n      shop,\n    });\n\n    return {\n      session,\n      payload,\n      admin: adminClientFactory({params, session}),\n    };\n  };\n}\n", "import type {ConfigParams, Shopify} from '@shopify/shopify-api';\n\nimport {AppConfig} from '../config-types';\n\n// When adding new flags, you should also add them to the `TEST_FUTURE_FLAGS` object in `test-config.ts` to ensure that\n// it doesn't cause regressions.\nexport interface FutureFlags {\n  /**\n   * When enabled, embedded apps will fetch access tokens via [token exchange](https://shopify.dev/docs/apps/auth/get-access-tokens/token-exchange).\n   * This assumes the app has scopes declared for [Shopify managing installation](https://shopify.dev/docs/apps/auth/installation#shopify-managed-installation).\n   *\n   * Learn more about this [new embedded app auth strategy](https://shopify.dev/docs/api/shopify-app-remix#embedded-auth-strategy).\n   *\n   * @default false\n   */\n  unstable_newEmbeddedAuthStrategy?: boolean;\n}\n\n// When adding new flags, use this format:\n// apiFutureFlag: Future extends FutureFlags ? Future['remixFutureFlag'] : false;\nexport interface ApiFutureFlags<_Future extends FutureFlagOptions> {\n  unstable_managedPricingSupport: true;\n}\n\nexport type ApiConfigWithFutureFlags<Future extends FutureFlagOptions> =\n  ConfigParams<ApiFutureFlags<Future>>;\n\nexport type FutureFlagOptions = FutureFlags | undefined;\n\nexport type FeatureEnabled<\n  Future extends FutureFlagOptions,\n  Flag extends keyof FutureFlags,\n> = Future extends FutureFlags\n  ? Future[Flag] extends true\n    ? true\n    : false\n  : false;\n\nexport function logDisabledFutureFlags(\n  config: AppConfig,\n  logger: Shopify['logger'],\n) {\n  const logFlag = (flag: string, message: string) =>\n    logger.info(`Future flag ${flag} is disabled.\\n\\n  ${message}\\n`);\n\n  if (!config.future.unstable_newEmbeddedAuthStrategy) {\n    logFlag(\n      'unstable_newEmbeddedAuthStrategy',\n      'Enable this to use OAuth token exchange instead of auth code to generate API access tokens.' +\n        '\\n  Your app must be using Shopify managed install: https://shopify.dev/docs/apps/auth/installation',\n    );\n  }\n}\n", "import '@shopify/shopify-api/adapters/web-api';\nimport {\n  ConfigInterface as ApiConfig,\n  ShopifyError,\n  shopifyApi,\n} from '@shopify/shopify-api';\nimport {SessionStorage} from '@shopify/shopify-app-session-storage';\n\nimport {type AppConfig, type AppConfigArg} from './config-types';\nimport {\n  AppDistribution,\n  type BasicParams,\n  type ShopifyApp,\n  type ShopifyAppBase,\n  type AdminApp,\n  type SingleMerchantApp,\n  type AppStoreApp,\n} from './types';\nimport {SHOPIFY_REMIX_LIBRARY_VERSION} from './version';\nimport {registerWebhooksFactory} from './authenticate/webhooks';\nimport {authStrategyFactory} from './authenticate/admin/authenticate';\nimport {authenticateWebhookFactory} from './authenticate/webhooks/authenticate';\nimport {overrideLogger} from './override-logger';\nimport {addDocumentResponseHeadersFactory} from './authenticate/helpers';\nimport {loginFactory} from './authenticate/login/login';\nimport {unauthenticatedAdminContextFactory} from './unauthenticated/admin';\nimport {authenticatePublicFactory} from './authenticate/public';\nimport {unauthenticatedStorefrontContextFactory} from './unauthenticated/storefront';\nimport {AuthCodeFlowStrategy} from './authenticate/admin/strategies/auth-code-flow';\nimport {TokenExchangeStrategy} from './authenticate/admin/strategies/token-exchange';\nimport {MerchantCustomAuth} from './authenticate/admin/strategies/merchant-custom-app';\nimport {IdempotentPromiseHandler} from './authenticate/helpers/idempotent-promise-handler';\nimport {authenticateFlowFactory} from './authenticate/flow/authenticate';\nimport {authenticateFulfillmentServiceFactory} from './authenticate/fulfillment-service/authenticate';\nimport {FutureFlagOptions, logDisabledFutureFlags} from './future/flags';\n\n/**\n * Creates an object your app will use to interact with Shopify.\n *\n * @param appConfig Configuration options for your Shopify app, such as the scopes your app needs.\n * @returns `ShopifyApp` An object constructed using your appConfig.  It has methods for interacting with Shopify.\n *\n * @example\n * <caption>The minimum viable configuration</caption>\n * ```ts\n * // /shopify.server.ts\n * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n *\n * const shopify = shopifyApp({\n *   apiKey: process.env.SHOPIFY_API_KEY!,\n *   apiSecretKey: process.env.SHOPIFY_API_SECRET!,\n *   scopes: process.env.SCOPES?.split(\",\")!,\n *   appUrl: process.env.SHOPIFY_APP_URL!,\n * });\n * export default shopify;\n * ```\n */\nexport function shopifyApp<\n  Config extends AppConfigArg<Storage, Future>,\n  Storage extends SessionStorage,\n  Future extends FutureFlagOptions = Config['future'],\n>(appConfig: Readonly<Config>): ShopifyApp<Config> {\n  const api = deriveApi(appConfig);\n  const config = deriveConfig<Storage>(appConfig, api.config);\n  const logger = overrideLogger(api.logger);\n\n  if (appConfig.webhooks) {\n    api.webhooks.addHandlers(appConfig.webhooks);\n  }\n\n  const params: BasicParams = {api, config, logger};\n\n  let strategy;\n  if (config.distribution === AppDistribution.ShopifyAdmin) {\n    strategy = new MerchantCustomAuth(params);\n  } else if (\n    config.future.unstable_newEmbeddedAuthStrategy &&\n    config.isEmbeddedApp\n  ) {\n    strategy = new TokenExchangeStrategy(params);\n  } else {\n    strategy = new AuthCodeFlowStrategy(params);\n  }\n\n  const authStrategy = authStrategyFactory<Config>({\n    ...params,\n    strategy,\n  });\n\n  const shopify:\n    | AdminApp<Config>\n    | AppStoreApp<Config>\n    | SingleMerchantApp<Config> = {\n    sessionStorage: config.sessionStorage,\n    addDocumentResponseHeaders: addDocumentResponseHeadersFactory(params),\n    registerWebhooks: registerWebhooksFactory(params),\n    authenticate: {\n      admin: authStrategy,\n      flow: authenticateFlowFactory(params),\n      public: authenticatePublicFactory(params),\n      fulfillmentService: authenticateFulfillmentServiceFactory(params),\n      webhook: authenticateWebhookFactory<string>(params),\n    },\n    unauthenticated: {\n      admin: unauthenticatedAdminContextFactory(params),\n      storefront: unauthenticatedStorefrontContextFactory(params),\n    },\n  };\n\n  if (\n    isAppStoreApp(shopify, appConfig) ||\n    isSingleMerchantApp(shopify, appConfig)\n  ) {\n    shopify.login = loginFactory(params);\n  }\n\n  logDisabledFutureFlags(config, logger);\n\n  return shopify as ShopifyApp<Config>;\n}\n\nfunction isAppStoreApp<Config extends AppConfigArg>(\n  _shopify: ShopifyAppBase<Config>,\n  config: Config,\n): _shopify is AppStoreApp<Config> {\n  return config.distribution === AppDistribution.AppStore;\n}\n\nfunction isSingleMerchantApp<Config extends AppConfigArg>(\n  _shopify: ShopifyAppBase<Config>,\n  config: Config,\n): _shopify is SingleMerchantApp<Config> {\n  return config.distribution === AppDistribution.SingleMerchant;\n}\n\n// This function is only exported so we can unit test it without having to mock the underlying module.\n// It's not available to consumers of the library because it is not exported in the index module, and never should be.\nexport function deriveApi(appConfig: AppConfigArg): BasicParams['api'] {\n  let appUrl: URL;\n  try {\n    appUrl = new URL(appConfig.appUrl);\n  } catch (error) {\n    const message =\n      appConfig.appUrl === ''\n        ? `Detected an empty appUrl configuration, please make sure to set the necessary environment variables.\\n` +\n          `If you're deploying your app, you can find more information at https://shopify.dev/docs/apps/launch/deployment/deploy-web-app/deploy-to-hosting-service#step-4-set-up-environment-variables`\n        : `Invalid appUrl configuration '${appConfig.appUrl}', please provide a valid URL.`;\n    throw new ShopifyError(message);\n  }\n\n  /* eslint-disable no-process-env */\n  if (appUrl.hostname === 'localhost' && !appUrl.port && process.env.PORT) {\n    appUrl.port = process.env.PORT;\n  }\n  /* eslint-enable no-process-env */\n  appConfig.appUrl = appUrl.origin;\n\n  let userAgentPrefix = `Shopify Remix Library v${SHOPIFY_REMIX_LIBRARY_VERSION}`;\n  if (appConfig.userAgentPrefix) {\n    userAgentPrefix = `${appConfig.userAgentPrefix} | ${userAgentPrefix}`;\n  }\n\n  return shopifyApi({\n    ...appConfig,\n    hostName: appUrl.host,\n    hostScheme: appUrl.protocol.replace(':', '') as 'http' | 'https',\n    userAgentPrefix,\n    isEmbeddedApp: appConfig.isEmbeddedApp ?? true,\n    apiVersion: appConfig.apiVersion,\n    isCustomStoreApp: appConfig.distribution === AppDistribution.ShopifyAdmin,\n    billing: appConfig.billing as ApiConfig['billing'],\n    future: {\n      unstable_managedPricingSupport: true,\n    },\n    _logDisabledFutureFlags: false,\n  });\n}\n\nfunction deriveConfig<Storage extends SessionStorage>(\n  appConfig: AppConfigArg,\n  apiConfig: ApiConfig,\n): AppConfig<Storage> {\n  if (\n    !appConfig.sessionStorage &&\n    appConfig.distribution !== AppDistribution.ShopifyAdmin\n  ) {\n    throw new ShopifyError(\n      'Please provide a valid session storage. Refer to https://github.com/Shopify/shopify-app-js/blob/main/README.md#session-storage-options for options.',\n    );\n  }\n\n  const authPathPrefix = appConfig.authPathPrefix || '/auth';\n  appConfig.distribution = appConfig.distribution ?? AppDistribution.AppStore;\n\n  return {\n    ...appConfig,\n    ...apiConfig,\n    billing: appConfig.billing as ApiConfig['billing'],\n    scopes: apiConfig.scopes,\n    idempotentPromiseHandler: new IdempotentPromiseHandler(),\n    canUseLoginForm: appConfig.distribution !== AppDistribution.ShopifyAdmin,\n    useOnlineTokens: appConfig.useOnlineTokens ?? false,\n    hooks: appConfig.hooks ?? {},\n    sessionStorage: appConfig.sessionStorage as Storage,\n    future: appConfig.future ?? {},\n    auth: {\n      path: authPathPrefix,\n      callbackPath: `${authPathPrefix}/callback`,\n      patchSessionTokenPath: `${authPathPrefix}/session-token`,\n      exitIframePath: `${authPathPrefix}/exit-iframe`,\n      loginPath: `${authPathPrefix}/login`,\n    },\n    distribution: appConfig.distribution,\n  };\n}\n", "import '@shopify/shopify-api/adapters/web-api';\nimport {setAbstractRuntimeString} from '@shopify/shopify-api/runtime';\n\nsetAbstractRuntimeString(() => {\n  return `Remix`;\n});\n\nexport {\n  LogSeverity,\n  DeliveryMethod,\n  BillingInterval,\n  BillingReplacementBehavior,\n  ApiVersion,\n  Session,\n} from '@shopify/shopify-api';\n\nexport type {JwtPayload} from '@shopify/shopify-api';\n\nexport type * from './types-contexts';\nexport type {ShopifyApp, LoginError} from './types';\nexport {LoginErrorType, AppDistribution} from './types';\nexport {boundary} from './boundary';\nexport {shopifyApp} from './shopify-app';\nexport * from './errors';\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAYO,eAAe,qBACpB,aAA8B;AAE9B,QAAMA,WAAU,YAAY;AAC5B,QAAM,UAAU,CAAA;AAChB,aAAW,CAAC,KAAK,KAAK,KAAKA,SAAQ,QAAQ,QAAO,GAAI;AACpD,cAAU,SAAS,KAAK,KAAK;EAC/B;AAEA,SAAO;IACL;IACA,QAAQA,SAAQ,UAAU;IAC1B,KAAK,IAAI,IAAIA,SAAQ,GAAG,EAAE,SAAQ;;AAEtC;AAEO,eAAe,qBACpB,SACA,cAA+B;AAE/B,QAAM,eAAe,IAAI,QAAO;AAChC,cAAY,WAAW,CAAA,CAAE,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAC7C,aAAa,OAAO,KAAK,KAAK,CAAC;AAEjC,SAAO,QAAQ,QAAQ,YAAY;AACrC;AAEO,eAAe,sBACpB,MACA,aAA8B;AAE9B,SAAO,IAAI,SAAS,KAAK,MAAM;IAC7B,QAAQ,KAAK;IACb,YAAY,KAAK;IACjB,SAAS,MAAM,qBAAqB,KAAK,WAAW,CAAA,CAAe;EACpE,CAAA;AACH;SAEgB,sBAAmB;AACjC,SAAO;AACT;;;ACrCA,qBAAqB,KAAK;AAC1B,8BAA8B,oBAAoB;AAClD,+BAA+B,qBAAqB;AACpD,8BAA8B,oBAAoB;AAClD,yBAAyB,mBAAmB;;;ICnBhC;CAAZ,SAAYC,cAAW;AACrB,EAAAA,aAAAA,aAAA,OAAA,IAAA,CAAA,IAAA;AACA,EAAAA,aAAAA,aAAA,SAAA,IAAA,CAAA,IAAA;AACA,EAAAA,aAAAA,aAAA,MAAA,IAAA,CAAA,IAAA;AACA,EAAAA,aAAAA,aAAA,OAAA,IAAA,CAAA,IAAA;AACF,GALY,gBAAA,cAAW,CAAA,EAAA;IAOX;CAAZ,SAAYC,aAAU;AACpB,EAAAA,YAAA,WAAA,IAAA;AACA,EAAAA,YAAA,WAAA,IAAA;AACA,EAAAA,YAAA,SAAA,IAAA;AACA,EAAAA,YAAA,QAAA,IAAA;AACA,EAAAA,YAAA,WAAA,IAAA;AACA,EAAAA,YAAA,WAAA,IAAA;AACA,EAAAA,YAAA,SAAA,IAAA;AACA,EAAAA,YAAA,QAAA,IAAA;AACA,EAAAA,YAAA,WAAA,IAAA;AACA,EAAAA,YAAA,WAAA,IAAA;AACA,EAAAA,YAAA,SAAA,IAAA;AACA,EAAAA,YAAA,QAAA,IAAA;AACA,EAAAA,YAAA,WAAA,IAAA;AACA,EAAAA,YAAA,UAAA,IAAA;AACF,GAfY,eAAA,aAAU,CAAA,EAAA;AAiBf,IAAM,eAAe;IAGhB;CAAZ,SAAYC,gBAAa;AACvB,EAAAA,eAAA,aAAA,IAAA;AACA,EAAAA,eAAA,YAAA,IAAA;AACA,EAAAA,eAAA,QAAA,IAAA;AACA,EAAAA,eAAA,MAAA,IAAA;AACA,EAAAA,eAAA,OAAA,IAAA;AACA,EAAAA,eAAA,UAAA,IAAA;AACA,EAAAA,eAAA,WAAA,IAAA;AACA,EAAAA,eAAA,wBAAA,IAAA;AACA,EAAAA,eAAA,sBAAA,IAAA;AACA,EAAAA,eAAA,sBAAA,IAAA;AACF,GAXY,kBAAA,gBAAa,CAAA,EAAA;IAcb;CAAZ,SAAYC,aAAU;AACpB,EAAAA,YAAA,MAAA,IAAA;AACA,EAAAA,YAAA,SAAA,IAAA;AACF,GAHY,eAAA,aAAU,CAAA,EAAA;AAKf,IAAM,gBAA0B;EACrC;EACA;EACA;;IAGU;CAAZ,SAAYC,kBAAe;AACzB,EAAAA,iBAAA,SAAA,IAAA;AACA,EAAAA,iBAAA,aAAA,IAAA;AACA,EAAAA,iBAAA,QAAA,IAAA;AACA,EAAAA,iBAAA,OAAA,IAAA;AACF,GALY,oBAAA,kBAAe,CAAA,EAAA;IAYf;CAAZ,SAAYC,6BAA0B;AACpC,EAAAA,4BAAA,kBAAA,IAAA;AACA,EAAAA,4BAAA,yBAAA,IAAA;AACA,EAAAA,4BAAA,UAAA,IAAA;AACF,GAJY,+BAAA,6BAA0B,CAAA,EAAA;IAM1B;CAAZ,SAAYC,aAAU;AACpB,EAAAA,YAAAA,YAAA,UAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,oBAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,IAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,SAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,UAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,6BAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,WAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,cAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,gBAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,iBAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,kBAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,OAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,UAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,aAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,UAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,mBAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,YAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,cAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,iBAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,WAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,UAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,kBAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,eAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,6BAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,gBAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,UAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,MAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,gBAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,oBAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,uBAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,mBAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,sBAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,8BAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,mBAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,WAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,qBAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,iBAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,qBAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,gBAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,YAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,oBAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,gBAAA,IAAA,GAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,yBAAA,IAAA,GAAA,IAAA;AACF,GA5CY,eAAA,aAAU,CAAA,EAAA;IA8CV;CAAZ,SAAYC,SAAM;AAChB,EAAAA,QAAA,KAAA,IAAA;AACA,EAAAA,QAAA,MAAA,IAAA;AACA,EAAAA,QAAA,KAAA,IAAA;AACA,EAAAA,QAAA,OAAA,IAAA;AACA,EAAAA,QAAA,QAAA,IAAA;AACA,EAAAA,QAAA,MAAA,IAAA;AACA,EAAAA,QAAA,SAAA,IAAA;AACA,EAAAA,QAAA,SAAA,IAAA;AACF,GATY,WAAA,SAAM,CAAA,EAAA;;;ACpHX,IAAM,8BAA8B;;;ACWrC,SAAU,IAAIC,SAAuB;AACzC,SAAO,SACL,UACA,SACA,UAAsB,CAAA,GAAE;AAExB,QAAI,WAAWA,QAAO,OAAO,OAAO;AAClC;IACF;AAEA,UAAM,SAAmB,CAAA;AAEzB,QAAIA,QAAO,OAAO,YAAY;AAC5B,aAAO,KAAK,IAAG,oBAAI,KAAI,GAAG,YAAW,EAAG,MAAM,GAAG,EAAE,CAAC,GAAG;IACzD;AAEA,QAAI,gBAAgB,QAAQ,WAAW;AACvC,WAAO,QAAQ;AAEf,YAAQ,UAAQ;MACd,KAAK,YAAY;AACf,wBAAgB,GAAG,aAAa;AAChC;MACF,KAAK,YAAY;AACf,wBAAgB,GAAG,aAAa;AAChC;MACF,KAAK,YAAY;AACf,wBAAgB,GAAG,aAAa;AAChC;MACF,KAAK,YAAY;AACf,wBAAgB,GAAG,aAAa;AAChC;;AAGJ,WAAO,KAAK,aAAa;AAEzB,UAAM,eAAyB,CAAA;AAC/B,WAAO,QAAQ,OAAO,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAK;AAC/C,mBAAa,KAAK,GAAG,GAAG,KAAK,KAAK,EAAE;IACtC,CAAC;AAED,QAAI,SAAS;AACb,QAAI,aAAa,SAAS,GAAG;AAC3B,eAAS,OAAO,aAAa,KAAK,IAAI,CAAC;IACzC;AAEA,IAAAA,QAAO,OAAO,IAAI,UAAU,IAAI,OAAO,KAAK,KAAK,CAAC,KAAK,OAAO,GAAG,MAAM,EAAE;EAC3E;AACF;;;ACjDM,SAAU,OAAOC,SAAuB;AAC5C,QAAM,cAAc,IAAIA,OAAM;AAE9B,SAAO;IACL,KAAK;IACL,OAAO,OAAO,SAAiB,UAAsB,CAAA,MACnD,YAAY,YAAY,OAAO,SAAS,OAAO;IACjD,MAAM,OAAO,SAAiB,UAAsB,CAAA,MAClD,YAAY,YAAY,MAAM,SAAS,OAAO;IAChD,SAAS,OAAO,SAAiB,UAAsB,CAAA,MACrD,YAAY,YAAY,SAAS,SAAS,OAAO;IACnD,OAAO,OAAO,SAAiB,UAAsB,CAAA,MACnD,YAAY,YAAY,OAAO,SAAS,OAAO;IACjD,YAAY,WAAW,WAAW;;AAEtC;AAIA,SAAS,WAAW,aAA2B;AAC7C,SAAO,SAAU,SAAiB,SAAe;AAC/C,QAAI,QAAQ,6BAA6B,SAAS,IAAI,GAAG;AACvD,YAAM,IAAI,uBACR,qCAAqC,OAAO,EAAE;IAElD;AAEA,WAAO,YACL,YAAY,SACZ,iBAAiB,OAAO,KAAK,OAAO,EAAE;EAE1C;AACF;;;AC3BM,SAAU,kBAA0D,EACxE,WACA,QAAAC,SACA,YAAAC,YAAU,GACyB;AACnC,QAAM,gBAAgB,OAAO,KAAK,SAAS,EAAE,CAAC;AAC9C,MAAID,QAAO,eAAe,UAAU,aAAa,EAAE,YAAY;AAC7D,WAAOA,OAAM,EAAE,QACb,0CAA0C,UAAU,aAAa,EAAE,UAAU,qCAAqCA,QAAO,UAAU,EAAE;EAEzI;AAEA,SAAO,OAAO,YACZ,OAAO,QAAQ,SAAS,EAAE,IAAI,CAAC,CAAC,MAAM,QAAQ,MAAK;IACjD,MAAM,oBAAoB,SAAQ;IAAG;AAErC,gBAAY,mBAAmB;MAC7B,QAAQC;MACR,QAAAD;IACD,CAAA;AAED,WAAO,QAAQ,YAAY,MAAM,EAAE,IAAI,CAAC,CAAC,YAAY,KAAK,MAAK;AAC5D,YAAsB,mBAAmB;QACxC,QAAQC;QACR,QAAAD;MACD,CAAA;IACH,CAAC;AAED,WAAO,QAAQ,YAAY,OAAO,EAAE,IAAI,CAAC,CAAC,YAAY,KAAK,MAAK;AAC7D,YAAsB,mBAAmB;QACxC,QAAQC;QACR,QAAAD;MACD,CAAA;IACH,CAAC;AAED,YAAQ,eAAe,aAAa,QAAQ;MAC1C,OAAO;IACR,CAAA;AAED,WAAO,CAAC,MAAM,WAAW;EAC3B,CAAC,CAAC;AAEN;;;ACxBM,SAAU,uBACdE,SACAC,SAAqB;AAFjB;AAIJ,MAAI,CAACD,QAAO,yBAAyB;AACnC;EACF;AAEA,QAAM,UAAU,CAAC,MAAc,YAC7BC,QAAO,KAAK,eAAe,IAAI;;IAAsB,OAAO;CAAI;AAElE,MAAI,GAAC,KAAAD,QAAO,WAAP,mBAAe,4BAA2B;AAC7C,YACE,6BACA,mIAAmI;EAEvI;AAEA,MAAI,GAAC,KAAAA,QAAO,WAAP,mBAAe,iCAAgC;AAClD,YACE,kCACA,0LAA0L;EAE9L;AACF;;;ACtDA,IAAM,cAAN,MAAM,YAAU;EAOd,YAAY,QAAkD;AAJtD;AACA;AACA;AAGN,QAAI,cAAwB,CAAA;AAC5B,QAAI,OAAO,WAAW,UAAU;AAC9B,oBAAc,OAAO,MACnB,IAAI,OAAO,GAAG,YAAW,eAAe,MAAM,CAAC;IAEnD,WAAW,MAAM,QAAQ,MAAM,GAAG;AAChC,oBAAc;IAChB,WAAW,QAAQ;AACjB,oBAAc,MAAM,KAAK,OAAO,cAAc;IAChD;AAEA,kBAAc,YACX,IAAI,CAAC,UAAU,MAAM,KAAI,CAAE,EAC3B,OAAO,CAAC,UAAU,MAAM,MAAM;AAEjC,UAAM,gBAAgB,KAAK,iBAAiB,WAAW;AAEvD,UAAM,WAAW,IAAI,IAAI,WAAW;AACpC,UAAM,aAAa,IAAI,IAAI,aAAa;AAExC,SAAK,mBAAmB,IAAI,IAC1B,CAAC,GAAG,QAAQ,EAAE,OAAO,CAAC,MAAM,CAAC,WAAW,IAAI,CAAC,CAAC,CAAC;AAEjD,SAAK,iBAAiB,oBAAI,IAAI,CAAC,GAAG,UAAU,GAAG,UAAU,CAAC;AAC1D,SAAK,iBAAiB;EACxB;;;;EAKO,IAAI,OAAiD;AAC1D,QAAI;AAEJ,QAAI,iBAAiB,aAAY;AAC/B,cAAQ;IACV,OAAO;AACL,cAAQ,IAAI,YAAW,KAAK;IAC9B;AAEA,WACE,MAAM,QAAO,EAAG,OAAO,CAAC,MAAM,CAAC,KAAK,eAAe,IAAI,CAAC,CAAC,EAAE,WAAW;EAE1E;;;;EAKO,OAAO,aAAuD;AACnE,QAAI;AAEJ,QAAI,uBAAuB,aAAY;AACrC,cAAQ;IACV,OAAO;AACL,cAAQ,IAAI,YAAW,WAAW;IACpC;AAEA,WACE,KAAK,iBAAiB,SAAS,MAAM,iBAAiB,QACtD,KAAK,QAAO,EAAG,OAAO,CAAC,MAAM,CAAC,MAAM,IAAI,CAAC,CAAC,EAAE,WAAW;EAE3D;;;;EAKO,WAAQ;AACb,WAAO,KAAK,QAAO,EAAG,KAAK,YAAW,eAAe;EACvD;;;;EAKO,QAAQ,uBAAuB,OAAK;AACzC,WAAO,uBACH,CAAC,GAAG,KAAK,cAAc,IACvB,CAAC,GAAG,KAAK,gBAAgB;EAC/B;EAEQ,iBAAiB,aAAqB;AAC5C,WAAO,YAAY,OAAO,CAAC,OAAiB,YAAmB;AAC7D,YAAM,UAAU,QAAQ,MAAM,iCAAiC;AAC/D,UAAI,SAAS;AACX,cAAM,KAAK,GAAG,QAAQ,CAAC,IAAI,QAAQ,CAAC,IAAI,EAAE,QAAQ,QAAQ,CAAC,CAAC,EAAE;MAChE;AAEA,aAAO;IACT,GAAG,CAAA,CAAE;EACP;;AA9FO,cADH,aACU,mBAAkB;AADlC,IAAM,aAAN;;;ACGM,SAAU,eACd,QAAc;;AAEd,QAAME,UAAS;IACb,QAAQ;IACR,cAAc;IACd,UAAU;IACV,YAAY;IACZ,eAAe;IACf,kBAAkB;IAClB,QAAQ;MACN,KAAK;MACL,OAAO,YAAY;MACnB,cAAc;MACd,YAAY;IACb;IACD,QAAQ,CAAA;IACR,yBAAyB;;AAI3B,QAAM,YAA8B;IAClC;IACA;IACA;;AAEF,MAAI,EAAE,sBAAsB,WAAW,CAAC,OAAO,kBAAkB;AAC/D,cAAU,KAAK,QAAQ;EACzB;AACA,MAAI,sBAAsB,UAAU,OAAO,kBAAkB;AAC3D,QACE,EAAE,yBAAyB,aAC3B,YAAO,wBAAP,mBAA4B,YAAW,GACvC;AACA,gBAAU,KAAK,qBAAqB;IACtC;EACF;AAEA,QAAM,UAA4B,CAAA;AAClC,YAAU,QAAQ,CAAC,QAAO;AACxB,QAAI,CAAC,SAAS,OAAO,GAAG,CAAC,GAAG;AAC1B,cAAQ,KAAK,GAAG;IAClB;EACF,CAAC;AAED,MAAI,QAAQ,QAAQ;AAClB,UAAM,IAAI,aACR,8DAA8D,QAAQ,KACpE,IAAI,CACL,6JAA6J;EAElK;AAEA,QAAM,EACJ,YACA,kBACA,qBACA,iBAAe,QACfC,UACA,iCACA,mBACA,SACA,QACA,GAAG,gBAAe,IAChB;AAEJ,MAAI;AACJ,MAAI,OAAO,WAAW,QAAW;AAC/B,aAAS;EACX,WAAW,OAAO,kBAAkB,YAAY;AAC9C,aAAS,OAAO;EAClB,OAAO;AACL,aAAS,IAAI,WAAW,OAAO,MAAM;EACvC;AAEA,SAAO,OAAOD,SAAQ,iBAAiB;IACrC,UAAU,OAAO,SAAS,QAAQ,OAAO,EAAE;IAC3C;IACA,YAAY,cAAcA,QAAO;IACjC,kBAAkB,oBAAoBA,QAAO;IAC7C,qBAAqB,uBAAuBA,QAAO;IACnD,iBAAiB,mBAAmBA,QAAO;IAC3C,QAAQ,EAAC,GAAGA,QAAO,QAAQ,GAAIC,YAAU,CAAA,EAAG;IAC5C,iCACE,mCAAmCD,QAAO;IAC5C,mBAAmB,qBAAqBA,QAAO;IAC/C,SAAS,WAAWA,QAAO;IAC3B,QAAQ,UAAUA,QAAO;EAC1B,CAAA;AAED,MACEA,QAAO,oBACP,OAAO,wBAAwB,OAAO,cACtC;AACAE,WAAaF,OAAM,EAAE,QACnB,2NAA2N;EAE/N;AAEA,SAAOA;AACT;AAEA,SAAS,SAAY,OAAQ;AAC3B,MAAI,SAAS,MAAM;AACjB,WAAO;EACT;AACA,SAAO,OAAO,UAAU,YAAY,MAAM,QAAQ,KAAK,IACnD,MAAM,SAAS,IACf;AACN;AAEA,SAAS,mBAAmB,UAAuB,SAAe;AAChE,UAAQ,UAAQ;IACd,KAAK,YAAY;AACf,cAAQ,MAAM,OAAO;AACrB;IACF,KAAK,YAAY;AACf,cAAQ,IAAI,OAAO;AACnB;IACF,KAAK,YAAY;AACf,cAAQ,KAAK,OAAO;AACpB;IACF,KAAK,YAAY;AACf,cAAQ,MAAM,OAAO;AACrB;;AAEN;;;AClHM,SAAU,aAAaG,SAAuB;AAClD,MAAI,kBAAkB,GAAG,YAAY,KAAK,2BAA2B,MAAM,sBAAqB,CAAE;AAClG,MAAIA,QAAO,iBAAiB;AAC1B,sBAAkB,GAAGA,QAAO,eAAe,MAAM,eAAe;EAClE;AAEA,SAAO;AACT;AAEA,SAAS,kBAAkB,UAAwB;AACjD,MAAI,CAAC,UAAU;AACb,WAAO,EAAC,OAAO,8BAA6B;EAC9C;AAEA,MAAI;AACF,UAAM,EAAC,QAAQ,YAAY,IAAI,YAAY,MAAM,KAAK,QAAO,IAAI;AAEjE,UAAM,aAAkB;MACtB;MACA;MACA;MACA;MACA;MACA;;AAGF,QAAI,mCAAS,SAAS;AACpB,iBAAW,UAAU,OAAO,YAAY,QAAQ,QAAO,CAAE;IAC3D,WAAW,SAAS;AAClB,iBAAW,UAAU;IACvB;AAEA,WAAO;EACT,QAAQ;AACN,WAAO;EACT;AACF;AAEM,SAAU,oBAAoBA,SAAuB;AACzD,SAAO,CAAC,eAA0B;AAChC,QAAIA,QAAO,OAAO,cAAc;AAC9B,cAAQ,WAAW,MAAI;QACrB,KAAK,iBAAiB;AACpB,gBAAM,cAA0C,WAAW;AAC3D,iBAAOA,OAAM,EAAE,MAAM,sCAAsC;YACzD,eAAe,KAAK,UAAU,YAAY,aAAa;YACvD,UAAU,KAAK,UAAU,kBAAkB,YAAY,QAAQ,CAAC;UACjE,CAAA;AACD;QACF;QACA,KAAK,cAAc;AACjB,gBAAM,cAAuC,WAAW;AACxD,iBAAOA,OAAM,EAAE,MAAM,yBAAyB;YAC5C,eAAe,KAAK,UAAU,YAAY,aAAa;YACvD,cAAc,YAAY;YAC1B,YAAY,YAAY;YACxB,UAAU,YAAY,eAClB,KAAK,UAAU,kBAAkB,YAAY,YAAY,CAAC,IAC1D;UACL,CAAA;AACD;QACF;QACA,KAAK,4CAA4C;AAC/C,gBAAM,cACJ,WAAW;AACb,iBAAOA,OAAM,EAAE,MACb,0DACA;YACE,eAAe,KAAK,UAAU,YAAY,aAAa;YACvD,mBAAmB,YAAY;UAChC,CAAA;AAEH;QACF;QACA,SAAS;AACP,iBAAOA,OAAM,EAAE,MAAM,uBAAuB,WAAW,OAAO,EAAE;AAChE;QACF;;IAEJ;EACF;AACF;SAEgB,mBACd,MACA,cACA,UAAmB;;AAEnB,MAAI,OAAO,aAAa,aAAa;AACnC,UAAM,YAAU,kCAAM,WAAN,mBAAc,YAAW;AACzC,UAAM,IAAIC,iBACR,8CAA8C,OAAO,EAAE;EAE3D;AAEA,QAAM,kBAAkB,oBACtB,OAAO,YAAY,SAAS,QAAQ,QAAO,KAAM,CAAA,CAAE,CAAC;AAGtD,MAAI,SAAS,WAAW,WAAW,MAAM,KAAK,OAAO,eAAe;AAClE,UAAM,IAAIC,kBAAgC;MACxC,WACE,UAAK,OAAO,kBAAZ,mBAA4B,GAAG,YAAW;MAC5C;MACA,SAAS;MACT;IACD,CAAA;EACH;AAEA,QAAM,gBAA0B,CAAA;AAChC,MAAI,KAAK,QAAQ;AACf,kBAAc,KAAK,KAAK,UAAU,KAAK,QAAQ,MAAM,CAAC,CAAC;EACzD;AACA,QAAM,aAAa,UAAU,iBAAiB,cAAc;AAC5D,MAAI,YAAY;AACd,kBAAc,KACZ,qDAAqD,UAAU,EAAE;EAErE;AAEA,QAAM,eAAe,cAAc,SAC/B;EAAM,cAAc,KAAK,IAAI,CAAC,KAC9B;AACJ,QAAM,OAAO,SAAS;AACtB,QAAM,aAAa,SAAS;AAE5B,UAAQ,MAAI;IACV,KAAK,SAAS,WAAW,WAAW,iBAAiB;AACnD,UAAI,cAAc;AAChB,cAAM,IAAIC,oBACR,2DAA2D;MAE/D,OAAO;AACL,cAAM,aAAa,UAAU,iBAAiB,aAAa;AAC3D,cAAM,IAAIC,oBAAkC;UAC1C,SAAS,kCAAkC,YAAY;UACvD;UACA;UACA;UACA,SAAS;UACT,YAAY,aAAa,WAAW,UAAU,IAAI;QACnD,CAAA;MACH;IACF;IACA,KAAK,SAAS,UAAU,WAAW;AACjC,UAAI,cAAc;AAChB,cAAM,IAAID,oBACR,2DAA2D;MAE/D,OAAO;AACL,cAAM,IAAIE,kBAAgC;UACxC,SAAS,yBAAyB,YAAY;UAC9C;UACA;UACA;UACA,SAAS;QACV,CAAA;MACH;IACF;AACE,YAAM,IAAIC,kBAAgC;QACxC,SAAS,+BAA+B,SAAS,MAAM,IAAI,SAAS,UAAU,iBAAiB,YAAY;QAC3G;QACA;QACA;QACA,SAAS;MACV,CAAA;;AAEP;;;IC3Ja,sBAAa;EAOxB,YAAY,QAA2B;AAJ9B;AACA;AACA;AAGP,UAAMC,UAAS,KAAK,aAAY,EAAG;AAEnC,QAAI,CAACA,QAAO,oBAAoB,CAAC,OAAO,QAAQ,aAAa;AAC3D,YAAM,IAAIC,wBACR,mDAAmD;IAEvD;AAEA,QAAI,OAAO,YAAY;AACrB,YAAM,UACJ,OAAO,eAAeD,QAAO,aACzB,oEAAoE,OAAO,UAAU,KACrF,+CAA+CA,QAAO,UAAU,SAAS,OAAO,UAAU;AAEhG,aAAOA,OAAM,EAAE,MAAM,OAAO;IAC9B;AAEA,SAAK,UAAU,OAAO;AACtB,SAAK,aAAa,OAAO;AACzB,SAAK,SAAS,qBAAqB;MACjC,aAAaA,QAAO,uBAAuB,KAAK,QAAQ;MACxD,YAAY,KAAK,cAAcA,QAAO;MACtC,aAAa,KAAK,QAAQ;MAC1B,gBAAgB;MAChB,QAAQ,oBAAoBA,OAAM;MAClC,iBAAiB,aAAaA,OAAM;MACpC,WAAWA,QAAO;IACnB,CAAA;EACH;EAEO,MAAM,MACX,QAAqB;AAErB,WAAO,KAAK,aAAY,EAAG,MAAM,EAAE,WACjC,UACA,kOACyJ;AAG3J,QACG,OAAO,OAAO,SAAS,YAAY,OAAO,KAAK,WAAW,KAC3D,OAAO,QAAQ,OAAO,IAAI,EAAE,WAAW,GACvC;AACA,YAAM,IAAIC,wBAAsC,gBAAgB;IAClE;AAEA,QAAI;AACJ,QAAI;AACJ,QAAI,OAAO,OAAO,SAAS,UAAU;AACnC,kBAAY,OAAO;IACrB,OAAO;AACL,kBAAY,OAAO,KAAK;AACxB,kBAAY,OAAO,KAAK;IAC1B;AAEA,UAAM,UAAU,OAAO,YACrB,OAAO,SAAQ,iCAAQ,iBAAgB,CAAA,CAAE,EAAE,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM;MAC/D;MACA,MAAM,QAAQ,KAAK,IAAI,MAAM,KAAK,IAAI,IAAI,MAAM,SAAQ;IACzD,CAAA,CAAC;AAGJ,UAAM,WAAW,MAAM,KAAK,QAAW,WAAW;MAChD;MACA,SAAS,OAAO,QAAQ,OAAO,QAAQ,IAAI;MAC3C;IACD,CAAA;AAED,WAAO,EAAC,MAAM,UAAe,SAAS,CAAA,EAAE;EAC1C;EAEO,MAAM,QAKX,WACA,SAAoD;AAMpD,UAAM,WAAW,MAAM,KAAK,OAAO,QAGjC,WAAW;MACX,YAAY,KAAK,cAAc,KAAK,aAAY,EAAG,OAAO;MAC1D,GAAI;IACL,CAAA;AAED,QAAI,SAAS,QAAQ;AACnB,YAAM,gBAAgB,SAAS,OAAO;AAEtC,yBAAmB,YAAW,mCAAS,YAAW,KAAK,GAAG,aAAa;IACzE;AAEA,UAAM,eAAe,OAAO,YAC1B,SAAS,UAAU,SAAS,QAAQ,QAAO,IAAK,CAAA,CAAE;AAGpD,WAAO;MACL,GAAG;MACH,SAAS,oBAAoB,gBAAgB,CAAA,CAAE;;EAEnD;EAEQ,eAAY;AAClB,WAAO,KAAK;EACd;AACD;AArHQ,cADI,eACG;AAuHV,SAAU,mBAAmB,EACjC,QAAAD,QAAM,GACmB;EACzB,MAAM,yBAAyB,cAAa;;AACnC,gBADH,kBACU,UAASA;AAGzB,UAAQ,eAAe,kBAAkB,QAAQ;IAC/C,OAAO;EACR,CAAA;AAED,SAAO;AACT;;;AC7JO,SAASE,UAAUC,OAAwB;AAChD,SAAOC,cAAcC,KAAKF,KAAK;AACjC;AAEA,IAAMC,gBAAgB;AAMf,SAASE,SAASH,OAAwB;AAC/C,SAAOI,aAAaF,KAAKF,KAAK;AAChC;AAEA,IAAMI,eAAe;AAUd,SAASC,aACdL,OACAM,SAGS;AACT,MAAIP,UAAUC,KAAK,GAAG;AACpB,WAAOO,OAAOC,cAAcD,OAAOE,SAAST,OAAO,EAAE,CAAC;EACxD;AAEA,QAAMU,MAAMH,OAAOI,WAAWX,KAAK;AACnC,QAAMY,SAASC,OAAOH,GAAG;AAEzB,MAAIV,UAAUY,QAAQ;AACpB,WAAO;EACT;AAEA,QAAME,cAAcC,yBAAyBf,KAAK;AAClD,QAAMgB,eAAeD,yBAAyBH,MAAM;AAEpD,MAAIE,gBAAgBE,cAAc;AAChC,WAAO;EACT;AAEA,OAAIV,WAAAA,gBAAAA,QAAQW,YAAW,MAAM;AAK3B,UAAMC,iBAAiB;AACvB,QACE,CAACnB,UAAUC,KAAK,KAChBgB,aAAaG,UAAUD,kBACvBJ,YAAYM,WAAWJ,aAAaK,UAAU,GAAGH,cAAc,CAAC,GAChE;AACA,aAAO;IACT;EACF;AAEA,SAAO;AACT;AAEA,IAAYI,sBAAkB,SAAlBA,qBAAkB;AAAlBA,EAAAA,oBAAkB,WAAA,IAAA;AAAlBA,EAAAA,oBAAkB,UAAA,IAAA;AAAlBA,EAAAA,oBAAkB,kBAAA,IAAA;AAAlBA,EAAAA,oBAAkB,gBAAA,IAAA;AAAA,SAAlBA;AAAkB,GAAA,CAAA,CAAA;AAYvB,SAASC,sBAAsBvB,OAA+C;AACnF,MAAIK,aAAaL,OAAO;IAAEiB,QAAQ;EAAM,CAAC,GAAG;AAC1C,WAAOO;EACT;AAEA,MAAIzB,UAAUC,KAAK,GAAG;AACpB,WAAOsB,mBAAmBG;EAC5B;AAEA,QAAMf,MAAMH,OAAOI,WAAWX,KAAK;AACnC,MAAI,CAACO,OAAOmB,SAAShB,GAAG,GAAG;AACzB,WAAOY,mBAAmBK;EAC5B;AAEA,MAAIjB,QAAQ,GAAG;AACb,WAAOY,mBAAmBM;EAC5B;AAEA,SAAON,mBAAmBO;AAC5B;AA2HO,SAASC,yBAAyBC,OAAuB;AAC9D,QAAM;IAAEC;IAAOC;EAAI,IAAIC,yBAAyBH,KAAK;AAErD,QAAMI,SAASJ,MAAMK,UAAUJ,OAAOC,GAAG;AAEzC,QAAMI,MAAMF,OAAOG,QAAQ,GAAG;AAC9B,MAAID,QAAQ,IAAI;AACd,WAAOF;EACT;AAEA,SAAOA,OAAOC,UAAU,GAAGC,GAAG,IAAIF,OAAOC,UAAUC,MAAM,CAAC;AAC5D;AAaA,SAASH,yBAAyBH,OAA+C;AAC/E,MAAIC,QAAQ;AACZ,MAAID,MAAM,CAAC,MAAM,KAAK;AACpBC;EACF;AACA,SAAOD,MAAMC,KAAK,MAAM,OAAOD,MAAMC,KAAK,MAAM,KAAK;AACnDA;EACF;AAEA,MAAIC,MAAMF,MAAMQ,YAAY,GAAG;AAC/B,MAAIN,QAAQ,IAAI;AACdA,UAAMF,MAAMQ,YAAY,GAAG;EAC7B;AACA,MAAIN,QAAQ,IAAI;AACdA,UAAMF,MAAMS;EACd;AACA,UAAQT,MAAME,MAAM,CAAC,MAAM,OAAOF,MAAME,MAAM,CAAC,MAAM,QAAQA,MAAMD,OAAO;AACxEC;EACF;AAEA,SAAO;IAAED;IAAOC;EAAI;AACtB;;;AClQO,IAAMQ,iBAAN,MAAqB;EAO1BC,YAAYC,OAAe;AAF3BC;;4CAAmB;AAGjB,QAAI,CAACC,SAASF,KAAK,GAAG;AACpB,YAAM,IAAIG,MAAM,2BAA2BH,KAAK,IAAI;IACtD;AAEA,SAAKA,QAAQA;EACf;;;;;;;;;;;;EAaAI,UAA2B;AACzB,UAAMC,eAAeC,sBAAsB,KAAKN,KAAK;AAGrD,QAAIK,iBAAiBE,UAAaF,iBAAiBG,mBAAmBC,gBAAgB;AACpF,aAAOC,OAAOC,WAAW,KAAKX,KAAK;IACrC;AAGA,QAAIY,UAAU,KAAKZ,KAAK,GAAG;AACzB,aAAOa,OAAO,KAAKb,KAAK;IAC1B;AAGA,UAAM,IAAIG,MACR,+CAA+C,KAAKH,KAAK,WAAWK,YAAY,eAAeK,OAAOC,WAAW,KAAKX,KAAK,CAAC,EAC9H;EACF;;;;EAKAc,WAAmB;AACjB,WAAO,KAAKd;EACd;;;;AAKF;AAKO,SAASC,iBAAiBD,OAAyC;AAExE,SAAQA,SAAS,OAAOA,UAAU,YAAYA,MAAMC,oBAAqB;AAC3E;;;ACxEO,SAASc,oBAAoBC,OAA+B;AACjE,SAAO,IAAIC,eAAeD,KAAK;AACjC;;;ACQO,SAASE,OAAOC,MAAeC,SAA2B;AAC/D,SAAOC,YAAY;IAAE,IAAIF;EAAK,GAAG,IAAIA,MAAMC,OAAO;AACpD;AAKA,SAASC,YACPC,SACAC,KACAC,OACAJ,SACS;AACT,MAAIK,MAAMC,QAAQF,KAAK,GAAG;AACxB,WAAOJ,QAAQO,KAAKL,SAASC,KAAKK,YAAYJ,OAAOJ,OAAO,CAAC;EAC/D;AAEA,MAAII,SAAS,OAAOA,UAAU,YAAY,CAACK,iBAAiBL,KAAK,GAAG;AAGlE,WAAOJ,QAAQO,KAAKL,SAASC,KAAKO,aAAaN,OAAiCJ,OAAO,CAAC;EAC1F;AAEA,SAAOA,QAAQO,KAAKL,SAASC,KAAKC,KAAK;AACzC;AAKA,SAASM,aAAaC,QAAgCX,SAAkB;AACtE,aAAWG,OAAOS,OAAOC,KAAKF,MAAM,GAAG;AACrC,UAAMP,QAAQH,YAAYU,QAAQR,KAAKQ,OAAOR,GAAG,GAAGH,OAAO;AAC3D,QAAII,UAAUU,QAAW;AACvBH,aAAOR,GAAG,IAAIC;IAChB,OAAO;AACL,aAAOO,OAAOR,GAAG;IACnB;EACF;AAEA,SAAOQ;AACT;AAKA,SAASH,YAAYO,OAAuBf,SAAkC;AAC5E,WAASgB,IAAI,GAAGA,IAAID,MAAME,QAAQD,KAAK;AACrCD,UAAMC,CAAC,IAAIf,YAAYc,OAAOG,OAAOF,CAAC,GAAGD,MAAMC,CAAC,GAAGhB,OAAO;EAC5D;AAEA,SAAOe;AACT;;;ACtCO,SAASI,MACdC,MACAC,SAES;AAAA,MADTC,cAAyBC,UAAAC,SAAA,KAAAD,UAAA,CAAA,MAAAE,SAAAF,UAAA,CAAA,IAAGG;AAE5B,MAAIC,IAAI;AACR,QAAMC,QAAQC,WAAW;AACzBC,cAAYF,KAAK;AACjBG,mBAAiB;AAEjB,SAAOV,UAAUW,OAAOJ,OAAOP,OAAO,IAAIO;AAE1C,WAASK,cAAkD;AACzD,QAAIb,KAAKc,WAAWP,CAAC,MAAMQ,kBAAkB;AAC3CR;AACAS,qBAAe;AAEf,YAAMC,SAAiC,CAAC;AACxC,UAAIC,UAAU;AACd,aAAOX,IAAIP,KAAKI,UAAUJ,KAAKc,WAAWP,CAAC,MAAMY,kBAAkB;AACjE,YAAI,CAACD,SAAS;AACZE,mBAAS;AACTJ,yBAAe;QACjB,OAAO;AACLE,oBAAU;QACZ;AAEA,cAAMG,QAAQd;AAEd,cAAMe,MAAMC,YAAY;AACxB,YAAID,QAAQjB,QAAW;AACrBmB,iCAAuB;AACvB;QACF;AAEAR,uBAAe;AACfS,iBAAS;AACT,cAAMjB,SAAQC,WAAW;AAEzB,YAAID,WAAUH,QAAW;AACvBqB,mCAAyB;AACzB;QACF;AAGA,YAAIC,OAAOC,UAAUC,eAAeC,KAAKb,QAAQK,GAAG,KAAK,CAACS,YAAYvB,QAAOS,OAAOK,GAAG,CAAC,GAAG;AAGzFU,4BAAkBV,KAAKD,QAAQ,CAAC;QAClC;AAEAJ,eAAOK,GAAG,IAAId;MAChB;AAEA,UAAIR,KAAKc,WAAWP,CAAC,MAAMY,kBAAkB;AAC3Cc,oCAA4B;MAC9B;AACA1B;AAEA,aAAOU;IACT;EACF;AAEA,WAASiB,aAAuC;AAC9C,QAAIlC,KAAKc,WAAWP,CAAC,MAAM4B,oBAAoB;AAC7C5B;AACAS,qBAAe;AAEf,YAAMoB,QAAQ,CAAA;AACd,UAAIlB,UAAU;AACd,aAAOX,IAAIP,KAAKI,UAAUJ,KAAKc,WAAWP,CAAC,MAAM8B,oBAAoB;AACnE,YAAI,CAACnB,SAAS;AACZE,mBAAS;QACX,OAAO;AACLF,oBAAU;QACZ;AAEA,cAAMV,SAAQC,WAAW;AACzB6B,wBAAgB9B,MAAK;AACrB4B,cAAMG,KAAK/B,MAAK;MAClB;AAEA,UAAIR,KAAKc,WAAWP,CAAC,MAAM8B,oBAAoB;AAC7CG,oCAA4B;MAC9B;AACAjC;AAEA,aAAO6B;IACT;EACF;AAEA,WAAS3B,aAAsB;AAC7BO,mBAAe;AAEf,UAAMR,SACJe,YAAY,KACZkB,aAAa,KACb5B,YAAY,KACZqB,WAAW,KACXQ,aAAa,QAAQ,IAAI,KACzBA,aAAa,SAAS,KAAK,KAC3BA,aAAa,QAAQ,IAAI;AAE3B1B,mBAAe;AAEf,WAAOR;EACT;AAEA,WAASkC,aAAaC,MAAcnC,QAAqC;AACvE,QAAIR,KAAK4C,MAAMrC,GAAGA,IAAIoC,KAAKvC,MAAM,MAAMuC,MAAM;AAC3CpC,WAAKoC,KAAKvC;AACV,aAAOI;IACT;EACF;AAEA,WAASQ,iBAAiB;AACxB,WAAO6B,aAAa7C,KAAKc,WAAWP,CAAC,CAAC,GAAG;AACvCA;IACF;EACF;AAEA,WAASgB,cAAc;AACrB,QAAIvB,KAAKc,WAAWP,CAAC,MAAMuC,iBAAiB;AAC1CvC;AACA,UAAIwC,SAAS;AACb,aAAOxC,IAAIP,KAAKI,UAAUJ,KAAKc,WAAWP,CAAC,MAAMuC,iBAAiB;AAChE,YAAI9C,KAAKc,WAAWP,CAAC,MAAMyC,eAAe;AACxC,gBAAMC,OAAOjD,KAAKO,IAAI,CAAC;AACvB,gBAAM2C,aAAaC,iBAAiBF,IAAI;AACxC,cAAIC,eAAe7C,QAAW;AAC5B0C,sBAAUG;AACV3C;UACF,WAAW0C,SAAS,KAAK;AACvB,gBACEG,MAAMpD,KAAKc,WAAWP,IAAI,CAAC,CAAC,KAC5B6C,MAAMpD,KAAKc,WAAWP,IAAI,CAAC,CAAC,KAC5B6C,MAAMpD,KAAKc,WAAWP,IAAI,CAAC,CAAC,KAC5B6C,MAAMpD,KAAKc,WAAWP,IAAI,CAAC,CAAC,GAC5B;AACAwC,wBAAUM,OAAOC,aAAaC,OAAOC,SAASxD,KAAK4C,MAAMrC,IAAI,GAAGA,IAAI,CAAC,GAAG,EAAE,CAAC;AAC3EA,mBAAK;YACP,OAAO;AACLkD,2CAA6BlD,CAAC;YAChC;UACF,OAAO;AACLmD,wCAA4BnD,CAAC;UAC/B;QACF,OAAO;AACL,cAAIoD,uBAAuB3D,KAAKc,WAAWP,CAAC,CAAC,GAAG;AAC9CwC,sBAAU/C,KAAKO,CAAC;UAClB,OAAO;AACLqD,kCAAsB5D,KAAKO,CAAC,CAAC;UAC/B;QACF;AACAA;MACF;AACAsD,wBAAkB;AAClBtD;AACA,aAAOwC;IACT;EACF;AAEA,WAASN,eAAe;AACtB,UAAMpB,QAAQd;AACd,QAAIP,KAAKc,WAAWP,CAAC,MAAMuD,WAAW;AACpCvD;AACAwD,kBAAY1C,KAAK;IACnB;AAEA,QAAIrB,KAAKc,WAAWP,CAAC,MAAMyD,UAAU;AACnCzD;IACF,WAAW0D,eAAejE,KAAKc,WAAWP,CAAC,CAAC,GAAG;AAC7CA;AACA,aAAO2D,QAAQlE,KAAKc,WAAWP,CAAC,CAAC,GAAG;AAClCA;MACF;IACF;AAEA,QAAIP,KAAKc,WAAWP,CAAC,MAAM4D,SAAS;AAClC5D;AACAwD,kBAAY1C,KAAK;AACjB,aAAO6C,QAAQlE,KAAKc,WAAWP,CAAC,CAAC,GAAG;AAClCA;MACF;IACF;AAEA,QAAIP,KAAKc,WAAWP,CAAC,MAAM6D,kBAAkBpE,KAAKc,WAAWP,CAAC,MAAM8D,gBAAgB;AAClF9D;AACA,UAAIP,KAAKc,WAAWP,CAAC,MAAMuD,aAAa9D,KAAKc,WAAWP,CAAC,MAAM+D,UAAU;AACvE/D;MACF;AACAwD,kBAAY1C,KAAK;AACjB,aAAO6C,QAAQlE,KAAKc,WAAWP,CAAC,CAAC,GAAG;AAClCA;MACF;IACF;AAEA,QAAIA,IAAIc,OAAO;AACb,aAAOnB,YAAYF,KAAK4C,MAAMvB,OAAOd,CAAC,CAAC;IACzC;EACF;AAEA,WAASa,WAAW;AAClB,QAAIpB,KAAKc,WAAWP,CAAC,MAAMgE,WAAW;AACpC,YAAM,IAAIC,YAAY,kCAAkCC,MAAM,CAAC,EAAE;IACnE;AACAlE;EACF;AAEA,WAASkB,WAAW;AAClB,QAAIzB,KAAKc,WAAWP,CAAC,MAAMmE,WAAW;AACpC,YAAM,IAAIF,YAAY,0CAA0CC,MAAM,CAAC,EAAE;IAC3E;AACAlE;EACF;AAEA,WAASG,YAAYF,QAAgB;AACnC,QAAIA,WAAUH,QAAW;AACvB,YAAM,IAAImE,YAAY,uBAAuBC,MAAM,CAAC,EAAE;IACxD;EACF;AAEA,WAASnC,gBAAgB9B,QAAgB;AACvC,QAAIA,WAAUH,QAAW;AACvB,YAAM,IAAImE,YAAY,uBAAuBC,MAAM,CAAC,EAAE;IACxD;EACF;AAEA,WAAS9D,mBAAmB;AAC1B,QAAIJ,IAAIP,KAAKI,QAAQ;AACnB,YAAM,IAAIoE,YAAY,yBAAyBC,MAAM,CAAC,EAAE;IAC1D;EACF;AAEA,WAASV,YAAY1C,OAAe;AAClC,QAAI,CAAC6C,QAAQlE,KAAKc,WAAWP,CAAC,CAAC,GAAG;AAChC,YAAMoE,WAAW3E,KAAK4C,MAAMvB,OAAOd,CAAC;AACpC,YAAM,IAAIiE,YAAY,mBAAmBG,QAAQ,wBAAwBF,MAAM,CAAC,EAAE;IACpF;EACF;AAEA,WAASZ,oBAAoB;AAC3B,QAAI7D,KAAKc,WAAWP,CAAC,MAAMuC,iBAAiB;AAC1C,YAAM,IAAI0B,YAAY,8BAA8BC,MAAM,CAAC,EAAE;IAC/D;EACF;AAEA,WAASjD,yBAAyB;AAChC,UAAM,IAAIgD,YAAY,8BAA8BC,MAAM,CAAC,EAAE;EAC/D;AAEA,WAASzC,kBAAkBV,KAAasD,MAAa;AACnD,UAAM,IAAIJ,YAAY,kBAAkBlD,GAAG,6BAA6BsD,IAAG,EAAE;EAC/E;AAEA,WAAS3C,8BAA8B;AACrC,UAAM,IAAIuC,YAAY,mDAAmDC,MAAM,CAAC,EAAE;EACpF;AAEA,WAASjC,8BAA8B;AACrC,UAAM,IAAIgC,YAAY,2CAA2CC,MAAM,CAAC,EAAE;EAC5E;AAEA,WAASb,sBAAsBX,MAAc;AAC3C,UAAM,IAAIuB,YAAY,sBAAsBvB,IAAI,KAAK2B,IAAI,CAAC,EAAE;EAC9D;AAEA,WAASlB,4BAA4BrC,OAAe;AAClD,UAAMwD,QAAQ7E,KAAK4C,MAAMvB,OAAOA,QAAQ,CAAC;AACzC,UAAM,IAAImD,YAAY,6BAA6BK,KAAK,KAAKD,IAAI,CAAC,EAAE;EACtE;AAEA,WAASlD,2BAA2B;AAClC,UAAM,IAAI8C,YAAY,mCAAmCI,IAAI,CAAC,EAAE;EAClE;AAEA,WAASnB,6BAA6BpC,OAAe;AACnD,UAAMwD,QAAQ7E,KAAK4C,MAAMvB,OAAOA,QAAQ,CAAC;AACzC,UAAM,IAAImD,YAAY,8BAA8BK,KAAK,KAAKD,IAAI,CAAC,EAAE;EACvE;AAGA,WAASA,MAAc;AACrB,WAAO,eAAerE,CAAC;EACzB;AAEA,WAASuE,MAAc;AACrB,WAAOvE,IAAIP,KAAKI,SAAS,YAAYJ,KAAKO,CAAC,CAAC,MAAM;EACpD;AAEA,WAASkE,QAAgB;AACvB,WAAO,GAAGK,IAAI,CAAC,IAAIF,IAAI,CAAC;EAC1B;AACF;AAEA,SAAS/B,aAAakC,MAAuB;AAC3C,SAAOA,SAASC,aAAaD,SAASE,eAAeF,SAASG,WAAWH,SAASI;AACpF;AAEA,SAAS/B,MAAM2B,MAAuB;AACpC,SACGA,QAAQf,YAAYe,QAAQK,YAC5BL,QAAQM,kBAAkBN,QAAQO,kBAClCP,QAAQQ,kBAAkBR,QAAQS;AAEvC;AAEA,SAAStB,QAAQa,MAAuB;AACtC,SAAOA,QAAQf,YAAYe,QAAQK;AACrC;AAEA,SAASnB,eAAec,MAAuB;AAC7C,SAAOA,QAAQU,WAAWV,QAAQK;AACpC;AAEO,SAASzB,uBAAuBoB,MAAuB;AAC5D,SAAOA,QAAQ,MAAQA,QAAQ;AACjC;AAEO,SAAShD,YAAY2D,GAAYC,GAAqB;AAC3D,MAAID,MAAMC,GAAG;AACX,WAAO;EACT;AAEA,MAAIC,MAAMC,QAAQH,CAAC,KAAKE,MAAMC,QAAQF,CAAC,GAAG;AACxC,WAAOD,EAAEtF,WAAWuF,EAAEvF,UAAUsF,EAAEI,MAAM,CAACC,MAAMC,UAAUjE,YAAYgE,MAAMJ,EAAEK,KAAK,CAAC,CAAC;EACtF;AAEA,MAAIC,SAASP,CAAC,KAAKO,SAASN,CAAC,GAAG;AAC9B,UAAMO,OAAO,CAAC,GAAG,oBAAIC,IAAI,CAAC,GAAGxE,OAAOuE,KAAKR,CAAC,GAAG,GAAG/D,OAAOuE,KAAKP,CAAC,CAAC,CAAC,CAAC;AAChE,WAAOO,KAAKJ,MAAOxE,SAAQS,YAAY2D,EAAEpE,GAAG,GAAGqE,EAAErE,GAAG,CAAC,CAAC;EACxD;AAEA,SAAO;AACT;AAEA,SAAS2E,SAASzF,OAAkD;AAClE,SAAO,OAAOA,UAAU,YAAYA,UAAU;AAChD;AAGA,IAAM2C,mBAA0C;EAC9C,KAAK;EACL,MAAM;EACN,KAAK;EACLwC,GAAG;EACHS,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;;AAEL;AAEA,IAAMvD,gBAAgB;AACtB,IAAMjC,mBAAmB;AACzB,IAAMI,mBAAmB;AACzB,IAAMgB,qBAAqB;AAC3B,IAAME,qBAAqB;AAC3B,IAAM2C,YAAY;AAClB,IAAMC,cAAc;AACpB,IAAMC,UAAU;AAChB,IAAMC,aAAa;AACnB,IAAMrC,kBAAkB;AACxB,IAAMwB,WAAW;AACjB,IAAMR,YAAY;AAClB,IAAME,WAAW;AACjB,IAAMyB,UAAU;AAChB,IAAML,WAAW;AACjB,IAAMb,YAAY;AAClB,IAAMJ,UAAU;AAChB,IAAMO,YAAY;AACX,IAAMW,iBAAiB;AACvB,IAAME,iBAAiB;AACvB,IAAMlB,iBAAiB;AACvB,IAAMD,iBAAiB;AACvB,IAAMkB,iBAAiB;AACvB,IAAME,iBAAiB;;;ICjWjB,oBAAA,YAAU;EAerB,YAAmB,EAAC,SAAS,WAAU,GAAmB;AAN1D,8CAA6C,CAAA;AAEpC;AACA;AACA;AAGP,UAAMgB,UAAS,KAAK,UAAS,EAAG;AAEhC,QAAI,CAACA,QAAO,oBAAoB,CAAC,QAAQ,aAAa;AACpD,YAAM,IAAIC,wBACR,gDAAgD;IAEpD;AAEA,QAAI,YAAY;AACd,YAAM,UACJ,eAAeD,QAAO,aAClB,mEAAmE,UAAU,KAC7E,8CAA8CA,QAAO,UAAU,SAAS,UAAU;AAExF,aAAOA,OAAM,EAAE,MAAM,OAAO;IAC9B;AAEA,UAAM,4BACJA,QAAO,uBAAuBA,QAAO;AAEvC,SAAK,UAAU;AACf,SAAK,aAAa,cAAcA,QAAO;AACvC,SAAK,SAAS,yBAAyB;MACrC,QAAQA,QAAO;MACf,aAAa,QAAQ;MACrB,YAAY,cAAcA,QAAO;MACjC,aAAaA,QAAO,mBAChB,4BACA,QAAQ;MACZ,gBAAgB;MAChB,QAAQ,oBAAoBA,OAAM;MAClC,iBAAiB,aAAaA,OAAM;MACpC,kBAAkB,KAAK,UAAS,EAAG;MACnC,aAAa,KAAK,UAAS,EAAG;MAC9B,WAAWA,QAAO;IACnB,CAAA;EACH;;;;EAKO,MAAM,IAAa,QAAwB;AAChD,WAAO,KAAK,QAAW,EAAC,QAAQ,OAAO,KAAK,GAAG,OAAM,CAAC;EACxD;;;;EAKO,MAAM,KAAc,QAAyB;AAClD,WAAO,KAAK,QAAW,EAAC,QAAQ,OAAO,MAAM,GAAG,OAAM,CAAC;EACzD;;;;EAKO,MAAM,IAAa,QAAwB;AAChD,WAAO,KAAK,QAAW,EAAC,QAAQ,OAAO,KAAK,GAAG,OAAM,CAAC;EACxD;;;;EAKO,MAAM,OAAgB,QAA2B;AACtD,WAAO,KAAK,QAAW,EAAC,QAAQ,OAAO,QAAQ,GAAG,OAAM,CAAC;EAC3D;EAEU,MAAM,QACd,QAAqB;;AAErB,UAAM,gBAAgB;MACpB,SAAS;QACP,GAAG,OAAO;QACV,GAAI,OAAO,OAAO,EAAC,gBAAgB,OAAO,KAAK,SAAQ,EAAE,IAAI,CAAA;MAC9D;MACD,SAAS,OAAO,QAAQ,OAAO,QAAQ,IAAI;MAC3C,cAAc,OAAO;;AAGvB,QAAI;AACJ,YAAQ,OAAO,QAAM;MACnB,KAAK,OAAO;AACV,mBAAW,MAAM,KAAK,OAAO,IAAI,OAAO,MAAM,aAAa;AAC3D;MACF,KAAK,OAAO;AACV,mBAAW,MAAM,KAAK,OAAO,IAAI,OAAO,MAAM;UAC5C,GAAG;UACH,MAAM,OAAO;QACd,CAAA;AACD;MACF,KAAK,OAAO;AACV,mBAAW,MAAM,KAAK,OAAO,KAAK,OAAO,MAAM;UAC7C,GAAG;UACH,MAAM,OAAO;QACd,CAAA;AACD;MACF,KAAK,OAAO;AACV,mBAAW,MAAM,KAAK,OAAO,OAAO,OAAO,MAAM,aAAa;AAC9D;MACF;AACE,cAAM,IAAIE,oBACR,+BAA+B,OAAO,MAAM,GAAG;;AAIrD,UAAM,aAAqB,MAAM,SAAS,KAAI;AAG9C,UAAM,OACJ,OAAO,WAAW,OAAO,UAAU,eAAe,KAC9C,CAAA,IACA,KAAK,6BAA6B,UAAU;AAElD,UAAM,kBAAkB,oBACtB,OAAO,YAAY,SAAS,QAAQ,QAAO,CAAE,CAAC;AAGhD,QAAI,CAAC,SAAS,IAAI;AAChB,yBAAmB,OAAO,OAAO,SAAS,KAAK,GAAG,QAAQ;IAC5D;AAEA,UAAM,gBAAsC;MAC1C;MACA,SAAS;;AAGX,UAAM,KAAK,gBACT;MACE,QAAQ,OAAO;MACf,KAAK,OAAO;MACZ,SAAS,cAAc;MACvB,MAAM,OAAO,OAAO,KAAK,UAAU,OAAO,IAAI,IAAI;OAEpD,aAAa;AAGf,UAAM,OAAO,SAAS,QAAQ,IAAI,MAAM;AACxC,QAAI,SAAS,QAAW;AACtB,YAAM,WAAqB;QACzB,SAAO,YAAO,UAAP,mBAAc,UACjB,YAAO,UAAP,mBAAc,MAAM,aACpB,YAAW;;AAGjB,UAAI,MAAM;AACR,cAAM,QAAQ,KAAK,MAAM,IAAI;AAE7B,mBAAWC,SAAQ,OAAO;AACxB,gBAAM,aAAaA,MAAK,MAAM,YAAW,kBAAkB;AAC3D,cAAI,CAAC,YAAY;AACf;UACF;AAEA,gBAAM,UAAU,WAAW,CAAC;AAC5B,gBAAM,UAAU,IAAI,IAAI,WAAW,CAAC,CAAC;AACrC,gBAAM,aAAa,QAAQ,aAAa,IAAI,QAAQ;AACpD,gBAAM,gBAAgB,QAAQ,aAAa,IAAI,WAAW;AAE1D,cAAI,CAAC,SAAS,UAAU,YAAY;AAClC,qBAAS,SAAS,WAAW,MAAM,GAAG;UACxC;AAEA,cAAI,eAAe;AACjB,oBAAQ,SAAO;cACb,KAAK;AACH,yBAAS,kBAAkB,WAAW,CAAC;AACvC,yBAAS,WAAW,KAAK,mBAAmB,WAAW,CAAC,CAAC;AACzD;cACF,KAAK;AACH,yBAAS,cAAc,WAAW,CAAC;AACnC,yBAAS,WAAW,KAAK,mBAAmB,WAAW,CAAC,CAAC;AACzD;;UAEN;QACF;MACF;AAEA,oBAAc,WAAW;IAC3B;AAEA,WAAO;EACT;EAEQ,YAAS;AACf,WAAO,KAAK;EACd;;;;;EAMQ,6BAA6B,YAAkB;AAErD,UAAM,SAAsB,MAAM,UAAU;AAG5C,UAAM,eAAe,CAAC,OAAY,QAAqB;AACrD,UAAI,UAAU,QAAQ,UAAU,QAAW;AACzC,eAAO;MACT;AAGA,UAAI,SAAS,MAAM,qBAAqB,MAAM;AAC5C,cAAM,YAAY,OAAO,IAAI,YAAW;AAExC,YAAI,aAAa,QAAQ,SAAS,SAAS,KAAK,GAAG;AACjD,iBAAO,MAAM,SAAQ;QACvB;AAGA,eAAO,OAAO,MAAM,KAAK;MAC3B;AAGA,UAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,cAAM,aAAa,OAAO,IAAI,YAAW,EAAG,SAAS,MAAM;AAC3D,eAAO,MAAM,IAAI,CAAC,SAAQ;AAExB,cAAI,cAAc,QAAQ,KAAK,qBAAqB,MAAM;AACxD,mBAAO,KAAK,SAAQ;UACtB;AACA,iBAAO,aAAa,IAAI;QAC1B,CAAC;MACH;AAGA,UAAI,OAAO,UAAU,UAAU;AAC7B,cAAM,SAAc,CAAA;AACpB,mBAAW,UAAU,OAAO;AAC1B,cAAI,OAAO,UAAU,eAAe,KAAK,OAAO,MAAM,GAAG;AACvD,mBAAO,MAAM,IAAI,aAAa,MAAM,MAAM,GAAG,MAAM;UACrD;QACF;AACA,eAAO;MACT;AAEA,aAAO;IACT;AAEA,WAAO,aAAa,MAAM;EAC5B;EAEQ,mBAAmB,YAAkB;AAC3C,UAAM,UAAU;AAEhB,UAAM,MAAM,IAAI,IAAI,UAAU;AAC9B,UAAM,OAAO,IAAI,SAAS,QAAQ,IAAI,OAAO,OAAO,GAAG,IAAI;AAC3D,WAAO;MACL;MACA,OAAO,OAAO,YAAY,IAAI,aAAa,QAAO,CAAE;;EAExD;EAEQ,MAAM,gBACZC,UACA,UAA2B;AAE3B,UAAMJ,UAAS,KAAK,UAAS,EAAG;AAEhC,UAAM,oBAAoB,UACxB,SAAS,SACT,iCAAiC;AAEnC,QAAI,mBAAmB;AACrB,YAAM,cAAoC;QACxC,SAAS;QACT,MAAMI,SAAQ;;AAGhB,UAAIA,SAAQ,MAAM;AAEhB,oBAAY,OAAO,GAAIA,SAAQ,KAAgB,UAAU,GAAG,GAAG,CAAC;MAClE;AAEA,YAAM,UAAU,MAAM,iBACpBJ,QAAO,cACP,KAAK,UAAU,WAAW,GAC1B,WAAW,GAAG;AAGhB,UACE,CAAC,OAAO,KAAK,KAAK,kBAAkB,EAAE,SAAS,OAAO,KACtD,KAAK,IAAG,IAAK,KAAK,mBAAmB,OAAO,KAC1C,YAAW,yBACb;AACA,aAAK,mBAAmB,OAAO,IAAI,KAAK,IAAG;AAE3C,cAAM,QAAQ,IAAI,MAAK,EAAG;AAC1B,cAAM,UAAU,2BAA0B,oBAAI,KAAI,GAAG,eAAc,CAAE,MAAM,KAAK,UAC9E,WAAW,CACZ,qBAAqB,KAAK;AAC3B,cAAM,OAAOA,OAAM,EAAE,QAAQ,OAAO;MACtC;IACF;EACF;;AApTO,cADI,aACG;AACP,cAFI,aAEG;AAEd,cAJW,aAIJ,sBAAqB;AAC5B,cALW,aAKJ,iBAAgB;AACvB,cANW,aAMJ,mBAAkB;AAEzB,cARW,aAQK,2BAA0B;IAR/B;AAwTP,SAAU,gBACd,QAA6B;AAE7B,QAAM,EAAC,QAAAA,SAAQ,YAAW,IAAI;EAE9B,MAAM,sBAAsB,WAAU;;AAC7B,gBADH,eACU,UAASA;AAChB,gBAFH,eAEU,eAAc,gBAAgB,SAAY,OAAO;AAGjE,UAAQ,eAAe,eAAe,QAAQ;IAC5C,OAAO;EACR,CAAA;AAED,SAAO;AACT;;;IC5Va,yBAAgB;EAO3B,YAAY,QAA2B;AAJ9B;AACA;AACA;AAGP,UAAMK,UAAS,KAAK,gBAAe,EAAG;AAEtC,QAAI,CAACA,QAAO,oBAAoB,CAAC,OAAO,QAAQ,aAAa;AAC3D,YAAM,IAAIC,wBACR,mDAAmD;IAEvD;AAEA,QAAI,OAAO,YAAY;AACrB,YAAM,UACJ,OAAO,eAAeD,QAAO,aACzB,yEAAyE,OAAO,UAAU,KAC1F,oDAAoDA,QAAO,UAAU,SAAS,OAAO,UAAU;AAErG,aAAOA,OAAM,EAAE,MAAM,OAAO;IAC9B;AAEA,QAAI;AACJ,QAAIA,QAAO,kBAAkB;AAC3B,oBAAcA,QAAO;AAErB,UAAI,CAAC,aAAa;AAChB,cAAM,IAAI,wBACR,qGAAqG;MAEzG;IACF,OAAO;AACL,oBAAc,OAAO,QAAQ;AAE7B,UAAI,CAAC,aAAa;AAChB,cAAM,IAAI,wBAAwB,+BAA+B;MACnE;IACF;AAEA,SAAK,UAAU,OAAO;AACtB,SAAK,aAAa,OAAO;AACzB,SAAK,SAAS,0BAA0B;MACtC,oBAAoB;MACpB,YAAY,KAAK,cAAcA,QAAO;MACtC,aAAa,KAAK,QAAQ;MAC1B,gBAAgB;MAChB,QAAQ,oBAAoBA,OAAM;MAClC,YAAY,aAAaA,OAAM;IAChC,CAAA;EACH;EAEO,MAAM,MACX,QAAqB;AAErB,WAAO,KAAK,gBAAe,EAAG,MAAM,EAAE,WACpC,UACA,kOACyJ;AAG3J,QACG,OAAO,OAAO,SAAS,YAAY,OAAO,KAAK,WAAW,KAC3D,OAAO,QAAQ,OAAO,IAAI,EAAE,WAAW,GACvC;AACA,YAAM,IAAIC,wBAAsC,gBAAgB;IAClE;AAEA,QAAI;AACJ,QAAI;AACJ,QAAI,OAAO,OAAO,SAAS,UAAU;AACnC,kBAAY,OAAO;IACrB,OAAO;AACL,kBAAY,OAAO,KAAK;AACxB,kBAAY,OAAO,KAAK;IAC1B;AAEA,UAAM,UAAU,OAAO,YACrB,OAAO,SAAQ,iCAAQ,iBAAgB,CAAA,CAAE,EAAE,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM;MAC/D;MACA,MAAM,QAAQ,KAAK,IAAI,MAAM,KAAK,IAAI,IAAI,MAAM,SAAQ;IACzD,CAAA,CAAC;AAGJ,UAAM,WAAW,MAAM,KAAK,QAAW,WAAW;MAChD;MACA,SAAS,OAAO,QAAQ,OAAO,QAAQ,IAAI;MAC3C;IACD,CAAA;AAED,WAAO,EAAC,MAAM,UAAe,SAAS,CAAA,EAAE;EAC1C;EAEO,MAAM,QAKX,WACA,SAAoD;AAIpD,UAAM,WAAW,MAAM,KAAK,OAAO,QAAsB,WAAW;MAClE,YAAY,KAAK,cAAc,KAAK,gBAAe,EAAG,OAAO;MAC7D,GAAI;IACL,CAAA;AAED,QAAI,SAAS,QAAQ;AACnB,YAAM,gBAAgB,SAAS,OAAO;AAEtC,yBAAmB,YAAW,mCAAS,YAAW,KAAK,GAAG,aAAa;IACzE;AAEA,WAAO;EACT;EAEQ,kBAAe;AACrB,WAAO,KAAK;EACd;AACD;AAzHQ,cADI,kBACG;AA2HV,SAAU,sBAAsB,QAAgC;AACpE,QAAM,EAAC,QAAAD,QAAM,IAAI;EACjB,MAAM,4BAA4B,iBAAgB;;AACzC,gBADH,qBACU,UAASA;AAGzB,UAAQ,eAAe,qBAAqB,QAAQ;IAClD,OAAO;EACR,CAAA;AAED,SAAO;AACT;;;AC7JM,SAAU,aAAaE,SAAuB;AAClD,SAAO,OAAO,EAAC,SAAS,QAAO,MAAK;AAClC,QAAI,CAAC,QAAQ,aAAa;AACxB,YAAM,IAAIC,eACR,gDAAgD;IAEpD;AAEA,UAAMC,iBAAgB,mBAAmB,EAAC,QAAAF,QAAM,CAAC;AACjD,UAAM,SAAS,IAAIE,eAAc,EAAC,QAAO,CAAC;AAE1C,QAAI;AACJ,QAAI;AACJ,QAAI,OAAO,YAAY,UAAU;AAC/B,cAAQ;IACV,OAAO;AACL,cAAQ,QAAQ;AAChB,kBAAY,QAAQ;IACtB;AAEA,QAAI,CAAC,OAAO;AACV,YAAM,IAAIC,wBAAsC,gBAAgB;IAClE;AAEA,UAAM,WAAW,MAAM,OAAO,QAAQ,OAAO,EAAC,UAAS,CAAC;AAExD,WAAO,EAAC,MAAM,UAAU,SAAS,CAAA,EAAE;EACrC;AACF;;;ACzBM,SAAU,cAAcC,SAAuB;AACnD,SAAO;;IAEL,MAAM,gBAAgB,EAAC,QAAAA,QAAM,CAAC;IAC9B,SAAS,mBAAmB,EAAC,QAAAA,QAAM,CAAC;IACpC,YAAY,sBAAsB,EAAC,QAAAA,QAAM,CAAC;IAC1C,cAAc,aAAaA,OAAM;;AAErC;;;ACjBc,IAAO,iBAAP,MAAO,gBAAc;EASjC,cAAA;AAFA;AAGE,SAAK,iBAAiB,IAAI,gBAAe;EAC3C;EAVA,OAAO,UAAU,eAAmC;AAClD,QAAI,CAAC,iBAAiB,OAAO,KAAK,aAAa,EAAE,WAAW;AAAG,aAAO;AAEtE,WAAO,IAAI,gBAAc,EAAG,OAAO,aAAa,EAAE,UAAS;EAC7D;EAQA,OAAO,eAAkC;AACvC,WAAO,QAAQ,aAAa,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAChD,KAAK,IAAI,KAAK,KAAK,CAAC;AAEtB,WAAO;EACT;EAEA,IAAI,KAAa,OAAU;AACzB,QAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,WAAK,SAAS,KAAK,KAAK;IAC1B,YAAW,+BAAO,iBAAgB,QAAQ;AACxC,WAAK,UAAU,KAAK,KAAK;IAC3B,OAAO;AACL,WAAK,UAAU,KAAK,KAAK;IAC3B;EACF;EAEA,SAAS,KAAa,OAA0B;AAC9C,UAAM,QAAQ,CAAC,eACb,KAAK,eAAe,OAAO,GAAG,GAAG,MAAM,GAAG,UAAU,EAAE,CAAC;EAE3D;EAEA,UAAU,KAAa,OAAa;AAClC,WAAO,QAAQ,KAAK,EAAE,QACpB,CAAC,CAAC,OAAO,UAAU,MAAgC;AACjD,WAAK,eAAe,OAAO,GAAG,GAAG,IAAI,KAAK,KAAK,GAAG,UAAU,EAAE;IAChE,CAAC;EAEL;EAEA,UAAU,KAAa,OAAsB;AAC3C,SAAK,eAAe,OAAO,KAAK,GAAG,KAAK,EAAE;EAC5C;EAEA,UAAU,mBAAmB,OAAK;AAChC,UAAM,cAAc,KAAK,eAAe,SAAQ;AAChD,WAAO,mBAAmB,cAAc,IAAI,WAAW;EACzD;AACD;;;IC7CY,cAA2B,CAAC,MAAM,SAAQ;AACrD,MAAI,OAAO,SAAS,OAAO,MAAM;AAC/B,UAAM,MAAM,IAAI,YAAW;AAC3B,UAAM,QAAQ,IAAI,OAAO,KAAK,UAAU,IAAI,CAAC;AAC7C,UAAM,QAAQ,IAAI,OAAO,KAAK,UAAU,IAAI,CAAC;AAE7C,QAAI,MAAM,WAAW,MAAM,QAAQ;AACjC,aAAO,gBAAgB,OAAO,KAAK;IACrC;EACF,OAAO;AACL,UAAM,IAAIC,iBACR,mCAAmC,OAAO,IAAI,QAAQ,OAAO,IAAI,EAAE;EAEvE;AACA,SAAO;AACT;AAGA,SAAS,gBAAgB,MAAmB,MAAiB;AAC3D,QAAM,QAAQ,IAAI,WAAW,IAAI;AACjC,QAAM,QAAQ,IAAI,WAAW,IAAI;AACjC,MAAI,MAAM;AACV,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,WAAO,MAAM,CAAC,IAAI,MAAM,CAAC;EAC3B;AACA,SAAO,QAAQ;AACjB;;;IC/BY;CAAZ,SAAYC,qBAAkB;AAC5B,EAAAA,oBAAA,MAAA,IAAA;AACA,EAAAA,oBAAA,SAAA,IAAA;AACA,EAAAA,oBAAA,oBAAA,IAAA;AACF,GAJY,uBAAA,qBAAkB,CAAA,EAAA;AAavB,IAAM,wBAAwB;EACnC,aAAa;EACb,aAAa;EACb,aAAa;;;;ACKf,IAAM,+CAA+C;AAerD,SAAS,uBAAuB,OAAgB;AAC9C,QAAM,iBAAiB,IAAI,eAAc;AACzC,SAAO,KAAK,KAAK,EACd,KAAK,CAAC,MAAM,SAAS,KAAK,cAAc,IAAI,CAAC,EAC7C,QAAQ,CAAC,QAAgB,eAAe,IAAI,KAAK,MAAM,GAAG,CAAC,CAAC;AAE/D,SAAO,eAAe,UAAU,IAAI;AACtC;AAEA,SAAS,0BAA0B,OAAgB;AACjD,SAAO,OAAO,QAAQ,KAAK,EACxB,KAAK,CAAC,CAAC,IAAI,GAAG,CAAC,IAAI,MAAM,KAAK,cAAc,IAAI,CAAC,EACjD,OAAO,CAAC,KAAK,CAAC,KAAK,KAAK,MAAK;AAC5B,WAAO,GAAG,GAAG,GAAG,GAAG,IAAI,MAAM,QAAQ,KAAK,IAAI,MAAM,KAAK,GAAG,IAAI,KAAK;EACvE,GAAG,EAAE;AACT;AAEM,SAAU,kBAAkBC,SAAuB;AACvD,SAAO,OACL,QACA,WAAyB,YACN;AACnB,UAAM,EAAC,MAAM,WAAW,GAAG,MAAK,IAAI;AAEpC,UAAM,cACJ,aAAa,UACT,uBAAuB,KAAK,IAC5B,0BAA0B,KAAK;AAErC,WAAO,iBAAiBA,QAAO,cAAc,aAAa,WAAW,GAAG;EAC1E;AACF;AAEM,SAAU,aAAaA,SAAuB;AAClD,SAAO,OACL,OACA,EAAC,SAAQ,IAA8B,EAAC,UAAU,QAAO,MACrC;AACpB,QAAI,aAAa,WAAW,CAAC,MAAM,MAAM;AACvC,YAAM,IAAIC,iBACR,uCAAuC;IAE3C;AAEA,QAAI,aAAa,cAAc,CAAC,MAAM,WAAW;AAC/C,YAAM,IAAIA,iBACR,2CAA2C;IAE/C;AAEA,0BAAsB,KAAK;AAE3B,UAAM,OAAO,aAAa,aAAa,MAAM,YAAY,MAAM;AAC/D,UAAM,YAAY,MAAM,kBAAkBD,OAAM,EAAE,OAAO,QAAQ;AAEjE,WAAO,YAAY,MAAgB,SAAS;EAC9C;AACF;AAEO,eAAe,mBACpBA,SACA,MACA,MACA,QAAkB;AAElB,QAAM,YAAY,MAAM,iBAAiBA,QAAO,cAAc,MAAM,MAAM;AAE1E,SAAO,YAAY,MAAM,SAAS;AACpC;SAEgB,sBAAmB;AACjC,SAAO,KAAK,MAAM,KAAK,IAAG,IAAK,GAAI;AACrC;AAEM,SAAU,+BAA+BA,SAAuB;AACpE,SAAO,eAAe,wBAAwB,EAC5C,MACA,SACA,GAAG,YAAW,GACC;AACf,UAAME,WAAU,MAAM,uBAAuB,WAAW;AACxD,QAAI,CAAC,QAAQ,QAAQ;AACnB,aAAO,KAAK,sBAAsB,aAAa,MAAMF,OAAM;IAC7D;AACA,UAAM,OAAO,UAAUE,SAAQ,SAAS,cAAc,IAAI;AAC1D,QAAI,CAAC,MAAM;AACT,aAAO,KAAK,sBAAsB,aAAa,MAAMF,OAAM;IAC7D;AACA,UAAM,YAAY,MAAM,mBACtBA,SACA,SACA,MACA,WAAW,MAAM;AAEnB,QAAI,CAAC,WAAW;AACd,aAAO,KAAK,sBAAsB,aAAa,MAAMA,OAAM;IAC7D;AAEA,WAAO,QAAQ,MAAMA,OAAM;EAC7B;AACF;AAEA,SAAS,sBAAsB,OAAgB;AAC7C,MACE,KAAK,IAAI,oBAAmB,IAAK,OAAO,MAAM,SAAS,CAAC,IACxD,8CACA;AACA,UAAM,IAAIC,iBACR,kDAAkD;EAEtD;AACF;AAEA,eAAe,KACb,QACA,MACAD,SAAuB;AAEvB,QAAMG,OAAM,OAAOH,OAAM;AACzB,QAAMG,KAAI,MAAM,GAAG,IAAI,yBAAyB,EAAC,OAAM,CAAC;AAExD,SAAO;IACL,OAAO;IACP;;AAEJ;AAEA,eAAe,QACb,MACAH,SAAuB;AAEvB,QAAMG,OAAM,OAAOH,OAAM;AACzB,QAAMG,KAAI,MAAM,GAAG,IAAI,mBAAmB;AAE1C,SAAO;IACL,OAAO;;AAEX;;;AC/KM,SAAU,WAAW,MAAY;AACrC,SAAO,KAAK,IAAI;AAClB;;;ACDM,SAAU,wBAAwB,cAAoB;AAC1D,QAAM,UAAU,eAAe,YAAY;AAE3C,QAAM,iBAAiB,QAAQ,MAAM,GAAG,EAAE,CAAC,MAAM;AAEjD,MAAI,CAAC,gBAAgB;AACnB,WAAO;EACT;AAEA,QAAM,QAAQ,IAAI,OAAO,0BAA0B;AACnD,QAAM,UAAU,QAAQ,MAAM,KAAK;AAEnC,MAAI,WAAW,QAAQ,WAAW,GAAG;AACnC,UAAM,WAAW,QAAQ,CAAC;AAC1B,UAAM,YAAY,QAAQ,SAAS,iBAAiB;AACpD,UAAM,aAAa,QAAQ,SAAS,iBAAiB;AAErD,QAAI,WAAW;AACb,aAAO,wBAAwB,OAAO;IACxC,WAAW,YAAY;AACrB,aAAO,yBAAyB,OAAO;IACzC,OAAO;AACL,aAAO,GAAG,QAAQ;IACpB;EACF,OAAO;AACL,WAAO;EACT;AACF;AAGM,SAAU,wBAAwB,gBAAsB;AAC5D,QAAM,UAAU,eAAe,cAAc;AAC7C,QAAM,QAAQ,IAAI,OAAO,yBAAyB;AAClD,QAAM,UAAU,QAAQ,MAAM,KAAK;AAEnC,MAAI,WAAW,QAAQ,WAAW,GAAG;AACnC,UAAM,WAAW,QAAQ,CAAC;AAC1B,WAAO,2BAA2B,QAAQ;EAC5C,OAAO;AACL,UAAM,YAAY,QAAQ,SAAS,UAAU;AAC7C,UAAM,aAAa,QAAQ,SAAS,UAAU;AAC9C,QAAI,WAAW;AACb,aAAO,wBAAwB,OAAO;IACxC,WAAW,YAAY;AACrB,aAAO,yBAAyB,OAAO;IACzC,OAAO;AACL,aAAO;IACT;EACF;AACF;AAEA,SAAS,wBAAwB,cAAoB;AACnD,QAAM,YAAY,IAAI,OAAO,4CAA4C;AACzE,QAAM,cAAc,aAAa,MAAM,SAAS;AAEhD,MAAI,eAAe,YAAY,WAAW,GAAG;AAC3C,UAAM,UAAU,YAAY,CAAC;AAC7B,UAAM,WAAW,YAAY,CAAC;AAC9B,WAAO,GAAG,QAAQ,YAAY,OAAO;EACvC,OAAO;AACL,WAAO;EACT;AACF;AAEA,SAAS,yBAAyB,cAAoB;AACpD,QAAM,aAAa,IAAI,OAAO,+BAA+B;AAC7D,QAAM,eAAe,aAAa,MAAM,UAAU;AAElD,MAAI,gBAAgB,aAAa,WAAW,GAAG;AAC7C,UAAM,WAAW,aAAa,CAAC;AAC/B,WAAO,GAAG,QAAQ;EACpB,OAAO;AACL,WAAO;EACT;AACF;AAEA,SAAS,wBAAwB,gBAAsB;AACrD,QAAM,YAAY,IAAI,OAAO,oCAAoC;AACjE,QAAM,cAAc,eAAe,MAAM,SAAS;AAElD,MAAI,eAAe,YAAY,WAAW,GAAG;AAC3C,UAAM,WAAW,YAAY,CAAC;AAC9B,UAAM,UAAU,YAAY,CAAC;AAC7B,WAAO,aAAa,OAAO,UAAU,QAAQ;EAC/C,OAAO;AACL,WAAO;EACT;AACF;AAEA,SAAS,yBAAyB,gBAAsB;AACtD,QAAM,aAAa,IAAI,OAAO,oBAAoB;AAClD,QAAM,eAAe,eAAe,MAAM,UAAU;AAEpD,MAAI,gBAAgB,aAAa,WAAW,GAAG;AAC7C,UAAM,WAAW,aAAa,CAAC;AAC/B,WAAO,wBAAwB,QAAQ;EACzC,OAAO;AACL,WAAO;EACT;AACF;AACA,SAAS,eAAe,KAAW;AACjC,SAAO,IAAI,QAAQ,gBAAgB,EAAE,EAAE,QAAQ,OAAO,EAAE;AAC1D;;;ACjGM,SAAU,aAAaC,SAAuB;AAClD,SAAO,CAAC,MAAc,iBAAiB,UAAwB;AAC7D,QAAI,UAAU;AACd,UAAM,eAAe;MACnB;MACA;MACA;MACA;;AAEF,QAAIA,QAAO,mBAAmB;AAC5B,mBAAa,KACX,GAAGA,QAAO,kBAAkB,IAAI,CAAC,UAC/B,OAAO,UAAU,WAAW,QAAQ,MAAM,MAAM,CACjD;IAEL;AAEA,UAAM,eAAe,IAAI,OACvB,iCAAiC,aAAa,KAAK,GAAG,CAAC,QAAQ;AAGjE,UAAM,iBAAiB,IAAI,OACzB,aAAa,aAAa,KAAK,GAAG,CAAC,sCAAsC;AAG3E,UAAM,iBAAiB,eAAe,KAAK,OAAO;AAClD,QAAI,gBAAgB;AAClB,gBAAU,wBAAwB,OAAO,KAAK;IAChD;AAEA,UAAM,gBAAgB,aAAa,KAAK,OAAO,IAAI,UAAU;AAC7D,QAAI,CAAC,iBAAiB,gBAAgB;AACpC,YAAM,IAAI,iBAAiB,gCAAgC;IAC7D;AAEA,WAAO;EACT;AACF;SAEgB,eAAY;AAC1B,SAAO,CAAC,MAAc,iBAAiB,UAAwB;AAC7D,UAAM,cAAc;AAEpB,QAAI,gBAAgB,YAAY,KAAK,IAAI,IAAI,OAAO;AACpD,QAAI,eAAe;AACjB,YAAM,EAAC,SAAQ,IAAI,IAAI,IAAI,WAAW,WAAW,aAAa,CAAC,EAAE;AAEjE,YAAM,eAAe;QACnB;QACA;QACA;QACA;QACA;;AAGF,YAAM,YAAY,IAAI,OAAO,OAAO,aAAa,KAAK,GAAG,CAAC,IAAI;AAC9D,UAAI,CAAC,UAAU,KAAK,QAAQ,GAAG;AAC7B,wBAAgB;MAClB;IACF;AACA,QAAI,CAAC,iBAAiB,gBAAgB;AACpC,YAAM,IAAI,iBAAiB,gCAAgC;IAC7D;AAEA,WAAO;EACT;AACF;;;IC1CY;CAAZ,SAAYC,WAAQ;AAClB,EAAAA,UAAA,MAAA,IAAA;AACA,EAAAA,UAAA,SAAA,IAAA;AACA,EAAAA,UAAA,YAAA,IAAA;AACF,GAJY,aAAA,WAAQ,CAAA,EAAA;;;ACzBd,SAAU,oBAAoBC,SAAuB;AACzD,SAAO,eAAe,aACpB,KACA,SAAqB;AAErB,UAAMC,OAAM,OAAOD,OAAM;AACzB,UAAM,QACJA,QAAO,OAAO,gBAAgBA,QAAO,OAAO,UAAU,YAAY;AAEpE,QAAI,OAAO;AACT,MAAAC,KAAI,MAAM,uBAAuB;QAC/B,SAAQ,mCAAS,WAAU;QAC3B;QACA,IAAI,mCAAS,SAAQ,EAAC,MAAM,mCAAS,KAAI;MAC1C,CAAA;IACH;AAEA,UAAM,WAAW,MAAM,cAAc,KAAK,OAAO;AAEjD,QAAI,OAAO;AACT,MAAAA,KAAI,MAAM,0BAA0B;QAClC,SAAQ,mCAAS,WAAU;QAC3B;QACA,QAAQ,SAAS;MAClB,CAAA;IACH;AAEA,WAAO;EACT;AACF;;;AChCO,IAAM,sBAAsB;AAC5B,IAAM,oBAAoB;;;SCDjB,QAAK;AACnB,QAAM,SAAS;AAEf,QAAM,QAAQ,OAAO,gBAAgB,IAAI,WAAW,MAAM,CAAC;AAE3D,QAAMC,SAAQ,MACX,IAAI,CAAC,SAAgB;AACpB,WAAO,OAAO;EAChB,CAAC,EACA,KAAK,EAAE;AAEV,SAAOA;AACT;;;ACPA,IAAM,mBAAmB;EACvB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;IAMW,gBAAA,SAAO;EAoJlB,YAAY,QAAqB;AA9BxB;;;;AAIF;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAGL,WAAO,OAAO,MAAM,MAAM;EAC5B;EArJO,OAAO,kBACZ,SACA,iBAAiB,OAAK;AAEtB,QAAI,CAAC,MAAM,QAAQ,OAAO,GAAG;AAC3B,YAAM,IAAI,eACR,8EAA8E;IAElF;AAEA,UAAM,MAAM,OAAO,YACjB,QACG,OAAO,CAAC,CAAC,MAAM,KAAK,MAAM,UAAU,QAAQ,UAAU,MAAS,EAE/D,IAAI,CAAC,CAAC,KAAK,KAAK,MAAK;AACpB,cAAQ,IAAI,YAAW,GAAE;QACvB,KAAK;AACH,iBAAO,CAAC,YAAY,KAAK;QAC3B,KAAK;AACH,iBAAO,CAAC,eAAe,KAAK;QAC9B,KAAK;AACH,iBAAO,CAAC,oBAAoB,KAAK;QACnC,KAAK;AACH,iBAAO,CAAC,UAAU,KAAK;QACzB,KAAK;AACH,iBAAO,CAAC,aAAa,KAAK;QAC5B,KAAK;AACH,iBAAO,CAAC,YAAY,KAAK;QAC3B,KAAK;AACH,iBAAO,CAAC,gBAAgB,KAAK;QAC/B,KAAK;AACH,iBAAO,CAAC,iBAAiB,KAAK;QAChC;AACE,iBAAO,CAAC,IAAI,YAAW,GAAI,KAAK;;IAEtC,CAAC,CAAC;AAGN,UAAM,cAAc,CAAA;AACpB,UAAM,mBAAmB;MACvB,iBAAiB,CAAA;;AAEnB,WAAO,QAAQ,GAAG,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAK;AAC3C,cAAQ,KAAG;QACT,KAAK;AACH,cAAI,OAAO,UAAU,UAAU;AAC7B,wBAAY,GAAG,IAAI,MAAM,SAAQ,EAAG,YAAW,MAAO;UACxD,WAAW,OAAO,UAAU,UAAU;AACpC,wBAAY,GAAG,IAAI,QAAQ,KAAK;UAClC,OAAO;AACL,wBAAY,GAAG,IAAI;UACrB;AACA;QACF,KAAK;AACH,sBAAY,GAAG,IAAI,MAAM,SAAQ;AACjC;QACF,KAAK;AACH,sBAAY,GAAG,IAAI,QAAQ,IAAI,KAAK,OAAO,KAAK,CAAC,IAAI;AACrD;QACF,KAAK;AACH,2BAAiB,gBAAgB,KAAK,OAAO,KAAK;AAClD;QACF,KAAK;AACH,cAAI,gBAAgB;AAClB,6BAAiB,gBAAgB,KAAK,OAAO,KAAK;AAClD;UACF;QACF,KAAK;AACH,cAAI,gBAAgB;AAClB,6BAAiB,gBAAgB,aAAa,OAAO,KAAK;AAC1D;UACF;QACF,KAAK;AACH,cAAI,gBAAgB;AAClB,6BAAiB,gBAAgB,YAAY,OAAO,KAAK;AACzD;UACF;QACF,KAAK;AACH,cAAI,gBAAgB;AAClB,6BAAiB,gBAAgB,QAAQ,OAAO,KAAK;AACrD;UACF;QACF,KAAK;AACH,cAAI,gBAAgB;AAClB,6BAAiB,gBAAgB,gBAAgB,QAAQ,KAAK;AAC9D;UACF;QACF,KAAK;AACH,cAAI,gBAAgB;AAClB,6BAAiB,gBAAgB,SAAS,OAAO,KAAK;AACtD;UACF;QACF,KAAK;AACH,cAAI,gBAAgB;AAClB,6BAAiB,gBAAgB,eAAe,QAAQ,KAAK;AAC7D;UACF;QACF,KAAK;AACH,cAAI,gBAAgB;AAClB,6BAAiB,gBAAgB,iBAAiB,QAAQ,KAAK;AAC/D;UACF;;QAEF;AACE,sBAAY,GAAG,IAAI;;IAEzB,CAAC;AACD,QAAI,YAAY,UAAU;AACxB,kBAAY,mBAAmB;IACjC;AACA,UAAM,UAAU,IAAI,SAAQ,WAAW;AACvC,WAAO;EACT;;;;;EA2CO,SACL,QACA,6BAA6B,KAAG;AAEhC,UAAM,iBAAiB,QAAQ,KAAK,WAAW;AAC/C,UAAM,oBAAoB,CAAC,KAAK,UAAU,0BAA0B;AACpE,UAAM,iBAAiB,KAAK,eAAe,MAAM;AACjD,WAAO,CAAC,kBAAkB,kBAAkB;EAC9C;;;;EAKO,eACL,QAAkD;AAElD,QAAI,OAAO,WAAW,aAAa;AACjC,aAAO;IACT;AAEA,WAAO,CAAC,KAAK,gBAAgB,MAAM;EACrC;;;;EAKO,gBAAgB,QAAsC;AAC3D,UAAM,iBACJ,kBAAkB,aAAa,SAAS,IAAI,WAAW,MAAM;AAC/D,UAAM,gBAAgB,IAAI,WAAW,KAAK,KAAK;AAE/C,WAAO,cAAc,IAAI,cAAc;EACzC;;;;EAKO,UAAU,6BAA6B,GAAC;AAC7C,WAAO,QACL,KAAK,WACH,KAAK,QAAQ,QAAO,IAAK,6BAA6B,KAAK,IAAG,CAAE;EAEtE;;;;EAKO,WAAQ;AACb,UAAM,SAAwB;MAC5B,IAAI,KAAK;MACT,MAAM,KAAK;MACX,OAAO,KAAK;MACZ,UAAU,KAAK;;AAGjB,QAAI,KAAK,OAAO;AACd,aAAO,QAAQ,KAAK;IACtB;AACA,QAAI,KAAK,SAAS;AAChB,aAAO,UAAU,KAAK;IACxB;AACA,QAAI,KAAK,aAAa;AACpB,aAAO,cAAc,KAAK;IAC5B;AACA,QAAI,KAAK,kBAAkB;AACzB,aAAO,mBAAmB,KAAK;IACjC;AACA,WAAO;EACT;;;;EAKO,OAAO,OAA0B;AACtC,QAAI,CAAC;AAAO,aAAO;AAEnB,UAAM,sBACJ,KAAK,OAAO,MAAM,MAClB,KAAK,SAAS,MAAM,QACpB,KAAK,UAAU,MAAM,SACrB,KAAK,aAAa,MAAM;AAE1B,QAAI,CAAC;AAAqB,aAAO;AAEjC,UAAM,QAAQ,KAAK,gBAAgB,IAAI;AACvC,UAAM,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE,MAAO,KAAK,KAAK,KAAK,CAAE;AAE7C,UAAM,QAAQ,MAAM,gBAAgB,IAAI;AACxC,UAAM,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE,MAAO,KAAK,KAAK,KAAK,CAAE;AAE7C,WAAO,KAAK,UAAU,KAAK,MAAM,KAAK,UAAU,KAAK;EACvD;;;;EAKO,gBACL,iBAAiB,OAAK;AAEtB,WACE,OAAO,QAAQ,IAAI,EAChB,OACC,CAAC,CAAC,KAAK,KAAK,MACV,iBAAiB,SAAS,GAAG,KAC7B,UAAU,UACV,UAAU,IAAI,EAGjB,QAAQ,CAAC,CAAC,KAAK,KAAK,MAA4C;;AAC/D,cAAQ,KAAG;QACT,KAAK;AACH,iBAAO,CAAC,CAAC,KAAK,QAAQ,MAAM,QAAO,IAAK,MAAS,CAAC;QACpD,KAAK;AAEH,cAAI,CAAC,gBAAgB;AACnB,mBAAO,CAAC,CAAC,KAAK,MAAM,gBAAgB,EAAE,CAAC;UACzC,OAAO;AACL,mBAAO;cACL,CAAC,WAAU,oCAAO,oBAAP,mBAAwB,EAAE;cACrC,CAAC,cAAa,oCAAO,oBAAP,mBAAwB,UAAU;cAChD,CAAC,aAAY,oCAAO,oBAAP,mBAAwB,SAAS;cAC9C,CAAC,UAAS,oCAAO,oBAAP,mBAAwB,KAAK;cACvC,CAAC,WAAU,oCAAO,oBAAP,mBAAwB,MAAM;cACzC,CAAC,kBAAiB,oCAAO,oBAAP,mBAAwB,cAAc;cACxD,CAAC,iBAAgB,oCAAO,oBAAP,mBAAwB,aAAa;cACtD,CAAC,iBAAgB,oCAAO,oBAAP,mBAAwB,YAAY;;UAEzD;QACF;AACE,iBAAO,CAAC,CAAC,KAAK,KAAK,CAAC;;IAE1B,CAAC,EAEA,OAAO,CAAC,CAAC,MAAM,KAAK,MAAM,UAAU,MAAS;EAEpD;AACD;;;ACzTK,SAAU,WAAW,KAAW;AACpC,QAAM,cAAc,IAAI,WAAW,IAAI,MAAM;AAC7C,WAAS,IAAI,GAAG,SAAS,IAAI,QAAQ,IAAI,QAAQ,KAAK;AACpD,gBAAY,CAAC,IAAI,IAAI,WAAW,CAAC;EACnC;AAEA,SAAO;AACT;;;ACCA,IAAM,gCAAgC;AAMhC,SAAU,mBAAmBC,SAAuB;AACxD,SAAO,OACL,OACA,EAAC,gBAAgB,KAAI,IAA+B,CAAA,MAC7B;AACvB,QAAI;AACJ,QAAI;AACF,iBACE,MAAW,UAAU,OAAO,WAAWA,QAAO,YAAY,GAAG;QAC3D,YAAY,CAAC,OAAO;QACpB,gBAAgB;OACjB,GACD;IACJ,SAAS,OAAO;AACd,YAAM,IAAIC,gBACR,kCAAkC,KAAK,MAAM,MAAM,OAAO,EAAE;IAEhE;AAIA,QAAI,iBAAiB,QAAQ,QAAQD,QAAO,QAAQ;AAClD,YAAM,IAAIC,gBACR,mCAAmC;IAEvC;AAEA,WAAO;EACT;AACF;;;AC5BM,SAAU,gBAAgBC,SAAuB;AACrD,SAAO,CAAC,MAAc,WAA0B;AAC9C,WAAO,GAAG,aAAaA,OAAM,EAAE,MAAM,IAAI,CAAC,IAAI,MAAM;EACtD;AACF;AAEM,SAAU,aAAaA,SAAuB;AAClD,SAAO,CAAC,SAAwB;AAC9B,WAAO,WAAW,aAAaA,OAAM,EAAE,MAAM,IAAI,CAAC;EACpD;AACF;AAEM,SAAU,oBAAoBA,SAAuB;AACzD,SAAO,eAAeC,qBAAoB,EACxC,UACA,GAAG,YAAW,GACY;AAC1B,UAAMC,WAAU,MAAM,uBAAuB,WAAW;AAExD,UAAMC,OAAM,OAAOH,OAAM;AAEzB,QAAIA,QAAO,eAAe;AACxB,MAAAG,KAAI,MAAM,0DAA0D;QAClE;MACD,CAAA;AAED,YAAM,aAAaD,SAAQ,QAAQ;AACnC,UAAI,YAAY;AACd,cAAM,WACJ,OAAO,eAAe,WAAW,aAAa,WAAW,CAAC,GAC1D,MAAM,eAAe;AACvB,YAAI,CAAC,SAAS;AACZ,UAAAC,KAAI,MAAM,gDAAgD,EAAC,SAAQ,CAAC;AAEpE,gBAAM,IAAIC,qBACR,8CAA8C;QAElD;AAEA,cAAM,aAAa,MAAM,mBAAmBJ,OAAM,EAAE,QAAQ,CAAC,CAAC;AAC9D,cAAM,OAAO,WAAW,KAAK,QAAQ,eAAe,EAAE;AAEtD,QAAAG,KAAI,MAAM,2BAA2B,EAAC,MAAM,SAAQ,CAAC;AAErD,YAAI,UAAU;AACZ,iBAAO,gBAAgBH,OAAM,EAAE,MAAM,WAAW,GAAG;QACrD,OAAO;AACL,iBAAO,aAAaA,OAAM,EAAE,IAAI;QAClC;MACF,OAAO;AACL,QAAAG,KAAI,MACF,gEACA,EAAC,SAAQ,CAAC;MAEd;IACF,OAAO;AACL,MAAAA,KAAI,MAAM,0DAA0D;QAClE;MACD,CAAA;AAED,YAAM,UAAU,IAAI,QAAQD,UAAS,CAAA,GAA0B;QAC7D,MAAM,CAACF,QAAO,YAAY;MAC3B,CAAA;AACD,aAAO,QAAQ,aAAa,mBAAmB;IACjD;AAEA,WAAO;EACT;AACF;AAEM,SAAU,iBAAiBA,SAAuB;AACtD,SAAO,CAAC,SAAyB;AAC/B,WAAO,IAAI,QAAQ;MACjB,IAAI;MACJ,MAAM,GAAG,aAAaA,OAAM,EAAE,MAAM,IAAI,CAAC;MACzC,OAAO;MACP,UAAU;IACX,CAAA;EACH;AACF;;;AClFM,SAAU,cAAc,EAC5B,QAAAK,SACA,qBACA,MACA,MAAK,GAMN;AACC,QAAM,iBAAkB,oBACrB;AACH,QAAM,WAAW,QAAQ,cAAc;AAEvC,SAAOA,OAAM,EAAE,KAAK,wBAAwB,EAAC,MAAM,SAAQ,CAAC;AAE5D,QAAM,uBAAuB,CAAC,eAC5B,IAAI,KAAK,KAAK,IAAG,IAAK,aAAa,GAAI;AAEzC,QAAM,6BAA6B,CAAC,iBAAsC;AACxE,UAAM,EAAC,cAAc,OAAO,GAAG,KAAI,IAAI;AACvC,UAAM,YAAYA,QAAO,gBACrB,gBAAgBA,OAAM,EACpB,MACA,GAAI,KAA0B,gBAAgB,EAAE,EAAE,IAEpD,OAAO,WAAU;AAErB,WAAO;MACL,IAAI;MACJ,kBAAkB;MAClB,SAAS,qBAAqB,KAAK,UAAU;;EAEjD;AAEA,QAAM,8BAA8B,CAAC,iBAAuC;AAC1E,UAAM,EAAC,WAAU,IAAI;AACrB,WAAO;MACL,IAAI,aAAaA,OAAM,EAAE,IAAI;MAC7B,GAAI,cAAc,EAAC,SAAS,qBAAqB,UAAU,EAAC;;EAEhE;AAEA,SAAO,IAAI,QAAQ;IACjB;IACA;IACA;IACA,aAAa,oBAAoB;IACjC,OAAO,oBAAoB;IAC3B,GAAI,WACA,2BAA2B,mBAA2C,IACtE,4BACE,mBAA4C;EAEnD,CAAA;AACH;;;ACfA,IAAM,YAAY,CAAC,EAAC,SAAAC,UAAS,KAAAC,MAAK,KAAI,MAAa;AACjD,EAAAA,KAAI,MAAM,gCAAgC,IAAI,MAAM;IAClD,WAAWD,SAAQ,QAAQ,YAAY;EACxC,CAAA;AACH;AAEM,SAAU,MAAME,SAAuB;AAC3C,SAAO,OAAO,EACZ,MACA,cACA,UACA,GAAG,YAAW,MAC4B;AAC1C,0BACEA,QAAO,kBACP,uCAAuC;AAGzC,UAAMD,OAAM,OAAOC,OAAM;AACzB,IAAAD,KAAI,KAAK,mBAAmB,EAAC,MAAM,UAAU,aAAY,CAAC;AAE1D,UAAMD,WAAU,MAAM,uBAAuB,WAAW;AACxD,UAAM,WAAW,MAAM,gCAAgC,WAAW;AAElE,QAAI,YAAYA,SAAQ,QAAQ,YAAY;AAC5C,QAAI,MAAM,QAAQ,SAAS,GAAG;AAC5B,kBAAY,UAAU,CAAC;IACzB;AACA,QAAI,MAAM,SAAS,GAAG;AACpB,gBAAU,EAAC,SAAAA,UAAS,KAAAC,MAAK,MAAM,QAAO,CAAC;AACvC,eAAS,aAAa;AACtB,aAAO,wBAAwB,UAAU,WAAW;IACtD;AAEA,UAAM,UAAU,IAAI,QAAQD,UAAS,UAAU;MAC7C,MAAM,CAACE,QAAO,YAAY;MAC1B,QAAQ;IACT,CAAA;AAED,UAAM,QAAQ,MAAK;AAEnB,UAAM,QAAQ,WAAW,mBAAmB,OAAO;MACjD,SAAS,IAAI,KAAK,KAAK,IAAG,IAAK,GAAK;MACpC,UAAU;MACV,QAAQ;MACR,MAAM;IACP,CAAA;AAED,UAAM,SAASA,QAAO,SAASA,QAAO,OAAO,SAAQ,IAAK;AAC1D,UAAM,QAAQ;MACZ,WAAWA,QAAO;MAClB,OAAO;MACP,cAAc,GAAGA,QAAO,UAAU,MAAMA,QAAO,QAAQ,GAAG,YAAY;MACtE;MACA,mBAAmB,WAAW,aAAa;;AAE7C,UAAM,iBAAiB,IAAI,eAAc;AACzC,mBAAe,OAAO,KAAK;AAE3B,UAAM,YAAY,aAAaA,OAAM,EAAE,MAAM,IAAI;AACjD,UAAM,cAAc,WAAW,SAAS,yBAAyB,eAAe,UAAS,CAAE;AAC3F,aAAS,aAAa;AACtB,aAAS,aAAa;AACtB,aAAS,UAAU;MACjB,GAAG,SAAS;MACZ,GAAG,QAAQ,SAAS;MACpB,UAAU;;AAGZ,IAAAD,KAAI,MAAM,iCAAiC,WAAW,IAAI,EAAC,MAAM,SAAQ,CAAC;AAE1E,WAAO,wBAAwB,UAAU,WAAW;EACtD;AACF;AAEM,SAAU,SAASC,SAAuB;AAC9C,SAAO,eAAeC,UAA6B,EACjD,GAAG,YAAW,GACC;AACf,0BACED,QAAO,kBACP,uCAAuC;AAGzC,UAAMD,OAAM,OAAOC,OAAM;AAEzB,UAAMF,WAAU,MAAM,uBAAuB,WAAW;AAExD,UAAM,QAAQ,IAAI,IAChBA,SAAQ,KACR,GAAGE,QAAO,UAAU,MAAMA,QAAO,QAAQ,EAAE,EAC3C;AACF,UAAM,OAAO,MAAM,IAAI,MAAM;AAE7B,UAAM,WAAW,CAAA;AACjB,QAAI,YAAYF,SAAQ,QAAQ,YAAY;AAC5C,QAAI,MAAM,QAAQ,SAAS,GAAG;AAC5B,kBAAY,UAAU,CAAC;IACzB;AACA,QAAI,MAAM,SAAS,GAAG;AACpB,gBAAU,EAAC,SAAAA,UAAS,KAAAC,MAAK,MAAM,WAAU,CAAC;AAC1C,YAAM,IAAIG,oBACR,yCAAyC;IAE7C;AAEA,IAAAH,KAAI,KAAK,oBAAoB,EAAC,KAAI,CAAC;AAEnC,UAAM,UAAU,IAAI,QAAQD,UAAS,UAAU;MAC7C,MAAM,CAACE,QAAO,YAAY;MAC1B,QAAQ;IACT,CAAA;AAED,UAAM,kBAAkB,MAAM,QAAQ,aAAa,iBAAiB;AACpE,YAAQ,aAAa,iBAAiB;AACtC,QAAI,CAAC,iBAAiB;AACpB,MAAAD,KAAI,MAAM,+BAA+B,EAAC,KAAI,CAAC;AAE/C,YAAM,IAAII,eACR,+EAA+E,IAAI,EAAE;IAEzF;AAEA,UAAM,YAAuB,OAAO,YAAY,MAAM,QAAO,CAAE;AAC/D,QAAI,CAAE,MAAM,WAAW,EAAC,QAAAH,SAAQ,OAAO,WAAW,gBAAe,CAAC,GAAI;AACpE,MAAAD,KAAI,MAAM,0BAA0B,EAAC,MAAM,gBAAe,CAAC;AAE3D,YAAM,IAAIK,kBAAgC,yBAAyB;IACrE;AAEA,IAAAL,KAAI,MAAM,mDAAmD,EAAC,KAAI,CAAC;AAEnE,UAAM,OAAO;MACX,WAAWC,QAAO;MAClB,eAAeA,QAAO;MACtB,MAAM,MAAM,IAAI,MAAM;;AAGxB,UAAM,YAAY,aAAaA,OAAM,EAAE,MAAM,IAAI,MAAM,GAAI,IAAI;AAE/D,UAAM,eAAe,MAAM,oBAAoBA,OAAM,EACnD,WAAW,SAAS,6BACpB;MACE,QAAQ;MACR,MAAM,KAAK,UAAU,IAAI;MACzB,SAAS;QACP,gBAAgB,SAAS;QACzB,QAAQ,SAAS;MAClB;IACF,CAAA;AAGH,QAAI,CAAC,aAAa,IAAI;AACpB,yBAAmB,MAAM,aAAa,KAAI,GAAI,OAAO,YAAY;IACnE;AAEA,UAAM,UAAmB,cAAc;MACrC,qBAAqB,MAAM,aAAa,KAAI;MAC5C,MAAM;MACN,OAAO;MACP,QAAAA;IACD,CAAA;AAED,QAAI,CAACA,QAAO,eAAe;AACzB,YAAM,QAAQ,WAAW,qBAAqB,QAAQ,IAAI;QACxD,SAAS,QAAQ;QACjB,UAAU;QACV,QAAQ;QACR,MAAM;MACP,CAAA;IACH;AAEA,WAAO;MACL,SAAU,MAAM,uBACd,QAAQ,SAAS,SACjB,WAAW;MAEb;;EAEJ;AACF;AAEA,eAAe,WAAW,EACxB,QAAAA,SACA,OACA,gBAAe,GAKhB;AACC,SACG,MAAM,aAAaA,OAAM,EAAE,KAAK,KACjC,YAAY,MAAM,OAAQ,eAAe;AAE7C;AAEA,SAAS,sBACP,kBACA,SAAe;AAEf,MAAI,kBAAkB;AACpB,UAAM,IAAIK,gBAA8B,OAAO;EACjD;AACF;;;ACnPM,SAAU,kBAAkBC,SAAuB;AACvD,SAAO,OAAO,EAAC,GAAG,YAAW,MAA+C;AAC1E,UAAMC,WAAU,MAAM,uBAAuB,WAAW;AAExD,QAAI,CAACA,UAAS;AACZ,YAAM,IAAIC,wBACR,sDAAsD;IAE1D;AAEA,QAAI,CAACD,SAAQ,KAAK;AAChB,YAAM,IAAIE,oBACR,gCAAgC;IAEpC;AAEA,UAAM,MAAM,IAAI,IAAIF,SAAQ,KAAK,WAAWA,SAAQ,QAAQ,IAAI,EAAE;AAClE,UAAM,OAAO,IAAI,aAAa,IAAI,MAAM;AAExC,QAAI,OAAO,SAAS,UAAU;AAC5B,YAAM,IAAIE,oBACR,iDAAiD;IAErD;AAEA,WAAO,oBAAoBH,OAAM,EAAE,IAAI;EACzC;AACF;AAEM,SAAU,oBACdA,SAAuB;AAEvB,SAAO,CAAC,SAAwB;AAC9B,iBAAY,EAAG,MAAM,IAAI;AACzB,UAAM,cAAc,WAAW,IAAI;AAEnC,WAAO,WAAW,WAAW,SAASA,QAAO,MAAM;EACrD;AACF;;;ICzCY;CAAZ,SAAYI,qBAAkB;AAC5B,EAAAA,oBAAA,mBAAA,IAAA;AACA,EAAAA,oBAAA,oBAAA,IAAA;AACF,GAHY,uBAAA,qBAAkB,CAAA,EAAA;AAK9B,IAAM,yBACJ;AACF,IAAM,cAAc;AAYd,SAAU,cAAcC,SAAuB;AACnD,SAAO,OAAO,EACZ,MACA,cACA,mBAAkB,MACM;AACxB,UAAM,mBAAmBA,OAAM,EAAE,YAAY;AAE7C,UAAM,OAAO;MACX,WAAWA,QAAO;MAClB,eAAeA,QAAO;MACtB,YAAY;MACZ,eAAe;MACf,oBAAoB;MACpB,sBAAsB;;AAGxB,UAAM,YAAY,aAAaA,OAAM,EAAE,MAAM,IAAI;AAEjD,UAAM,eAAe,MAAM,oBAAoBA,OAAM,EACnD,WAAW,SAAS,6BACpB;MACE,QAAQ;MACR,MAAM,KAAK,UAAU,IAAI;MACzB,SAAS;QACP,gBAAgB,SAAS;QACzB,QAAQ,SAAS;MAClB;IACF,CAAA;AAGH,QAAI,CAAC,aAAa,IAAI;AACpB,yBAAmB,MAAM,aAAa,KAAI,GAAI,OAAO,YAAY;IACnE;AAEA,WAAO;MACL,SAAS,cAAc;QACrB,qBAAqB,MAAM,aAAa,KAAI;QAC5C,MAAM;;QAEN,OAAO;QACP,QAAAA;OACD;;EAEL;AACF;;;AC7DA,IAAM,6BAA6B;AAM7B,SAAU,kBAAkBC,SAAuB;AACvD,SAAO,OAAO,EAAC,KAAI,MAA8B;AAC/C,UAAM,YAAY,aAAaA,OAAM,EAAE,MAAM,IAAI;AAEjD,UAAM,gBAAgB;MACpB,QAAQ;MACR,MAAM,KAAK,UAAU;QACnB,WAAWA,QAAO;QAClB,eAAeA,QAAO;QACtB,YAAY;OACb;MACD,SAAS;QACP,gBAAgB,SAAS;QACzB,QAAQ,SAAS;MAClB;;AAGH,UAAM,eAAe,MAAM,oBAAoBA,OAAM,EACnD,WAAW,SAAS,6BACpB,aAAa;AAGf,UAAM,eAAgB,MAAM,aAAa,KAAI;AAE7C,QAAI,CAAC,aAAa,IAAI;AACpB,yBAAmB,cAAc,OAAO,YAAY;IACtD;AAEA,WAAO;MACL,SAAS,cAAc;QACrB,qBAAqB;QACrB,MAAM;;QAEN,OAAO;QACP,QAAAA;OACD;;EAEL;AACF;;;AC1CM,SAAU,YACdC,SAAc;AAEd,QAAM,UAAU;IACd,OAAO,MAAMA,OAAM;IACnB,UAAU,SAASA,OAAM;IACzB;IACA;IACA,mBAAmB,kBAAkBA,OAAM;IAC3C,qBAAqB,oBAAoBA,OAAM;IAC/C,eAAe,cAAcA,OAAM;IACnC,mBAAmB,kBAAkBA,OAAM;;AAG7C,SAAO;AACT;;;ACrBM,SAAU,eAAeC,SAAuB;AACpD,SAAO;IACL,kBAAkB,iBAAiBA,OAAM;IACzC,cAAc,oBAAoBA,OAAM;IACxC,cAAc,aAAaA,OAAM;IACjC,iBAAiB,gBAAgBA,OAAM;IACvC,oBAAoB,mBAAmBA,OAAM;;AAEjD;;;ACfM,SAAU,kBAAkBC,SAAuB;AACvD,SAAO,CACL,kBACA,iBAA6BA,QAAO,eACzB;AAEX,QAAI,mBAAmB,WAAW,UAAU;AAC1C,aAAO;IACT;AACA,UAAM,iBAAiB,CAAC,YACtB,SAAS,QAAQ,QAAQ,KAAK,EAAE,GAAG,EAAE;AACvC,UAAM,UAAU,eAAe,cAAc;AAC7C,UAAM,YAAY,eAAe,gBAAgB;AACjD,WAAO,WAAW;EACpB;AACF;AAEM,SAAU,eAAeA,SAAuB;AACpD,SAAO,CACL,kBACA,iBAA6BA,QAAO,eACzB;AACX,WAAO,CAAC,kBAAkBA,OAAM,EAAE,kBAAkB,cAAc;EACpE;AACF;;;ACjBM,SAAU,aAAaC,SAAuB;AAClD,SAAO;IACL,cAAc,aAAaA,OAAM;IACjC,cAAc,aAAY;IAC1B,cAAc,aAAaA,OAAM;IACjC,mBAAmB,kBAAkBA,OAAM;IAC3C,gBAAgB,eAAeA,OAAM;IACrC;IACA;;AAEJ;;;IChBY;CAAZ,SAAYC,iBAAc;AACxB,EAAAA,gBAAA,MAAA,IAAA;AACA,EAAAA,gBAAA,aAAA,IAAA;AACA,EAAAA,gBAAA,QAAA,IAAA;AACF,GAJY,mBAAA,iBAAc,CAAA,EAAA;IAyDd;CAAZ,SAAYC,mBAAgB;AAC1B,EAAAA,kBAAA,QAAA,IAAA;AACA,EAAAA,kBAAA,QAAA,IAAA;AACA,EAAAA,kBAAA,QAAA,IAAA;AACF,GAJY,qBAAA,mBAAgB,CAAA,EAAA;AAyErB,IAAM,+BAA+B;EAC1C,GAAG;EACH,gBAAgB;;;;SC7HF,WAAQ;AACtB,SAAO,CAAA;AACT;AAEM,SAAU,gBAAgB,OAAa;AAC3C,SAAO,MAAM,YAAW,EAAG,QAAQ,UAAU,GAAG;AAClD;AAEM,SAAU,YACdC,SACA,iBAAgC;AAEhC,SAAO,SAASC,aAAY,eAAgC;AAC1D,eAAW,CAAC,OAAO,QAAQ,KAAK,OAAO,QAAQ,aAAa,GAAG;AAC7D,YAAM,WAAW,gBAAgB,KAAK;AAEtC,UAAI,MAAM,QAAQ,QAAQ,GAAG;AAC3B,mBAAW,WAAW,UAAU;AAC9B,4BAAkBD,SAAQ,iBAAiB,UAAU,OAAO;QAC9D;MACF,OAAO;AACL,0BAAkBA,SAAQ,iBAAiB,UAAU,QAAQ;MAC/D;IACF;EACF;AACF;AAEM,SAAU,eAAe,iBAAgC;AAC7D,SAAO,SAASE,kBAAc;AAC5B,WAAO,OAAO,KAAK,eAAe;EACpC;AACF;AAEM,SAAU,YAAY,iBAAgC;AAC1D,SAAO,SAASC,aAAY,OAAa;AACvC,WAAO,gBAAgB,gBAAgB,KAAK,CAAC,KAAK,CAAA;EACpD;AACF;AAEM,SAAU,kBACdH,SACA,SAAuB;AAEvB,QAAM,SAAS,QAAQ;AAEvB,UAAQ,QAAQ,gBAAc;IAC5B,KAAK,eAAe;AAClB,aAAO,GAAG,MAAM,IAAI,qBAAqBA,SAAQ,QAAQ,WAAW,CAAC;IACvE,KAAK,eAAe;AAClB,aAAO,GAAG,MAAM,IAAI,QAAQ,GAAG;IACjC,KAAK,eAAe;AAClB,aAAO,GAAG,MAAM,IAAI,QAAQ,aAAa,IAAI,QAAQ,WAAW;IAClE;AACE,YAAM,IAAI,2BACR,iCAAkC,QAAgB,cAAc,GAAG;;AAG3E;AAEM,SAAU,qBACdA,SACA,aAAmB;AAEnB,MAAI,YAAY,WAAW,GAAG,GAAG;AAC/B,WAAO,GAAGA,QAAO,UAAU,MAAMA,QAAO,QAAQ,GAAG,WAAW;EAChE,OAAO;AACL,WAAO;EACT;AACF;AAEA,SAAS,kBACPA,SACA,iBACA,OACA,SAAuB;;AAEvB,QAAMI,OAAM,OAAOJ,OAAM;AAEzB,gBAAQ,kBAAR,mBAAuB;AACvB,gBAAQ,wBAAR,mBAA6B;AAE7B,MAAI,EAAE,SAAS,kBAAkB;AAC/B,oBAAgB,KAAK,IAAI,CAAC,OAAO;AACjC;EACF;AAEA,QAAM,aAAa,kBAAkBA,SAAQ,OAAO;AAEpD,aAAW,SAAS,gBAAgB,KAAK,GAAG;AAC1C,QAAI,CAAC,OAAO,UAAU,eAAe,KAAK,gBAAgB,KAAK,GAAG,KAAK,GAAG;AACxE;IACF;AAEA,UAAM,kBAAkB,gBAAgB,KAAK,EAAE,KAAK;AACpD,UAAM,qBAAqB,kBAAkBA,SAAQ,eAAe;AAEpE,QAAI,eAAe,oBAAoB;AACrC;IACF;AAEA,QAAI,QAAQ,mBAAmB,eAAe,MAAM;AAClD,MAAAI,KAAI,KACF,mCAAmC,KAAK,iDAAiD;AAE3F;IACF,OAAO;AACL,YAAM,IAAI,2BACR,iMAAiM,KAAK,UACpM,OAAO,CACR,EAAE;IAEP;EACF;AAEA,kBAAgB,KAAK,EAAE,KAAK,OAAO;AACrC;;;AC9HM,SAAU,cAAc,UAAkB,QAA2B;AACzE,MAAI,QAAQ;AAEZ,SAAO,QAAQ,MAAM,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAK;AAC9C,YAAQ,MAAM,QAAQ,KAAK,GAAG,MAAM,KAAK;EAC3C,CAAC;AAED,SAAO;AACT;;;ACqCM,SAAU,SACdC,SACA,iBAAgC;AAEhC,SAAO,eAAeC,UAAS,EAC7B,QAAO,GACQ;AACf,UAAMC,OAAM,OAAOF,OAAM;AACzB,IAAAE,KAAI,KAAK,wBAAwB,EAAC,MAAM,QAAQ,KAAI,CAAC;AAErD,UAAM,iBAAiC,OAAO,KAAK,eAAe,EAAE,OAClE,CAAC,KAAqB,UAAS;AAC7B,UAAI,KAAK,IAAI,CAAA;AACb,aAAO;IACT,GACA,CAAA,CAAE;AAGJ,UAAM,mBAAmB,MAAM,oBAAoBF,SAAQ,OAAO;AAElE,IAAAE,KAAI,MACF,qBAAqB,OAAO,KAAK,gBAAgB,EAAE,KAAK,IAAI,CAAC,KAC7D,EAAC,MAAM,QAAQ,KAAI,CAAC;AAGtB,eAAW,SAAS,iBAAiB;AACnC,UAAI,CAAC,OAAO,UAAU,eAAe,KAAK,iBAAiB,KAAK,GAAG;AACjE;MACF;AAEA,UAAI,cAAc,SAAS,KAAK,GAAG;AACjC;MACF;AAEA,qBAAe,KAAK,IAAI,MAAM,cAAc;QAC1C,QAAAF;QACA;QACA;QACA,kBAAkB,iBAAiB,KAAK,KAAK,CAAA;QAC7C,UAAU,YAAY,eAAe,EAAE,KAAK;MAC7C,CAAA;AAGD,aAAO,iBAAiB,KAAK;IAC/B;AAGA,eAAW,SAAS,kBAAkB;AACpC,UAAI,CAAC,OAAO,UAAU,eAAe,KAAK,kBAAkB,KAAK,GAAG;AAClE;MACF;AAEA,YAAMG,iBAAgB,mBAAmB,EAAC,QAAAH,QAAM,CAAC;AACjD,YAAM,SAAS,IAAIG,eAAc,EAAC,QAAO,CAAC;AAE1C,qBAAe,KAAK,IAAI,MAAM,aAAa;QACzC,QAAAH;QACA;QACA;QACA,UAAU,iBAAiB,KAAK;QAChC,WAAW,iBAAiB;MAC7B,CAAA;IACH;AAEA,WAAO;EACT;AACF;AAEA,eAAe,oBACbA,SACA,SAAgB;;AAEhB,QAAMG,iBAAgB,mBAAmB,EAAC,QAAAH,QAAM,CAAC;AACjD,QAAM,SAAS,IAAIG,eAAc,EAAC,QAAO,CAAC;AAE1C,QAAM,mBAAoC,CAAA;AAE1C,MAAI;AACJ,MAAI,YAA2B;AAC/B,KAAG;AACD,UAAM,QAAQ,gBAAgB,SAAS;AAEvC,UAAM,WAAW,MAAM,OAAO,QAA8B,KAAK;AAEjE,yBAAS,SAAT,mBAAe,yBAAf,mBAAqC,MAAM,QACzC,CAAC,SAAkC;AACjC,YAAM,UAAU,qBAAqB,IAAI;AAEzC,UAAI,CAAC,iBAAiB,KAAK,KAAK,KAAK,GAAG;AACtC,yBAAiB,KAAK,KAAK,KAAK,IAAI,CAAA;MACtC;AAEA,uBAAiB,KAAK,KAAK,KAAK,EAAE,KAAK,OAAO;IAChD;AAGF,iBAAY,oBAAS,SAAT,mBAAe,yBAAf,mBAAqC,SAAS;AAC1D,mBAAc,oBAAS,SAAT,mBAAe,yBAAf,mBAAqC,SAAS;EAC9D,SAAS;AAET,SAAO;AACT;AAEA,SAAS,gBAAgB,WAAwB;AAC/C,SAAO,cAAc,uBAAuB;IAC1C,YAAY,KAAK,UAAU,SAAS;EACrC,CAAA;AACH;AAEA,SAAS,qBAAqB,MAA8B;;AAC1D,QAAM,WAAW,KAAK,KAAK;AAE3B,MAAI;AAEJ,UAAQ,SAAS,YAAU;IACzB,KAAK;AACH,gBAAU;QACR,gBAAgB,eAAe;QAC/B,aAAa,SAAS;;QAEtB,UAAU,YAAA;QAAa;;AAEzB;IACF,KAAK;AACH,gBAAU;QACR,gBAAgB,eAAe;QAC/B,KAAK,SAAS;;AAEhB;IACF,KAAK;AACH,gBAAU;QACR,gBAAgB,eAAe;QAC/B,eAAe,SAAS;QACxB,aAAa,SAAS;;AAExB;;AAIJ,UAAQ,KAAK,KAAK,KAAK;AACvB,UAAQ,gBAAgB,KAAK,KAAK;AAClC,UAAQ,sBAAsB,KAAK,KAAK;AAGxC,gBAAQ,kBAAR,mBAAuB;AACvB,gBAAQ,wBAAR,mBAA6B;AAE7B,SAAO;AACT;AAEA,eAAe,cAAc,EAC3B,QAAAH,SACA,SACA,OACA,kBACA,SAAQ,GACY;AACpB,MAAI,kBAAoC,CAAA;AAExC,QAAM,EAAC,UAAU,UAAU,SAAQ,IAAI,mBACrCA,SACA,kBACA,QAAQ;AAGV,QAAMG,iBAAgB,mBAAmB,EAAC,QAAAH,QAAM,CAAC;AACjD,QAAM,SAAS,IAAIG,eAAc,EAAC,QAAO,CAAC;AAE1C,MAAI,YAAY,iBAAiB;AACjC,oBAAkB,gBAAgB,OAChC,MAAM,aAAa,EAAC,QAAAH,SAAQ,QAAQ,OAAO,WAAW,UAAU,SAAQ,CAAC,CAAC;AAG5E,cAAY,iBAAiB;AAC7B,oBAAkB,gBAAgB,OAChC,MAAM,aAAa,EAAC,QAAAA,SAAQ,QAAQ,OAAO,WAAW,UAAU,SAAQ,CAAC,CAAC;AAG5E,cAAY,iBAAiB;AAC7B,oBAAkB,gBAAgB,OAChC,MAAM,aAAa,EAAC,QAAAA,SAAQ,QAAQ,OAAO,WAAW,UAAU,SAAQ,CAAC,CAAC;AAG5E,SAAO;AACT;AAIA,SAAS,mBACPA,SACA,kBACA,UAA0B;AAE1B,QAAM,gBAAgB,SAAS,OAAO,CAAC,KAAoB,UAAS;AAClE,QAAI,kBAAkBA,SAAQ,KAAK,CAAC,IAAI;AACxC,WAAO;EACT,GAAG,CAAA,CAAE;AACL,QAAM,wBAAwB,iBAAiB,OAC7C,CAAC,KAAoB,UAAS;AAC5B,QAAI,kBAAkBA,SAAQ,KAAK,CAAC,IAAI;AACxC,WAAO;EACT,GACA,CAAA,CAAE;AAGJ,QAAM,WAA0B,EAAC,GAAG,cAAa;AACjD,QAAM,WAA0B,CAAA;AAChC,QAAM,WAA0B,CAAA;AAChC,aAAW,eAAe,uBAAuB;AAC/C,QACE,CAAC,OAAO,UAAU,eAAe,KAAK,uBAAuB,WAAW,GACxE;AACA;IACF;AAEA,UAAM,kBAAkB,sBAAsB,WAAW;AACzD,UAAM,UAAU,cAAc,WAAW;AAEzC,QAAI,eAAe,eAAe;AAChC,aAAO,SAAS,WAAW;AAE3B,UAAI,CAAC,sBAAsB,iBAAiB,OAAO,GAAG;AACpD,iBAAS,WAAW,IAAI;AACxB,iBAAS,WAAW,EAAE,KAAK,gBAAgB;MAC7C;IACF,OAAO;AACL,eAAS,WAAW,IAAI;IAC1B;EACF;AAEA,SAAO;IACL,UAAU,OAAO,OAAO,QAAQ;IAChC,UAAU,OAAO,OAAO,QAAQ;IAChC,UAAU,OAAO,OAAO,QAAQ;;AAEpC;AACA,SAAS,sBACP,MACA,MAAoB;AAEpB,QAAM,qBAAqB,YACzB,KAAK,iBAAiB,CAAA,GACtB,KAAK,iBAAiB,CAAA,CAAE;AAE1B,QAAM,2BAA2B,YAC/B,KAAK,uBAAuB,CAAA,GAC5B,KAAK,uBAAuB,CAAA,CAAE;AAGhC,SAAO,sBAAsB;AAC/B;AAEA,SAAS,YAAY,MAAa,MAAW;AAC3C,MAAI,KAAK,WAAW,KAAK,QAAQ;AAC/B,WAAO;EACT;AAEA,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,QAAI,KAAK,CAAC,MAAM,KAAK,CAAC,GAAG;AACvB,aAAO;IACT;EACF;AAEA,SAAO;AACT;AAEA,eAAe,aAAa,EAC1B,QAAAA,SACA,QACA,OACA,UACA,UAAS,GACU;AACnB,QAAM,kBAAoC,CAAA;AAE1C,aAAW,WAAW,UAAU;AAC9B,oBAAgB,KACd,MAAM,YAAY,EAAC,QAAAA,SAAQ,QAAQ,OAAO,SAAS,UAAS,CAAC,CAAC;EAElE;AAEA,SAAO;AACT;AAEA,eAAe,YAAY,EACzB,QAAAA,SACA,QACA,OACA,SACA,UAAS,GACS;AAClB,MAAI;AAEJ,SAAOA,OAAM,EAAE,MAAM,4BAA4B,EAAC,OAAO,UAAS,CAAC;AAEnE,MAAI;AACF,UAAM,QAAQ,cAAcA,SAAQ,OAAO,SAAS,SAAS;AAE7D,UAAM,SAAS,MAAM,OAAO,QAAQ,KAAK;AAEzC,qBAAiB;MACf,gBAAgB,QAAQ;MACxB,SAAS,UAAU,QAAQ,SAAS,SAAS;MAC7C;MACA;;EAEJ,SAAS,OAAO;AACd,QAAI,iBAAiB,4BAA4B;AAC/C,uBAAiB;QACf,gBAAgB,QAAQ;QACxB,SAAS;QACT,QAAQ,EAAC,SAAS,MAAM,QAAO;QAC/B;;IAEJ,OAAO;AACL,YAAM;IACR;EACF;AAEA,SAAO;AACT;AAEA,SAAS,cACPA,SACA,OACA,SACA,WAA2B;AAE3B,QAAM,SAAiC,CAAA;AAEvC,MAAI;AACJ,MAAI,QAAQ,IAAI;AACd,iBAAa,QAAQ,QAAQ,EAAE;EACjC,OAAO;AACL,iBAAa,UAAU,KAAK;EAC9B;AAEA,QAAM,oBAAoB;IACxB,eAAe,gBAAgB,SAAS,SAAS;IACjD,YAAY;IACZ,iBAAiB;;AAGnB,MAAI,cAAc,iBAAiB,QAAQ;AACzC,YAAQ,QAAQ,gBAAc;MAC5B,KAAK,eAAe;AAClB,eAAO,cAAc,IAAI,qBACvBA,SACA,QAAQ,WAAW,CACpB;AACD;MACF,KAAK,eAAe;AAClB,eAAO,MAAM,IAAI,QAAQ,GAAG;AAC5B;MACF,KAAK,eAAe;AAClB,eAAO,gBAAgB,IAAI,QAAQ,aAAa;AAChD,eAAO,cAAc,IAAI,QAAQ,WAAW;AAC5C;MACF;AACE,cAAM,IAAI,2BACR,iCAAkC,QAAgB,cAAc,GAAG;;AAIzE,QAAI,QAAQ,eAAe;AACzB,aAAO,gBAAgB,KAAK,UAAU,QAAQ,aAAa;IAC7D;AACA,QAAI,QAAQ,qBAAqB;AAC/B,aAAO,sBAAsB,KAAK,UAAU,QAAQ,mBAAmB;IACzE;AAEA,QAAI,QAAQ,UAAU;AACpB,YAAM,iBAAiB,cAAc,QAAQ,QAAQ;AACrD,wBAAkB,kBAAkB;IACtC;AAEA,UAAM,eAAe,OAAO,QAAQ,MAAM,EACvC,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM,GAAG,GAAG,KAAK,KAAK,EAAE,EACxC,KAAK,IAAI;AAEZ,sBAAkB,mBAAmB,yBAAyB,YAAY;EAC5E;AAEA,SAAO,cAAc,mBAAmB,iBAAiB;AAC3D;AAEA,SAAS,gBACP,SACA,WAA2B;AAE3B,UAAQ,WAAS;IACf,KAAK,iBAAiB;AACpB,aAAO,GAAG,YAAY,OAAO,CAAC;IAChC,KAAK,iBAAiB;AACpB,aAAO,GAAG,YAAY,OAAO,CAAC;IAChC,KAAK,iBAAiB;AACpB,aAAO;IACT;AACE,YAAM,IAAI,aAAa,2BAA2B,SAAS,GAAG;;AAEpE;AAEA,SAAS,YAAY,SAAuB;AAC1C,UAAQ,QAAQ,gBAAc;IAC5B,KAAK,eAAe;AAClB,aAAO;IACT,KAAK,eAAe;AAClB,aAAO;IACT,KAAK,eAAe;AAClB,aAAO;IACT;AACE,YAAM,IAAI,aACR,iCAAkC,QAAgB,cAAc,GAAG;;AAG3E;AAEA,SAAS,UACP,QACA,SACA,WAA2B;AAE3B,QAAM,eAAe,gBAAgB,SAAS,SAAS;AAEvD,SAAO,QACL,OAAO,QACL,OAAO,KAAK,YAAY,KACxB,OAAO,KAAK,YAAY,EAAE,WAAW,WAAW,CAAC;AAEvD;AAEO,IAAM,wBAAwB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiC9B,IAAM,oBAAoB;;;;;;;;;;;;;;;ACvejC,IAAM,8BAA8B;EAClC,UAAU,cAAc;;AAG1B,IAAM,qBAAqB;EACzB,YAAY,cAAc;EAC1B,QAAQ,cAAc;EACtB,MAAM,cAAc;EACpB,OAAO,cAAc;EACrB,WAAW,cAAc;EACzB,GAAG;;AAGC,SAAU,gBAAgBI,SAAuB;AACrD,SAAO,eAAe,SAAS,EAC7B,SACA,GAAG,YAAW,GACQ;AACtB,UAAMC,WACJ,MAAM,uBAAuB,WAAW;AAE1C,UAAM,kBAAkB,MAAM,+BAA+BD,OAAM,EAAE;MACnE,MAAM,mBAAmB;MACzB;MACA,GAAG;IACJ,CAAA;AAED,QAAI,CAAC,gBAAgB,OAAO;AAC1B,UAAI,gBAAgB,WAAW,sBAAsB,aAAa;AAChE,cAAME,OAAM,OAAOF,OAAM;AACzB,cAAME,KAAI,MACR,kOAAkO;MAEtO;AACA,aAAO;IACT;AAEA,WAAO,oBAAoBD,SAAQ,OAAO;EAC5C;AACF;AAEA,SAAS,oBACP,SAAgB;AAEhB,QAAM,iBAAkC,CAAA;AACxC,QAAM,UAAU,OAAO,QAAQ,kBAAkB;AAIjD,QAAM,eAAe,QAAQ,OAAO,CAAC,KAAK,CAAC,UAAU,UAAU,MAAK;AAClE,UAAM,cAAc,UAAU,SAAS,UAAU;AACjD,QAAI,aAAa;AACf,UAAI,QAAQ,IAAI;IAClB,WAAW,EAAE,YAAY,8BAA8B;AACrD,qBAAe,KAAK,UAAU;IAChC;AAEA,WAAO;EACT,GAAG,CAAA,CAAmB;AAEtB,MAAI,eAAe,QAAQ;AACzB,WAAO;MACL,OAAO;MACP,QAAQ,6BAA6B;MACrC;;EAEJ,OAAO;AACL,WAAO;MACL,OAAO;MACP,GAAG;MACH,GAAI,aAAa,WAAW,EAAC,UAAU,aAAa,SAAQ,IAAI,CAAA;MAChE,OAAO,gBAAgB,aAAa,KAAK;;EAE7C;AACF;;;AC/DA,IAAM,qBAA6C;EACjD,CAAC,WAAW,EAAE,GAAG;EACjB,CAAC,WAAW,UAAU,GAAG;EACzB,CAAC,WAAW,YAAY,GAAG;EAC3B,CAAC,WAAW,QAAQ,GAAG;EACvB,CAAC,WAAW,mBAAmB,GAAG;;AAG9B,SAAUE,SACdC,SACA,iBAAgE;AAEhE,SAAO,eAAeD,SAAQ,EAC5B,SACA,SACA,GAAG,YAAW,GACO;AACrB,UAAM,WAA+B;MACnC,YAAY,WAAW;MACvB,YAAY,mBAAmB,WAAW,EAAE;MAC5C,SAAS,CAAA;;AAGX,UAAM,OAAOC,OAAM,EAAE,KAAK,2BAA2B;AAErD,UAAM,eAAe,MAAM,gBAAgBA,OAAM,EAAE;MACjD;MACA,GAAG;IACJ,CAAA;AAED,QAAI,eAAe;AACnB,QAAI,aAAa,OAAO;AACtB,YAAM,gBAAgB,MAAM,oBAC1BA,SACA,iBACA,cACA,SACA,OAAO;AAGT,eAAS,aAAa,cAAc;AACpC,UAAI,CAAC,KAAK,QAAQ,GAAG;AACnB,uBAAe,cAAc,gBAAgB;MAC/C;IACF,OAAO;AACL,YAAM,cAAc,MAAM,qBAAqBA,SAAQ,YAAY;AAEnE,eAAS,aAAa,YAAY;AAClC,eAAS,aAAa,mBAAmB,SAAS,UAAU;AAC5D,qBAAe,YAAY;IAC7B;AAEA,UAAM,iBAAiB,MAAM,wBAAwB,UAAU,WAAW;AAC1E,QAAI,CAAC,KAAK,QAAQ,GAAG;AACnB,YAAM,IAAIC,oBAAkC;QAC1C,SAAS;QACT,UAAU;MACX,CAAA;IACH;AAEA,WAAO,QAAQ,QAAQ,cAAc;EACvC;AACF;AAEA,eAAe,oBACbD,SACA,iBACA,cACA,SACA,SAAY;AAEZ,QAAME,OAAM,OAAOF,OAAM;AACzB,QAAM,EAAC,MAAM,OAAO,OAAO,QAAQ,GAAG,eAAc,IAAI;AAExD,QAAME,KAAI,MACR,+DACA,cAAc;AAGhB,QAAM,WAAW,gBAAgB,aAAa,KAAK,KAAK,CAAA;AAExD,QAAM,WAA8B,EAAC,YAAY,WAAW,GAAE;AAE9D,MAAI,QAAQ;AACZ,aAAW,WAAW,UAAU;AAC9B,QAAI,QAAQ,mBAAmB,eAAe,MAAM;AAClD;IACF;AACA,QAAI,CAAC,QAAQ,UAAU;AACrB,eAAS,aAAa,WAAW;AACjC,eAAS,eACP;AAEF,YAAM,IAAIC,4BAA0C;QAClD,SAAS,SAAS;QAClB;MACD,CAAA;IACH;AAEA,YAAQ;AAER,UAAMD,KAAI,MAAM,qCAAqC,cAAc;AAEnE,QAAI;AACF,YAAM,QAAQ,SACZ,aAAa,OACb,aAAa,QACb,SACA,aAAa,WACb,aAAa,YACb,IAAI,6CAAc,YAAW,aAAa,WAAW,IACrD,OAAO;IAEX,SAAS,OAAO;AACd,eAAS,aAAa,WAAW;AACjC,eAAS,eAAe,MAAM;IAChC;EACF;AAEA,MAAI,CAAC,OAAO;AACV,UAAMA,KAAI,MAAM,0BAA0B,cAAc;AAExD,aAAS,aAAa,WAAW;AACjC,aAAS,eAAe,yCAAyC,aAAa,KAAK;EACrF;AAEA,SAAO;AACT;AAEA,eAAe,qBACbF,SACA,cAAsC;AAEtC,QAAM,WAA4B;IAChC,YAAY,WAAW;IACvB,cAAc;;AAGhB,UAAQ,aAAa,QAAM;IACzB,KAAK,6BAA6B;AAChC,eAAS,aAAa,WAAW;AACjC,eAAS,eAAe,0EACtB,aACA,eAAe,KAAK,IAAI,CAAC;AAC3B;IACF,KAAK,6BAA6B;AAChC,eAAS,aAAa,WAAW;AACjC,eAAS,eAAe;AACxB;IACF,KAAK,6BAA6B;AAChC,eAAS,aAAa,WAAW;AACjC,eAAS,eAAe;AACxB;IACF,KAAK,6BAA6B;AAChC,eAAS,aAAa,WAAW;AACjC,eAAS,eAAe;AACxB;;AAGJ,QAAM,OAAOA,OAAM,EAAE,MACnB,yCAAyC,SAAS,UAAU,KAAK,SAAS,YAAY,EAAE;AAG1F,SAAO;AACT;;;ACrHM,SAAU,gBAAgBI,SAAuB;AACrD,QAAM,kBAAkB,SAAQ;AAEhC,SAAO;IACL,aAAa,YAAYA,SAAQ,eAAe;IAChD,gBAAgB,eAAe,eAAe;IAC9C,aAAa,YAAY,eAAe;IACxC,UAAU,SAASA,SAAQ,eAAe;IAC1C,SAASC,SACPD,SACA,eAAkE;IAEpE,UAAU,gBAAgBA,OAAM;;AAEpC;;;AC8iBO,IAAM,4BAA4B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvoBnC,SAAU,mBAAmB,MAAS;AAC1C,MAAI,CAAC;AAAM,WAAO;AAElB,8BAA4B,IAAI;AAChC,kCAAgC,IAAI;AACpC,0BAAwB,IAAI;AAE5B,SAAO;AACT;AAEM,SAAU,gCAAgC,MAAS;AAbzD;AAcE,MAAI,CAAC;AAAM;AAEX,QAAI,UAAK,UAAL,mBAAY,WAAU,OAAO,KAAK,MAAM,WAAW,UAAU;AAC/D,SAAK,MAAM,SAAS,WAAW,KAAK,MAAM,MAAM;EAClD;AACF;AAEM,SAAU,wBAAwB,MAAS;AArBjD;AAsBE,MAAI,CAAC;AAAM;AAEX,QACE,gBAAK,aAAL,mBAAe,uBAAf,mBAAmC,WACnC,OAAO,KAAK,SAAS,mBAAmB,WAAW,UACnD;AACA,SAAK,SAAS,mBAAmB,SAAS,WACxC,KAAK,SAAS,mBAAmB,MAAM;EAE3C;AAEA,QACE,sBAAK,aAAL,mBAAe,UAAf,mBAAsB,WAAtB,mBAA8B,WAC9B,OAAO,KAAK,SAAS,MAAM,OAAO,WAAW,UAC7C;AACA,SAAK,SAAS,MAAM,OAAO,SAAS,WAClC,KAAK,SAAS,MAAM,OAAO,MAAM;EAErC;AACF;AAEM,SAAU,4BAA4B,MAAS;AA3CrD;AA4CE,MAAI,CAAC;AAAM;AAEX,QAAI,UAAK,gBAAL,mBAAkB,WAAU,OAAO,KAAK,YAAY,WAAW,UAAU;AAC3E,SAAK,YAAY,SAAS,WAAW,KAAK,YAAY,MAAM;EAC9D;AAEA,QACE,UAAK,iBAAL,mBAAmB,WACnB,OAAO,KAAK,aAAa,WAAW,UACpC;AACA,SAAK,aAAa,SAAS,WAAW,KAAK,aAAa,MAAM;EAChE;AACF;AAKM,SAAU,iBAAiB,WAAuC;AACtE,SAAO,UAAU,IAAI,CAAC,SAAQ;AA9DhC;AA+DI,SAAI,UAAK,SAAL,mBAAW,gBAAgB;AAC7B,WAAK,KAAK,iBAAiB,mBAAmB,KAAK,KAAK,cAAc;IACxE;AACA,WAAO;EACT,CAAC;AACH;;;AClCM,SAAU,MAGdE,SAAc;AACd,SAAO,eAAeC,OACpB,QAAc;;AAEd,QAAI,GAAC,KAAAD,QAAO,WAAP,mBAAe,mCAAkC,CAACA,QAAO,SAAS;AACrE,YAAM,IAAI,aAAa;QACrB,SAAS;QACT,WAAW,CAAA;MACZ,CAAA;IACH;AAEA,UAAM,EAAC,SAAS,SAAS,MAAM,MAAK,IAAI;AACxC,UAAM,eACH,OACE,gBAAgB;AAErB,UAAME,iBAAgB,mBAAmB,EAAC,QAAAF,QAAM,CAAC;AACjD,UAAM,SAAS,IAAIE,eAAc,EAAC,QAAO,CAAC;AAE1C,UAAM,WAAW,MAAM,eAAe,EAAC,QAAQ,QAAQ,MAAK,CAAC;AAE7D,UAAI,KAAAF,QAAO,WAAP,mBAAe,mCAAkC,cAAc;AACjE,aAAO;IACT,OAAO;AACL,aAAO,SAAS;IAClB;EACF;AACF;AAEO,eAAe,eAAe,EACnC,QACA,QACA,MAAK,GACU;;AACf,QAAM,cAA0C;IAC9C,kBAAkB;IAClB,kBAAkB,CAAA;IAClB,kBAAkB,CAAA;;AAGpB,MAAI;AACJ,MAAI,YAA2B;AAC/B,KAAG;AACD,UAAM,uBAAuB,MAAM,OAAO,QACxC,oBACA,EAAC,WAAW,EAAC,UAAS,EAAC,CAAC;AAG1B,oBAAe,0BAAqB,SAArB,mBAA2B;AAC1C,iBAAa,oBAAoB,QAAQ,CAAC,iBAAgB;AACxD,UAAI,0BAA0B,EAAC,cAAc,QAAQ,MAAK,CAAC,GAAG;AAC5D,oBAAY,mBAAmB;AAC/B,YAAI,aAAa,WAAW;AAC1B,uBAAa,YAAY,iBAAiB,aAAa,SAAS;QAClE;AACA,oBAAY,iBAAiB,KAAK,YAAY;MAChD;IACF,CAAC;AACD,iBAAa,iBAAiB,MAAM,QAAQ,CAAC,EAAC,MAAM,SAAQ,MAAK;AAC/D,UAAI,sBAAsB,EAAC,UAAU,QAAQ,MAAK,CAAC,GAAG;AACpD,oBAAY,mBAAmB;AAC/B,oBAAY,iBAAiB,KAAK,QAAQ;MAC5C;IACF,CAAC;AAED,gBAAY,aAAa,iBAAiB,SAAS;EACrD,SAAS,6CAAc,iBAAiB,SAAS;AAEjD,SAAO;AACT;AAEA,SAAS,0BAA0B,EACjC,cACA,QACA,MAAK,GAC2B;AAChC,UACG,OAAO,UAAU,eAAe,MAAM,SAAS,aAAa,IAAI,OAChE,UAAU,CAAC,aAAa;AAE7B;AAEA,SAAS,sBAAsB,EAC7B,UACA,QACA,MAAK,GACuB;AAC5B,UACG,OAAO,UAAU,eAAe,MAAM,SAAS,SAAS,IAAI,OAC5D,UAAU,CAAC,SAAS,SACrB,SAAS,WAAW;AAExB;AAEA,IAAM,qBAAqB;IACvB,yBAAyB;;;;;;;;;;;;;;;;;;;;;;;;;AChH7B,IAAM,8BAA8B;IAChC,yBAAyB;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6B7B,IAAM,6BAA6B;;;;;;;;;;;;;;;;;;;;;;;;;;AA0C7B,SAAU,QAIdG,SAAc;AACd,SAAO,eAAqD,EAC1D,SACA,MACA,SAAS,MACT,WAAW,gBACX,eAAe,OACf,GAAG,UAAS,GACL;;AACP,QAAI,CAACA,QAAO,WAAW,CAACA,QAAO,QAAQ,IAAI,GAAG;AAC5C,YAAM,IAAI,aAAa;QACrB,SAAS,uBAAuB,IAAI;QACpC,WAAW,CAAA;MACZ,CAAA;IACH;AAEA,UAAM,gBAAgB;MACpB,GAAGA,QAAO,QAAQ,IAAI;;AAExB,UAAM,oBAAoB,OAAO,YAC/B,OAAO,QAAQ,SAAS,EAAE,OAAO,CAAC,CAAC,MAAM,KAAK,MAAM,UAAU,MAAS,CAAC;AAG1E,UAAM,gBAAgB,QAAQ,KAAK,QAAQ,kBAAkB,EAAE;AAC/D,UAAM,iBAAiB,oBAAoBA,OAAM,EAC/C,WAAW,2BAA2B,aAAa,IAAI,WAAW,MAAM,CAAC;AAG3E,UAAM,SAAS,GAAGA,QAAO,UAAU,MAAMA,QAAO,QAAQ,SAAS,QAAQ,IAAI;AAG7E,UAAM,YACJ,mBAAmBA,QAAO,gBAAgB,iBAAiB;AAE7D,UAAMC,iBAAgB,mBAAmB,EAAC,QAAAD,QAAM,CAAC;AACjD,UAAM,SAAS,IAAIC,eAAc,EAAC,QAAO,CAAC;AAE1C,aAAS,eACPC,gBAAkB;AAElB,aAAO,eAAeA;IACxB;AAEA,aAAS,cACPA,gBAAkB;AAElB,aAAOA,eAAc,aAAa,gBAAgB;IACpD;AAEA,QAAI;AACJ,QAAI,eAAe,aAAa,GAAG;AACjC,YAAM,uBAAuB,oBAC3B,eACA,iBAAiB;AAEnB,YAAM,4BAA4B,MAAM,2BAA2B;QACjE,eAAe;QACf;QACA;QACA;QACA;MACD,CAAA;AAED,aAAO,0BAA0B;IACnC,WAAW,cAAc,aAAa,GAAG;AACvC,YAAM,0BAA0B,MAAM,qBAAqB;QACzD,eAAe,EAAC,GAAG,eAAe,GAAG,kBAAiB;QACtD;QACA;QACA;QACA;MACD,CAAA;AACD,aAAO,wBAAwB;IACjC,OAAO;AACL,YAAM,IAAI,aAAa;QACrB,SAAS,0CAA0C,IAAI;QACvD,WAAW,CAAA;MACZ,CAAA;IACH;AAEA,SAAI,UAAK,eAAL,mBAAiB,QAAQ;AAC3B,YAAM,IAAI,aAAa;QACrB,SAAS;QACT,WAAW,KAAK;MACjB,CAAA;IACH;AAEA,QAAI,cAAc;AAChB,aAAO;IAIT,OAAO;AACL,aAAO,KAAK;IACd;EACF;AACF;AAEA,eAAe,2BAA2B,EACxC,eACA,MACA,QACA,WACA,OAAM,GACoB;AAC1B,QAAM,YAAY,cAAc,UAAU,IAAI,CAAC,SAAQ;AACrD,QACE,KAAK,aAAa,gBAAgB,eAClC,KAAK,aAAa,gBAAgB,QAClC;AACA,YAAM,6BAAkC;QACtC,UAAU,KAAK;QACf,OAAO;UACL,QAAQ,KAAK;UACb,cAAc,KAAK;QACpB;;AAGH,UAAI,KAAK,UAAU;AACjB,mCAA2B,WAAW;UACpC,0BAA0B,KAAK,SAAS;UACxC,OAAO;YACL,QAAQ,KAAK,SAAS,MAAM;YAC5B,YAAY,KAAK,SAAS,MAAM;UACjC;;MAEL;AAEA,aAAO;QACL,MAAM;UACJ;QACD;;IAEL,WAAW,KAAK,aAAa,gBAAgB,OAAO;AAClD,YAAM,yBAAyB;QAC7B,OAAO,KAAK;QACZ,cAAc;UACZ,QAAQ,KAAK;UACb,cAAc,KAAK;QACpB;;AAGH,aAAO;QACL,MAAM;UACJ;QACD;;IAEL,OAAO;AACL,YAAM,IAAI,aAAa;QACrB,SAAS;QACT,WAAW,CAAC,IAAI;MACjB,CAAA;IACH;EACF,CAAC;AAED,QAAM,mBAAmB,MAAM,OAAO,QACpC,6BACA;IACE,WAAW;MACT,MAAM;MACN,WAAW,cAAc;MACzB,qBAAqB,cAAc;MACnC;MACA,MAAM;MACN;IACD;EACF,CAAA;AAGH,MAAI,iBAAiB,QAAQ;AAC3B,UAAM,IAAI,aAAa;MACrB,SAAS;MACT,WAAW,iBAAiB;IAC7B,CAAA;EACH;AAEA,SAAO,iBAAiB;AAC1B;AAEA,eAAe,qBAAqB,EAClC,eACA,MACA,QACA,WACA,OAAM,GAC8B;AACpC,QAAM,mBAAmB,MAAM,OAAO,QACpC,4BACA;IACE,WAAW;MACT,MAAM;MACN;MACA,MAAM;MACN,OAAO;QACL,QAAQ,cAAc;QACtB,cAAc,cAAc;MAC7B;IACF;EACF,CAAA;AAGH,MAAI,iBAAiB,QAAQ;AAC3B,UAAM,IAAI,aAAa;MACrB,SAAS;MACT,WAAW,iBAAiB;IAC7B,CAAA;EACH;AAEA,SAAO,iBAAiB;AAC1B;AAEA,SAAS,oBACP,eACA,WAAyC;AAEzC,QAAM,eAAe,EAAC,GAAG,eAAe,GAAG,UAAS;AACpD,QAAM,kBAAkB,CAAA;AAExB,MAAI,cAAc,aAAa,UAAU,WAAW;AAClD,eAAW,KAAK,cAAc,WAAW;AACvC,UAAI,QAAQ;AAEZ,iBAAW,KAAK,UAAU,WAAW;AACnC,YAAI,EAAE,aAAa,EAAG,UAAU;AAC9B,0BAAgB,KAAK,EAAC,GAAG,GAAG,GAAG,EAAC,CAAC;AACjC,kBAAQ;AACR;QACF;MACF;AAEA,UAAI,CAAC,OAAO;AACV,wBAAgB,KAAK,CAAC;MACxB;IACF;AAEA,iBAAa,YAAY;EAC3B;AAEA,SAAO;AACT;;;ACrUA,IAAM,kBAAkB;IACpB,yBAAyB;;;;;;;;;;;;;AAcvB,SAAU,OAAOC,SAAuB;AAC5C,SAAO,eACL,kBAAqC;;AAErC,UAAM,EAAC,SAAS,gBAAgB,UAAU,KAAI,IAAI;AAElD,UAAMC,iBAAgB,mBAAmB,EAAC,QAAAD,QAAM,CAAC;AACjD,UAAM,SAAS,IAAIC,eAAc,EAAC,QAAO,CAAC;AAE1C,QAAI;AACF,YAAM,WAAW,MAAM,OAAO,QAAwB,iBAAiB;QACrE,WAAW,EAAC,IAAI,gBAAgB,QAAO;MACxC,CAAA;AAED,WAAI,oBAAS,SAAT,mBAAe,0BAAf,mBAAsC,WAAW,QAAQ;AAC3D,cAAM,IAAI,aAAa;UACrB,SAAS;UACT,YAAW,oBAAS,SAAT,mBAAe,0BAAf,mBAAsC;QAClD,CAAA;MACH;AAEA,cAAO,oBAAS,SAAT,mBAAe,0BAAf,mBAAsC;IAC/C,SAAS,OAAO;AACd,UAAI,iBAAiB,mBAAmB;AACtC,cAAM,IAAI,aAAa;UACrB,SAAS,MAAM;UACf,YAAW,WAAM,aAAN,mBAAgB;QAC5B,CAAA;MACH,OAAO;AACL,cAAM;MACR;IACF;EACF;AACF;;;AC/CA,IAAM,qBAAqB;EACzB,yBAAyB;;;;;;;;;AAUrB,SAAU,cAAcC,SAAuB;AACnD,SAAO,eAAgB,EACrB,QAAO,GACmB;;AAC1B,QAAI,GAAC,KAAAA,QAAO,WAAP,mBAAe,mCAAkC,CAACA,QAAO,SAAS;AACrE,YAAM,IAAI,aAAa;QACrB,SAAS;QACT,WAAW,CAAA;MACZ,CAAA;IACH;AAEA,UAAMC,iBAAgB,mBAAmB,EAAC,QAAAD,QAAM,CAAC;AACjD,UAAM,SAAS,IAAIC,eAAc,EAAC,QAAO,CAAC;AAE1C,UAAM,WACJ,MAAM,OAAO,QAA8B,kBAAkB;AAE/D,QAAI,GAAC,oBAAS,SAAT,mBAAe,2BAAf,mBAAuC,sBAAqB;AAC/D,aAAO,EAAC,qBAAqB,CAAA,EAAE;IACjC;AAEA,UAAM,sBACJ,SAAS,KAAK,uBAAuB;AACvC,wBAAoB,QAAQ,CAAC,iBAAgB;AAC3C,UAAI,aAAa,WAAW;AAC1B,qBAAa,YAAY,iBAAiB,aAAa,SAAS;MAClE;IACF,CAAC;AAED,WAAO;MACL;;EAEJ;AACF;;;AC/BA,IAAM,+BAA+B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsC/B,SAAU,kBACdC,SAAuB;AAEvB,SAAO,eAAeC,mBACpB,iBAA+C;;AAE/C,UAAM,EACJ,SACA,wBACA,aACA,OACA,gBACA,SAAS,KAAI,IACX;AAEJ,UAAMC,iBAAgB,mBAAmB,EAAC,QAAAF,QAAM,CAAC;AACjD,UAAM,SAAS,IAAIE,eAAc,EAAC,QAAO,CAAC;AAI1C,UAAM,8BAA8B,yBAChC,yBACA,MAAM,qCAAqC,EAAC,QAAQ,OAAM,CAAC;AAE/D,UAAM,YAAwC;MAC5C;MACA;MACA,wBAAwB;;AAE1B,QAAI,gBAAgB;AAClB,gBAAU,iBAAiB;IAC7B;AAEA,QAAI;AACF,YAAM,WAAW,MAAM,OAAO,QAC5B,8BACA;QACE;MACD,CAAA;AAEH,WAAI,oBAAS,SAAT,mBAAe,yBAAf,mBAAqC,WAAW,QAAQ;AAC1D,cAAM,IAAI,aAAa;UACrB,SAAS;UACT,YAAW,oBAAS,SAAT,mBAAe,yBAAf,mBAAqC;QACjD,CAAA;MACH;AAEA,YAAM,kBAAiB,oBAAS,SAAT,mBAAe,yBAAf,mBAAqC;AAC5D,sCAAgC,eAAe,KAAK;AACpD,kCAA4B,eAAe,qBAAqB,KAAK,cAAc;AAEnF,aAAO;IACT,SAAS,OAAO;AACd,UAAI,iBAAiB,mBAAmB;AACtC,cAAM,IAAI,aAAa;UACrB,SAAS,MAAM;UACf,YAAW,WAAM,aAAN,mBAAgB;QAC5B,CAAA;MACH,OAAO;AACL,cAAM;MACR;IACF;EACF;AACF;AAEA,eAAe,qCAAqC,EAClD,QACA,OAAM,GACS;AACf,QAAM,WAAW,MAAM,eAAe,EAAC,QAAQ,OAAM,CAAC;AAEtD,MAAI,CAAC,SAAS,kBAAkB;AAC9B,UAAM,IAAI,aAAa;MACrB,SAAS;MACT,WAAW,CAAA;IACZ,CAAA;EACH;AACA,MAAI,CAAC,SAAS,iBAAiB,QAAQ;AACrC,UAAM,IAAI,aAAa;MACrB,SAAS;MACT,WAAW,CAAA;IACZ,CAAA;EACH;AACA,MAAI,SAAS,kBAAkB;AAC7B,UAAM,8BAA8B,mBAClC,SAAS,gBAAgB;AAE3B,WAAO;EACT;AACA,QAAM,IAAI,aAAa;IACrB,SAAS;IACT,WAAW,CAAA;EACZ,CAAA;AACH;AAEA,SAAS,mBAAmBC,gBAAgC;AAC1D,aAAW,gBAAgBA,gBAAe;AAExC,QAAI,aAAa,WAAW,YAAY,aAAa,WAAW;AAE9D,iBAAW,YAAY,aAAa,WAAW;AAC7C,YAAI,iBAAiB,SAAS,KAAK,gBAAgB;AACjD,iBAAO,SAAS;QAClB;MACF;IACF;EACF;AAEA,QAAM,IAAI,aAAa;IACrB,SAAS;IACT,WAAW,CAAA;EACZ,CAAA;AACH;;;ACnKA,IAAM,sCAAsC;EAC1C,yBAAyB;;;;;;;;;;;;;;AAerB,SAAU,wBACdC,SAAuB;AAEvB,SAAO,eAAeC,yBACpB,QAA4C;;AAE5C,QAAI,CAACD,QAAO,SAAS;AACnB,YAAM,IAAI,aAAa;QACrB,SAAS;QACT,WAAW,CAAA;MACZ,CAAA;IACH;AAEA,UAAM,EACJ,SACA,wBACA,cAAc,EAAC,QAAQ,aAAY,EAAC,IAClC;AAEJ,UAAME,iBAAgB,mBAAmB,EAAC,QAAAF,QAAM,CAAC;AACjD,UAAM,SAAS,IAAIE,eAAc,EAAC,QAAO,CAAC;AAE1C,QAAI;AACF,YAAM,WACJ,MAAM,OAAO,QACX,qCACA;QACE,WAAW;UACT,IAAI;UACJ,cAAc;YACZ;YACA;UACD;QACF;MACF,CAAA;AAGL,WAAI,oBAAS,SAAT,mBAAe,kCAAf,mBAA8C,WAAW,QAAQ;AACnE,cAAM,IAAI,aAAa;UACrB,SAAS;UACT,YAAW,oBAAS,SAAT,mBAAe,kCAAf,mBAA8C;QAC1D,CAAA;MACH;AAEA,YAAM,mBACJ,oBAAS,SAAT,mBAAe,kCAAf,mBAA8C;AAChD,UAAI,mBAAmB,gBAAgB,WAAW;AAChD,wBAAgB,YAAY,iBAAiB,gBAAgB,SAAS;MACxE;AAEA,aAAO;QACL,kBACE,oBAAS,SAAT,mBAAe,kCAAf,mBAA8C;QAChD;;IAEJ,SAAS,OAAO;AACd,UAAI,iBAAiB,mBAAmB;AACtC,cAAM,IAAI,aAAa;UACrB,SAAS,MAAM;UACf,YAAW,WAAM,aAAN,mBAAgB;QAC5B,CAAA;MACH;AAEA,YAAM;IACR;EACF;AACF;;;AClFM,SAAU,eACdC,SAAuB;AAEvB,SAAO;IACL,OAAO,MAAMA,OAAM;IACnB,SAAS,QAAQA,OAAM;IACvB,QAAQ,OAAOA,OAAM;IACrB,eAAe,cAAcA,OAAM;IACnC,mBAAmB,kBAAkBA,OAAM;IAC3C,yBAAyB,wBAAwBA,OAAM;;AAE3D;;;ACfM,SAAUC,iBAAgBC,SAAuB;AACrD,SAAO,eAAe,SAAS,EAC7B,SACA,GAAG,YAAW,GACC;AACf,WAAO,+BAA+BA,OAAM,EAAE;MAC5C,MAAM,mBAAmB;MACzB;MACA,GAAG;IACJ,CAAA;EACH;AACF;;;AChBM,SAAU,YAAYC,SAAuB;AACjD,SAAO;IACL,UAAUC,iBAAgBD,OAAM;;AAEpC;;;ACCM,SAAUE,iBAAgBC,SAAuB;AACrD,SAAO,eAAe,SAAS,EAC7B,SACA,GAAG,YAAW,GACC;AACf,WAAO,+BAA+BA,OAAM,EAAE;MAC5C,MAAM,mBAAmB;MACzB;MACA,GAAG;IACJ,CAAA;EACH;AACF;;;AChBM,SAAU,mBAAmBC,SAAuB;AACxD,SAAO;IACL,UAAUC,iBAAgBD,OAAM;;AAEpC;;;ACqDM,SAAU,WAId,EACA,QACA,eACA,GAAGE,QAAM,GAC6C;AAKtD,QAAM,YAAY,EAAC,GAAGA,SAAQ,QAAQ,cAAa;AACnD,QAAM,kBAAkB,eAAe,SAAS;AAEhD,QAAM,UAAU;IACd,QAAQ;IACR,SAAS,cAAc,eAAe;IACtC,MAAM,YAAY,eAAe;IACjC,SAAS,eAAe,eAAe;IACvC,OAAO,aAAa,eAAe;IACnC,UAAU,gBAAgB,eAAe;IACzC,SAAS,eAAe,eAAe;IACvC,MAAM,YAAY,eAAe;IACjC,oBAAoB,mBAAmB,eAAe;IACtD,QAAQ,OAAO,eAAe;IAC9B,MAAM,CAAA;;AAGR,MAAI,eAAe;AACjB,YAAQ,OAAO,kBAAkB;MAC/B,WAAW;MACX,QAAQ;MACR,YAAY,gBAAgB,EAAC,QAAQ,gBAAe,CAAC;IACtD,CAAA;EACH;AAEA,UAAQ,OACL,KACC,WAAW,2BAA2B,iBAAiB,sBAAqB,CAAE,EAAE,EAEjF,MAAM,CAAC,QAAQ,QAAQ,IAAI,GAAG,CAAC;AAElC,yBAAuB,iBAAiB,QAAQ,MAAM;AAEtD,SAAO;AACT;;;AC1GM,SAAU,gBAAgB,SAAoB;AAClD,QAAM,EAAC,eAAe,eAAe,eAAe,aAAY,IAAI;AAEpE,MAAI,gBAAgB,MAAM,KAAK,aAAa,QAAO,CAAE,EAAE,SAAS,GAAG;AACjE,WAAO;EACT;AAEA,SAAO,IAAI,QAAQ;IACjB,GAAI,gBAAgB,MAAM,KAAK,cAAc,QAAO,CAAE,IAAI,CAAA;IAC1D,GAAI,gBAAgB,MAAM,KAAK,cAAc,QAAO,CAAE,IAAI,CAAA;IAC1D,GAAI,gBAAgB,MAAM,KAAK,cAAc,QAAO,CAAE,IAAI,CAAA;EAC3D,CAAA;AACH;;;;ACdM,SAAU,cAAc,OAAU;AACtC,MACE,MAAM,YAAY,SAAS,mBAC3B,MAAM,YAAY,SAAS,qBAC3B;AACA,eACEC,wBAAA,OAAA,EACE,yBAAyB,EAAC,QAAQ,MAAM,QAAQ,oBAAmB,EAAC,CAAA;EAG1E;AAEA,QAAM;AACR;;;ACPO,IAAM,WAAW;;;;;;;;;;;;;;;EAetB,OAAO;;;;;;;;;;;;;;;EAgBP,SAAS;;;;ACrCJ,IAAM,gCAAgC;;;SCI7B,wBAAwB,EAAC,KAAK,QAAAC,QAAM,GAAc;AAChE,SAAO,eAAe,iBAAiB,EAAC,QAAO,GAA0B;AACvE,WAAO,IAAI,SACR,SAAS,EAAC,QAAO,CAAC,EAClB,KAAK,CAAC,aAAY;AACjB,aAAO,QAAQ,QAAQ,EAAE,QAAQ,CAAC,CAAC,OAAO,YAAY,MAAK;AACzD,qBAAa,QAAQ,CAAC,EAAC,SAAS,GAAG,KAAI,MAAK;AAC1C,cAAI,SAAS;AACX,YAAAA,QAAO,MAAM,sBAAsB;cACjC;cACA,MAAM,QAAQ;cACd,WAAW,KAAK;YACjB,CAAA;UACH,OAAO;AACL,YAAAA,QAAO,MAAM,8BAA8B;cACzC;cACA,MAAM,QAAQ;cACd,QAAQ,KAAK,UAAU,KAAK,MAAM;YACnC,CAAA;UACH;QACF,CAAC;MACH,CAAC;AAED,aAAO;IACT,CAAC,EACA,MAAM,CAAC,UAAS;;AACf,YAAM,kBACJ,iBAAM,SAAN,mBAAY,WAAZ,mBAAoB,kBAAiB,CAAA;AAEvC,YAAM,YAAY,cAAc,KAC9B,CAAC,EAAC,YAAY,EAAC,KAAI,EAAC,MAAM,SAAS,WAAW;AAGhD,UAAI,WAAW;AACb,QAAAA,QAAO,MAAM,+BAA+B;UAC1C,MAAM,QAAQ;UACd,OAAO,KAAK,UAAU,KAAK;QAC5B,CAAA;MACH,OAAO;AACL,cAAM;MACR;IACF,CAAC;EACL;AACF;;;ACxCM,SAAU,yBACd,QACAC,UACA,cAAwB,CAAA,GAAE;AAE1B,QAAM,EAAC,QAAAC,SAAQ,QAAAC,QAAM,IAAI;AAEzB,SAAO,SAAS,kBAAkB,UAAQ;AACxC,UAAM,SAASF,SAAQ,QAAQ,IAAI,QAAQ;AAC3C,QAAI,UAAU,WAAWE,QAAO,QAAQ;AACtC,MAAAD,QAAO,MACL,4DAA4D;AAG9D,YAAM,iBAAiB,oBAAI,IAAI;QAC7B;QACA;QACA,GAAG;MACJ,CAAA;AAED,eAAS,QAAQ,IAAI,+BAA+B,GAAG;AACvD,eAAS,QAAQ,IACf,gCACA,CAAC,GAAG,cAAc,EAAE,KAAK,IAAI,CAAC;AAEhC,eAAS,QAAQ,IAAI,iCAAiC,iBAAiB;IACzE;AAEA,WAAO;EACT;AACF;;;;ICjCa,uBAAuB,CAAC,QAAqB,QAAmB;AAC3E,QAAM,EAAC,QAAAE,QAAM,IAAI;AAIjB,QAAM,eAAe,IAAI;AACzB,eAAa,OAAO,UAAU;AAC9B,eAAa,IACX,kBACA,GAAGA,QAAO,MAAM,GAAG,IAAI,QAAQ,IAAI,aAAa,SAAQ,CAAE,EAAE;AAM9D,QAAM,SACJ,GAAGA,QAAO,KAAK,qBAAqB,IAAI,aAAa,SAAQ,CAAE,EAAE;AAErE;;;ACZM,SAAU,6BAA6B,EAC3C,QACA,SAAAC,UACA,eAAe,MAAK,GACe;AACnC,QAAM,EAAC,KAAK,QAAAC,SAAQ,QAAAC,QAAM,IAAI;AAE9B,QAAM,oBAAoB,CAACF,SAAQ,QAAQ,IAAI,eAAe;AAC9D,MAAI,mBAAmB;AACrB,WAAO,qBAAqB,EAAc,QAAAE,QAAM,GAAG,IAAI,IAAIF,SAAQ,GAAG,CAAC;EACzE;AAEA,QAAM,IAAI,SAAS,QAAW;IAC5B,QAAQ;IACR,YAAY;IACZ,SAAS,eAAe,+BAA+B,CAAA;EACxD,CAAA;AACH;;;AC3BM,SAAU,mBAAmBG,UAAgB;AACjD,QAAM,MAAM,IAAI,IAAIA,SAAQ,GAAG;AAC/B,SAAO,IAAI,aAAa,IAAI,MAAM;AACpC;;;ACSO,eAAe,qBACpB,QACAC,UACA,OACA,EAAC,gBAAgB,MAAM,eAAe,KAAI,IAAiC,CAAA,GAAE;AAE7E,QAAM,EAAC,KAAK,QAAAC,QAAM,IAAI;AACtB,QAAM,OAAO,mBAAmBD,QAAO;AACvC,EAAAC,QAAO,MAAM,4BAA4B,EAAC,KAAI,CAAC;AAE/C,MAAI;AACF,UAAM,UAAU,MAAM,IAAI,QAAQ,mBAAmB,OAAO;MAC1D;IACD,CAAA;AACD,IAAAA,QAAO,MAAM,sCAAsC;MACjD;MACA,SAAS,KAAK,UAAU,OAAO;IAChC,CAAA;AAED,WAAO;EACT,SAAS,OAAO;AACd,IAAAA,QAAO,MAAM,qCAAqC,MAAM,OAAO,IAAI;MACjE;IACD,CAAA;AAED,UAAM,6BAA6B,EAAC,QAAQ,SAAAD,UAAS,aAAY,CAAC;EACpE;AACF;;;ACvCA,IAAM,sBAAsB;AAEtB,SAAU,sBAAsBE,UAAgB;AAFtD;AAGE,UAAO,KAAAA,SAAQ,QAAQ,IAAI,eAAe,MAAnC,mBAAsC,QAAQ,WAAW;AAClE;AAEM,SAAU,4BAA4BA,UAAgB;AAC1D,QAAM,MAAM,IAAI,IAAIA,SAAQ,GAAG;AAE/B,SAAO,IAAI,aAAa,IAAI,mBAAmB;AACjD;;;ACNA,IAAM,yBAAyB;AAC/B,IAAM,4BAA4B;AAElC,IAAM,sBAAsB,CAAC,wBAAwB,yBAAyB;SAE9D,oBACd,EAAC,QAAAC,QAAM,GACPC,UAAgB;AAEhB,QAAM,YAAYA,SAAQ,QAAQ,IAAI,YAAY,KAAK;AAIvD,MAAI,oBAAoB,KAAK,CAAC,UAAU,MAAM,KAAK,SAAS,CAAC,GAAG;AAC9D,IAAAD,QAAO,MAAM,wCAAwC;AACrD;EACF;AAEA,MAAI,MAAM,SAAS,GAAG;AACpB,IAAAA,QAAO,MAAM,sCAAsC;AACnD,UAAM,IAAI,SAAS,QAAW,EAAC,QAAQ,KAAK,YAAY,OAAM,CAAC;EACjE;AACF;;;SCtBgB,wBACd,QACAE,UACA,aAAsB;AAEtB,MAAIA,SAAQ,WAAW,WAAW;AAChC,UAAM,oBAAoB,yBACxB,QACAA,UACA,WAAW;AAGb,UAAM,kBACJ,IAAI,SAAS,MAAM;MACjB,QAAQ;MACR,SAAS;QACP,0BAA0B;MAC3B;IACF,CAAA,CAAC;EAEN;AACF;A;;;;;;;;ACvBO,eAAe,UACpB,QACAC,UACA,UACA,MAAY;AAEZ,QAAM,EAAC,KAAK,QAAAC,QAAM,IAAI;AAEtB,QAAM,MAAM,IAAI,KAAK,MAAM;IACzB;IACA,cAAcA,QAAO,KAAK;IAC1B;IACA,YAAYD;EACb,CAAA;AACH;;;;SCZgB,uBACd,QACAE,UACA,MAAY;AAEZ,QAAM,EAAC,KAAK,QAAAC,QAAM,IAAI;AACtB,QAAM,MAAM,IAAI,IAAID,SAAQ,GAAG;AAE/B,QAAM,cAAc,IAAI;AAExB,QAAM,OAAO,IAAI,MAAM,aAAa,YAAY,IAAI,MAAM,CAAE;AAE5D,cAAY,IAAI,QAAQ,IAAI;AAE5B,MAAI,cAAc,GAAGC,QAAO,KAAK,IAAI,SAAS,IAAI;AAElD,MAAI,MAAM;AACR,gBAAY,IAAI,QAAQ,IAAI;AAC5B,kBAAc,GAAG,WAAW,SAAS,IAAI;EAC3C;AACA,cAAY,IAAI,cAAc,WAAW;AAEzC,QAAM,SAAS,GAAGA,QAAO,KAAK,cAAc,IAAI,YAAY,SAAQ,CAAE,EAAE;AAC1E;;;ACzBM,SAAU,6BAA6B,aAAmB;AAC9D,QAAM,IAAI,SAAS,QAAW;IAC5B,QAAQ;IACR,YAAY;IACZ,SAAS,oBAAoB,WAAW;EACzC,CAAA;AACH;AAEM,SAAU,oBAAoB,KAAW;AAC7C,SAAO,IAAI,QAAQ,EAAC,CAAC,iBAAiB,GAAG,IAAG,CAAC;AAC/C;;;ACNO,eAAe,mBACpB,QACAC,UACA,MACA,WAAW,OAAK;AAEhB,QAAM,EAAC,QAAAC,QAAM,IAAI;AAEjB,QAAM,MAAM,IAAI,IAAID,SAAQ,GAAG;AAC/B,QAAME,qBAAoB,IAAI,aAAa,IAAI,UAAU,MAAM;AAC/D,QAAM,eAAeF,SAAQ,QAAQ,IAAI,eAAe;AAExD,MAAI,cAAc;AAChB,UAAM,cAAc,IAAI,IAAIC,QAAO,KAAK,MAAMA,QAAO,MAAM;AAC3D,gBAAY,aAAa,IAAI,QAAQ,IAAI;AACzC,iCAA6B,YAAY,SAAQ,CAAE;EACrD,WAAWC,oBAAmB;AAC5B,2BAAuB,QAAQF,UAAS,IAAI;EAC9C,OAAO;AACL,UAAM,MAAM,UAAU,QAAQA,UAAS,UAAU,IAAI;EACvD;AACF;;;ACvBO,eAAe,sBACpB,QACA,SAAgB;AAEhB,QAAM,EAAC,QAAAG,SAAQ,QAAAC,QAAM,IAAI;AAEzB,EAAAD,QAAO,MAAM,2CAA2C,QAAQ,EAAE,IAAI;IACpE,MAAM,QAAQ;EACf,CAAA;AAED,UAAQ,cAAc;AACtB,QAAMC,QAAO,eAAgB,aAAa,OAAO;AACnD;;;SCRgB,qBACd,QACAC,UACA,SAAgB;AAEhB,SAAO,eAAe,cAAc,SAA6B;AAC/D,UAAM,EAAC,KAAK,QAAAC,QAAM,IAAI;AAEtB,IAAAA,QAAO,MAAM,sBAAsB,EAAC,MAAM,QAAQ,MAAM,GAAG,QAAO,CAAC;AAEnE,QAAI;AACF,aAAO,MAAM,IAAI,QAAQ,OAAO;QAC9B;QACA,gBAAgB,QAAQ;QACxB,QAAQ,QAAQ;QAChB,SAAS,QAAQ;MAClB,CAAA;IACH,SAAS,OAAO;AACd,UAAI,iBAAiB,qBAAqB,MAAM,SAAS,SAAS,KAAK;AACrE,QAAAA,QAAO,MAAM,+CAA+C;UAC1D,MAAM,QAAQ;QACf,CAAA;AACD,cAAM,sBAAsB,QAAQ,OAAO;AAC3C,cAAM,MAAM,mBAAmB,QAAQD,UAAS,QAAQ,IAAI;MAC9D,OAAO;AACL,cAAM;MACR;IACF;EACF;AACF;A;;;SCxBgB,sBACd,QACAE,UACA,SAAgB;AAEhB,QAAM,EAAC,KAAK,QAAAC,QAAM,IAAI;AAEtB,SAAO,eAAe,eAAe,SAAsC;AACzE,UAAM,aAAa;MACjB,MAAM,QAAQ;MACd,OAAO,QAAQ;MACf,QAAQ,QAAQ;;AAGlB,IAAAA,QAAO,MAAM,iCAAiC,UAAU;AAExD,QAAI;AACJ,QAAI;AACF,aAAO,MAAM,IAAI,QAAQ,MAAM;QAC7B;QACA,OAAO,QAAQ;QACf,QAAQ,QAAQ;QAChB,cAAc;MACf,CAAA;IACH,SAAS,OAAO;AACd,UAAI,iBAAiB,qBAAqB,MAAM,SAAS,SAAS,KAAK;AACrE,QAAAA,QAAO,MAAM,+CAA+C,UAAU;AAEtE,cAAM,sBAAsB,QAAQ,OAAO;AAC3C,cAAM,MAAM,mBAAmB,QAAQD,UAAS,QAAQ,IAAI;MAC9D,OAAO;AACL,cAAM;MACR;IACF;AAEA,QAAI,CAAC,KAAK,kBAAkB;AAC1B,MAAAC,QAAO,MAAM,wBAAwB,UAAU;AAC/C,YAAM,MAAM,QAAQ,UAAU,IAAI,MAAM,sBAAsB,CAAC;IACjE;AAEA,IAAAA,QAAO,MAAM,2BAA2B,UAAU;AAElD,WAAO;EACT;AACF;A;;;;;;ACpDM,SAAU,iBACd,QACAC,UACA,KACA,MAAY;AAEZ,QAAM,EAAC,QAAAC,SAAQ,QAAAC,QAAM,IAAI;AAEzB,EAAAA,QAAO,MAAM,0BAA0B,EAAC,MAAM,IAAG,CAAC;AAElD,QAAM,aAAa,IAAI,IAAIF,SAAQ,GAAG;AACtC,QAAMG,qBAAoB,WAAW,aAAa,IAAI,UAAU,MAAM;AACtE,QAAM,eAAeH,SAAQ,QAAQ,IAAI,eAAe;AAExD,MAAI,cAAc;AAKhB,UAAM,IAAI,SAAS,QAAW;MAC5B,QAAQ;MACR,YAAY;MACZ,SAAS,oBAAoB,GAAG;IACjC,CAAA;EACH,WAAWG,oBAAmB;AAC5B,UAAMC,UAAS,IAAI,gBAAgB;MACjC;MACA,MAAM,WAAW,aAAa,IAAI,MAAM;MACxC,YAAY;IACb,CAAA;AAED,UAAM,SAAS,GAAGH,QAAO,KAAK,cAAc,IAAIG,QAAO,SAAQ,CAAE,EAAE;EACrE,OAAO;AAEL,UAAM,SAAS,GAAG;EACpB;AACF;;;SC3BgB,sBACd,QACAC,UACA,SAAgB;AAEhB,SAAO,eAAe,eAAe,EACnC,MACA,QACA,WACA,GAAG,UAAS,GACkB;AAC9B,UAAM,EAAC,KAAK,QAAAC,QAAM,IAAI;AAEtB,IAAAA,QAAO,KAAK,sBAAsB;MAChC,MAAM,QAAQ;MACd;MACA;MACA;IACD,CAAA;AAED,QAAI;AACJ,QAAI;AACF,eAAS,MAAM,IAAI,QAAQ,QAAQ;QACjC;QACA;QACA;QACA;QACA,cAAc;QACd,GAAG;MACJ,CAAA;IACH,SAAS,OAAO;AACd,UAAI,iBAAiB,qBAAqB,MAAM,SAAS,SAAS,KAAK;AACrE,QAAAA,QAAO,MAAM,+CAA+C;UAC1D,MAAM,QAAQ;QACf,CAAA;AACD,cAAM,sBAAsB,QAAQ,OAAO;AAC3C,cAAM,MAAM,mBAAmB,QAAQD,UAAS,QAAQ,IAAI;MAC9D,OAAO;AACL,cAAM;MACR;IACF;AAEA,UAAM,iBACJ,QACAA,UACA,OAAO,iBACP,QAAQ,IAAI;EAEhB;AACF;A;;;SCtDgB,oBACd,QACAE,UACA,SAAgB;AAEhB,SAAO,eAAe,aACpB,UAAuC,CAAA,GAAE;AAEzC,UAAM,EAAC,KAAK,QAAAC,QAAM,IAAI;AAEtB,IAAAA,QAAO,MAAM,0BAA0B,EAAC,MAAM,QAAQ,MAAM,GAAG,QAAO,CAAC;AAEvE,QAAI;AACF,aAAO,MAAM,IAAI,QAAQ,MAAM;QAC7B;QACA,OAAO,QAAQ;QACf,QAAQ,QAAQ;QAChB,cAAc;MACf,CAAA;IACH,SAAS,OAAO;AACd,UAAI,iBAAiB,qBAAqB,MAAM,SAAS,SAAS,KAAK;AACrE,QAAAA,QAAO,MAAM,+CAA+C;UAC1D,MAAM,QAAQ;QACf,CAAA;AACD,cAAM,sBAAsB,QAAQ,OAAO;AAC3C,cAAM,MAAM,mBAAmB,QAAQD,UAAS,QAAQ,IAAI;MAC9D,OAAO;AACL,cAAM;MACR;IACF;EACF;AACF;A;;;SChCgB,yBACd,QACAE,UACA,SAAgB;AAEhB,SAAO,eAAeC,mBAAkB,SAAiC;AACvE,UAAM,EAAC,KAAK,QAAAC,QAAM,IAAI;AAEtB,IAAAA,QAAO,MAAM,uBAAuB,EAAC,MAAM,QAAQ,MAAM,GAAG,QAAO,CAAC;AAEpE,QAAI;AACF,aAAO,MAAM,IAAI,QAAQ,kBAAkB;QACzC,GAAG;QACH;MACD,CAAA;IACH,SAAS,OAAO;AACd,UAAI,iBAAiB,qBAAqB,MAAM,SAAS,SAAS,KAAK;AACrE,QAAAA,QAAO,MAAM,+CAA+C;UAC1D,MAAM,QAAQ;QACf,CAAA;AACD,cAAM,sBAAsB,QAAQ,OAAO;AAC3C,cAAM,MAAM,mBAAmB,QAAQF,UAAS,QAAQ,IAAI;MAC9D,OAAO;AACL,cAAM;MACR;IACF;EACF;AACF;A;;;SCtBgB,+BACd,QACAG,UACA,SAAgB;AAEhB,SAAO,eAAeC,yBACpB,SAAuC;AAEvC,UAAM,EAAC,KAAK,QAAAC,QAAM,IAAI;AAEtB,IAAAA,QAAO,MAAM,6CAA6C;MACxD,MAAM,QAAQ;MACd,GAAG;IACJ,CAAA;AAED,QAAI;AACJ,QAAI;AACF,eAAS,MAAM,IAAI,QAAQ,wBAAwB;QACjD;QACA,wBAAwB,QAAQ;QAChC,cAAc,QAAQ;MACvB,CAAA;IACH,SAAS,OAAO;AACd,UAAI,iBAAiB,qBAAqB,MAAM,SAAS,SAAS,KAAK;AACrE,QAAAA,QAAO,MAAM,+CAA+C;UAC1D,MAAM,QAAQ;QACf,CAAA;AACD,cAAM,sBAAsB,QAAQ,OAAO;AAC3C,cAAM,MAAM,mBAAmB,QAAQF,UAAS,QAAQ,IAAI;MAC9D,OAAO;AACL,cAAM;MACR;IACF;AAEA,UAAM,iBACJ,QACAA,UACA,OAAO,iBACP,QAAQ,IAAI;EAEhB;AACF;;;AC7CM,SAAU,qBAAqB,EACnC,QACA,mBACA,QAAO,GACY;AACnB,SAAO,eAAe,MAAM,WAAW,SAAO;AAC5C,UAAM,SAAS,IAAI,OAAO,IAAI,QAAQ,QAAQ;MAC5C;MACA,YAAY,mCAAS;IACtB,CAAA;AAED,QAAI;AAEF,YAAM,cAAc,MAAM,OAAO,QAAQ,WAAW;QAClD,WAAW,mCAAS;QACpB,UAAS,mCAAS,SAAQ,QAAQ,QAAQ,IAAI;QAC9C,SAAS,mCAAS;QAClB,QAAQ,mCAAS;MAClB,CAAA;AAED,aAAO,IAAI,SAAS,KAAK,UAAU,WAAW,CAAC;IACjD,SAAS,OAAO;AACd,UAAI,mBAAmB;AACrB,cAAM,MAAM,kBAAkB,EAAC,OAAO,QAAQ,QAAO,CAAC;MACxD;AAEA,YAAM;IACR;EACF;AACF;;;ACzBM,SAAU,mBAAmB,EACjC,QACA,mBACA,QAAO,GACY;AACnB,SAAO;IACL,SAAS,qBAAqB,EAAC,QAAQ,SAAS,kBAAiB,CAAC;;AAEtE;;;SCZgB,sBACd,SACA,QACA,mBAAyC;AAEzC,SAAO,mBAAmB;IACxB;IACA;IACA;EACD,CAAA;AACH;;;;ACfO,eAAe,2BACpBG,UACA,QACA,iBAAyB;AAEzB,QAAM,EAAC,IAAG,IAAI;AACd,QAAM,MAAM,IAAI,IAAIA,SAAQ,GAAG;AAE/B,QAAM,OAAO,IAAI,MAAM,aAAa,IAAI,aAAa,IAAI,MAAM,CAAE;AACjE,QAAM,OAAO,IAAI,MAAM,aAAa,IAAI,aAAa,IAAI,MAAM,CAAE;AAEjE,QAAM,cAAc,IAAI,OAAO,gBAC3B,MAAM,IAAI,KAAK,kBAAkB,EAAC,YAAYA,SAAO,CAAC,IACtD,UAAU,IAAI,SAAS,mBAAmB,IAAI,CAAC;AAEnD,QAAM,SAAS,aAAa,EAAC,SAAS,gBAAe,CAAC;AACxD;;;AChBO,IAAM,gCAAgC,OAC3C,QACAC,aACE;AACF,QAAM,EAAC,KAAK,QAAAC,SAAQ,QAAAC,QAAM,IAAI;AAC9B,QAAM,MAAM,IAAI,IAAIF,SAAQ,GAAG;AAE/B,QAAM,OAAO,IAAI,aAAa,IAAI,MAAM;AAExC,MAAI,IAAI,OAAO,iBAAiB,IAAI,aAAa,IAAI,UAAU,MAAM,KAAK;AACxE,IAAAC,QAAO,MAAM,+CAA+C,EAAC,KAAI,CAAC;AAClE,UAAM,2BAA2BD,UAAS,EAAC,IAAmB,CAAC;EACjE;AACF;;;ACbA,IAAMG,uBAAsB;AAErB,IAAM,0CAA0C,OACrD,QACAC,aACE;AACF,QAAM,EAAC,KAAK,QAAAC,QAAM,IAAI;AACtB,QAAM,MAAM,IAAI,IAAID,SAAQ,GAAG;AAE/B,QAAM,OAAO,IAAI,aAAa,IAAI,MAAM;AACxC,QAAM,0BAA0B,IAAI,aAAa,IAAID,oBAAmB;AACxE,QAAM,aAAa,IAAI,aAAa,IAAI,UAAU,MAAM;AAExD,MAAI,IAAI,OAAO,iBAAiB,cAAc,CAAC,yBAAyB;AACtE,IAAAE,QAAO,MACL,gEACA,EAAC,KAAI,CAAC;AAER,yBAAqB,QAAQ,GAAG;EAClC;AACF;A;;;;;ACjBM,SAAU,kCACd,QAAmB;AAEnB,QAAM,EAAC,KAAK,QAAAC,QAAM,IAAI;AAEtB,SAAO,SAAUC,UAAkB,SAAgB;AACjD,UAAM,EAAC,aAAY,IAAI,IAAI,IAAIA,SAAQ,GAAG;AAC1C,UAAM,OAAO,IAAI,MAAM,aAAa,aAAa,IAAI,MAAM,CAAE;AAE7D,+BAA2B,SAASD,QAAO,eAAe,IAAI;EAChE;AACF;SAEgB,2BACd,SACA,eACA,MAA+B;AAE/B,MAAI,MAAM;AACR,YAAQ,IACN,QACA,mFAAmF;EAEvF;AAEA,MAAI,eAAe;AACjB,QAAI,MAAM;AACR,cAAQ,IACN,2BACA,2BAA2B,IAAI,kGAAkG;IAErI;EACF,OAAO;AACL,YAAQ,IAAI,2BAA2B,yBAAyB;EAClE;AACF;;;AChCA,IAAM,iBAAiB;AACvB,IAAM,uBAAuB;AAC7B,IAAM,uBAAuB;AAC7B,IAAM,kBAAkB,CAAC,UAAU,OAAO;AAE1C,SAAS,OACP,QACA,aACA,aAAkC,MAAI;AAEtC,MAAI,OAAO,gBAAgB,UAAU;AACnC,WAAO;EACT;AAEA,MACE,eAAe,KAAK,WAAW,KAC/B,qBAAqB,KAAK,WAAW,GACrC;AACA,WAAO;EACT;AAEA,MAAI;AAEJ,MAAI;AACF,UAAM,IAAI,IAAI,aAAa,MAAM;EACnC,SAAS,OAAO;AACd,WAAO;EACT;AAEA,MAAI,qBAAqB,KAAK,IAAI,QAAQ,GAAG;AAC3C,WAAO;EACT;AAEA,MAAI,CAAC,gBAAgB,SAAS,IAAI,QAAQ,GAAG;AAC3C,WAAO;EACT;AAEA,MAAI,cAAc,IAAI,aAAa,UAAU;AAC3C,WAAO;EACT;AAEA,SAAO;AACT;AAEM,SAAU,oBACd,QACA,aACA,UAAsB,CAAA,GAAgB;AAEtC,MAAI,OAAO,QAAQ,aAAa,QAAQ,UAAU,GAAG;AACnD,WAAO,IAAI,IAAI,aAAa,MAAM;EACpC,WAAW,QAAQ,mBAAmB,OAAO;AAC3C,WAAO;EACT,OAAO;AACL,UAAM,IAAI,aAAa,mCAAmC;EAC5D;AACF;;;ACrDM,SAAU,gBACd,EAAC,QAAAE,QAAM,GACPC,UACA,YAA8B;AAE9B,MAAI,mBAAmB;AACvB,MAAI,YAAY;AACd,UAAM,cAAc,oBAAoBD,QAAO,QAAQ,WAAW,GAAG;AAErE,UAAM,SAAS,WAAW,UAAU;AAEpC,uBAAmB,uBAAuB,KAAK,UAC7C,YAAY,SAAQ,CAAE,CACvB,KAAK,KAAK,UAAU,MAAM,CAAC;EAC9B;AAEA,QAAM,kBAAkB,IAAI,QAAQ;IAClC,gBAAgB;EACjB,CAAA;AACD,6BACE,iBACAA,QAAO,eACP,IAAI,IAAIC,SAAQ,GAAG,EAAE,aAAa,IAAI,MAAM,CAAC;AAG/C,QAAM,IAAI,SACR;8BAC0BD,QAAO,MAAM,UAAU,aAAY,CAAE;QAC3D,gBAAgB;OAEpB,EAAC,SAAS,gBAAe,CAAC;AAE9B;;;SCdgB,gBACd,QACAE,UACA,MAAY;AAEZ,QAAM,EAAC,QAAAC,SAAQ,QAAAC,QAAM,IAAI;AAEzB,SAAO,SAASC,WAAS,KAAK,MAAkB;AAC9C,UAAM,EAAC,aAAY,IAAI,IAAI,IAAIH,SAAQ,GAAG;AAC1C,UAAM,EAAC,KAAK,WAAW,OAAM,IAAI,SAAS;MACxC;MACA;MACA,MAAMC,QAAO;MACb;MACA;IACD,CAAA;AAED,IAAAC,QAAO,MAAM,eAAe,EAAC,MAAM,KAAK,UAAU,SAAQ,EAAE,CAAC;AAE7D,UAAM,eAAe,UAAU,WAAWD,QAAO;AACjD,QAAI,gBAAgB,IAAI,WAAW,GAAG,GAAG;AACvC,mBAAa,QAAQ,CAAC,OAAO,QAAO;AAClC,YAAI,CAAC,UAAU,aAAa,IAAI,GAAG,GAAG;AACpC,oBAAU,aAAa,IAAI,KAAK,KAAK;QACvC;MACF,CAAC;IACH;AAEA,QAAI,WAAW,SAAS;AACtB,UAAI,gBAAgBD,QAAO,GAAG;AAC5B,cAAM,gBAAgB,QAAQA,UAAS;UACrC,KAAK,UAAU,SAAQ;UACvB;QACD,CAAA;MACH,OAAO;AACL,eAAOI,SAAc,UAAU,SAAQ,GAAI,IAAI;MACjD;IACF,WAAW,cAAcJ,QAAO,GAAG;AACjC,YAAM,6BAA6B,UAAU,SAAQ,CAAE;IACzD,WAAW,kBAAkBA,QAAO,GAAG;AACrC,YAAM,gBAAgB,QAAQA,UAAS;QACrC,KAAK,UAAU,SAAQ;QACvB;MACD,CAAA;IACH;AACA,WAAOI,SAAc,KAAK,IAAI;EAChC;AACF;AAEA,SAAS,gBAAgBJ,UAAgB;AACvC,SACE,QAAQ,sBAAsBA,QAAO,CAAC,KACtCA,SAAQ,QAAQ,IAAI,kBAAkB;AAE1C;AAEA,SAAS,cAAcA,UAAgB;AACrC,QAAM,QAAQA,SAAQ,WAAW;AACjC,QAAM,qBAAqB,QAAQ,sBAAsBA,QAAO,CAAC;AAEjE,SACE,sBACA,CAAC,gBAAgBA,QAAO,MACvB,CAAC,kBAAkBA,QAAO,KAAK,CAAC;AAErC;AAEA,SAAS,kBAAkBA,UAAgB;AACzC,QAAM,EAAC,aAAY,IAAI,IAAI,IAAIA,SAAQ,GAAG;AAE1C,SAAO,aAAa,IAAI,UAAU,MAAM;AAC1C;AAEA,SAAS,SAAS,EAAC,QAAQ,MAAM,MAAM,MAAM,IAAG,GAAkB;AAChE,MAAI,SACF,OAAO,SAAS,aAAY,6BAAM,UAAS,KAAK,SAAS;AAE3D,MAAI,kBAAkB,GAAG,GAAG;AAC1B,UAAM,EAAC,QAAAC,QAAM,IAAI;AAEjB,UAAM,YAAY,mBAAmB,GAAG;AACxC,UAAM,gBAAgB,KAAK,QAAQ,kBAAkB,EAAE;AAEvD,QAAI,CAAC,QAAQ;AACX,eAASA,QAAO,gBAAgB,YAAY;IAC9C;AAEA,WAAO;MACL,KAAK,IAAI,IACP,mCAAmC,aAAa,GAAG,SAAS,EAAE;MAEhE;;EAEJ,OAAO;AACL,WAAO;MACL,KAAK,IAAI,IAAI,KAAK,IAAI;MACtB,QAAQ,UAAU;;EAEtB;AACF;AAEA,IAAM,cAAc;AAEpB,SAAS,kBAAkB,KAAW;AACpC,SAAO,YAAY,KAAK,GAAG;AAC7B;AAEA,SAAS,mBAAmB,KAAiB;AAC3C,QAAM,YAAY,uBAAuB,IAAI,IAAI,GAAG,CAAC,EAAE;AACvD,SAAO,UAAU,QAAQ,aAAa,GAAG;AAC3C;AAEA,IAAM,8BAA8B;EAClC;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;;AAGF,SAAS,uBAAuB,KAAiB;AAC/C,QAAM,SAAS,IAAI,IAAI,GAAG;AAC1B,8BAA4B,QAAQ,CAAC,UACnC,OAAO,aAAa,OAAO,KAAK,CAAC;AAEnC,SAAO;AACT;;;;AC/JM,SAAU,0BACd,QACAI,UAAgB;AAEhB,QAAM,EAAC,KAAK,QAAAC,SAAQ,QAAAC,QAAM,IAAI;AAE9B,MAAID,QAAO,eAAe;AACxB,UAAM,MAAM,IAAI,IAAID,SAAQ,GAAG;AAC/B,UAAM,OAAO,IAAI,MAAM,aAAa,IAAI,aAAa,IAAI,MAAM,CAAE;AACjE,QAAI,CAAC,MAAM;AACT,MAAAE,QAAO,MAAM,sDAAsD;QACjE;MACD,CAAA;AACD,YAAM,oBAAoBF,UAAS,MAAM;IAC3C;AAEA,UAAM,OAAO,IAAI,MAAM,aAAa,IAAI,aAAa,IAAI,MAAM,CAAE;AACjE,QAAI,CAAC,MAAM;AACT,MAAAE,QAAO,MAAM,2CAA2C;QACtD;QACA,MAAM,IAAI,aAAa,IAAI,MAAM;MAClC,CAAA;AACD,YAAM,oBAAoBF,UAAS,MAAM;IAC3C;EACF;AACF;AAEA,SAAS,oBAAoBA,UAAkB,QAAmB;AAChE,QAAM,EAAC,QAAAC,SAAQ,QAAAC,QAAM,IAAI;AAEzB,QAAM,EAAC,SAAQ,IAAI,IAAI,IAAIF,SAAQ,GAAG;AACtC,MAAI,aAAaC,QAAO,KAAK,WAAW;AACtC,UAAM,UACJ,8EACKA,QAAO,KAAK,SAAS;AAE5B,IAAAC,QAAO,MAAM,OAAO;AACpB,UAAM,IAAI,SAAS,SAAS,EAAC,QAAQ,IAAG,CAAC;EAC3C;AAEA,QAAM,SAASD,QAAO,KAAK,SAAS;AACtC;A;;;ACvCO,eAAe,sBACpB,QACA,MACA,iBAA2B,CAAA,GAAE;AAE7B,QAAM,aAAa,gBAAgB,QAAQ,MAAM,cAAc;AAC/D,MAAI,OAAO,OAAO,eAAe;AAC/B,UAAM,6BAA6B,UAAU;EAC/C,OAAO;AACL,UAAME,SAAc,UAAU;EAChC;AACF;AAEA,SAAS,gBACP,QACA,MACA,iBAA2B,CAAA,GAAE;AAE7B,QAAM,iBAAiB,oBAAoB,QAAQ,IAAI;AACvD,iBAAe,SAAS,sBACtB,QACA,cAAc,EACd,SAAQ;AACV,SAAO,eAAe;AACxB;AAEA,SAAS,oBAAoB,EAAC,IAAG,GAAgB,MAAY;AAC3D,QAAM,YAAY,IAAI,MAAM,aAAa,MAAM,IAAI;AACnD,SAAO,IAAI,IAAI,WAAW,SAAS,sBAAsB;AAC3D;AAEA,SAAS,sBACP,EAAC,QAAAC,QAAM,GACP,iBAA2B,CAAA,GAAE;;AAE7B,QAAM,sBACJ,kBAAkB,eAAe,SAAS,IACtC,EAAC,iBAAiB,eAAe,KAAK,GAAG,EAAC,IAC1C;AAEN,QAAM,QAAQ;IACZ,WAAWA,QAAO;IAClB,SAAO,KAAAA,QAAO,WAAP,mBAAe,eAAc;IACpC,GAAG;;AAEL,SAAO,IAAI,gBAAgB,KAAK;AAClC;;;AClCA,IAAM,4BAA4B;;;;;;;;;;;;;;;;AAiB3B,eAAe,iBACpB,OAAsB;AAEtB,QAAM,yBAAyB,MAAM,MAAM,QAAQ,yBAAyB;AAE5E,QAAM,gBAAgB,MAAM,uBAAuB,KAAI;AACvD,SAAO,cAAc;AACvB;;;SClCgB,qBACd,QACA,SACA,OAAsB;AAEtB,SAAO,eAAe,cAAc,QAAgB;AAClD,UAAM,EAAC,QAAAC,QAAM,IAAI;AAEjB,IAAAA,QAAO,MAAM,gCAAgC,EAAC,MAAM,QAAQ,MAAM,OAAM,CAAC;AAEzE,QAAI,OAAO,WAAW;AAAG;AACzB,QAAI,MAAM,eAAe,QAAQ,KAAK;AAAG;AAEzC,UAAM,MAAM,sBAAsB,QAAQ,QAAQ,MAAM,MAAM;EAChE;AAEA,iBAAe,eAAe,QAAkBC,QAAsB;AACpE,UAAM,eAAe,MAAM,iBAAiBA,MAAK;AACjD,UAAM,gBAAgB,aAAa,IAAI,aAAa,aAAa,IAC/D,CAAC,UAAU,MAAM,MAAM;AAEzB,WAAO,IAAI,WAAW,aAAa,EAAE,IAAI,MAAM;EACjD;AACF;;;SCpBgB,mBACd,QACA,SACA,OAAsB;AAEtB,SAAO,eAAe,cAAW;AAC/B,UAAM,EAAC,QAAAC,QAAM,IAAI;AAEjB,IAAAA,QAAO,MAAM,6BAA6B;MACxC,MAAM,QAAQ;IACf,CAAA;AAED,UAAM,eAAe,MAAM,iBAAiB,KAAK;AACjD,WAAO,oBAAoB,YAAY;EACzC;AACF;AAEM,SAAU,oBACd,sBAA+C;AAE/C,QAAM,iBAAiB,qBAAqB;AAE5C,QAAM,UAAU,IAAI,WAClB,eAAe,aAAa,aAAa,IAAI,CAAC,UAAU,MAAM,MAAM,CAAC,EACrE,QAAQ,IAAI;AAEd,QAAM,WAAW,IAAI,WACnB,eAAe,sBAAsB,IAAI,CAAC,UAAU,MAAM,MAAM,CAAC,EACjE,QAAQ,IAAI;AAEd,QAAM,WAAW,IAAI,WACnB,eAAe,qBAAqB,IAAI,CAAC,UAAU,MAAM,MAAM,CAAC,EAChE,QAAQ,IAAI;AAEd,SAAO;IACL;IACA;IACA;;AAEJ;;;ACtCA,IAAM,wBAAwB;;;;;;;;;;;;AAavB,eAAe,aACpB,OACA,QAAgB;AAEhB,QAAM,qBAAqB,MAAM,MAAM,QAAQ,uBAAuB;IACpE,WAAW;MACT;IACD;EACF,CAAA;AAED,QAAM,gBAAgB,MAAM,mBAAmB,KAAI;AACnD,SAAO,cAAc,KAAK;AAC5B;;;SC9BgB,oBACd,QACA,SACA,OAAsB;AAEtB,SAAO,eAAe,OAAO,QAAgB;;AAC3C,UAAM,EAAC,QAAAC,QAAM,IAAI;AAEjB,UAAM,eAAe,MAAM;AAE3B,IAAAA,QAAO,MAAM,mBAAmB;MAC9B,MAAM,QAAQ;MACd;IACD,CAAA;AAED,UAAM,qBAAqB,MAAM,aAAa,OAAO,MAAM;AAC3D,UAAI,wBAAmB,eAAnB,mBAA+B,UAAS,GAAG;AAC7C,MAAAA,QAAO,MAAM,6BAA6B;QACxC,MAAM,QAAQ;QACd,QAAQ,mBAAmB;MAC5B,CAAA;AAED,YAAM,IAAI,SAAS,KAAK,UAAU,mBAAmB,UAAU,GAAG;QAChE,QAAQ;QACR,SAAS;UACP,gBAAgB;QACjB;MACF,CAAA;IACH;AAEA,WAAO;MACL,SAAS,mBAAmB,QAAQ,IAAI,CAAC,UAAU,MAAM,MAAM;;EAEnE;AACF;AAEA,eAAe,eAAe,QAAgB;AAC5C,MAAI,CAAC,UAAU,OAAO,WAAW,GAAG;AAClC,UAAM,IAAI,SAAS,sBAAsB,EAAC,QAAQ,IAAG,CAAC;EACxD;AACF;;;SCrCgB,iBACd,QACA,SACA,OAAsB;AAEtB,SAAO;IACL,OAAO,mBAAmB,QAAQ,SAAS,KAAK;IAChD,SAAS,qBAAqB,QAAQ,SAAS,KAAK;IACpD,QAAQ,oBAAoB,QAAQ,SAAS,KAAK;;AAEtD;;;AC8BM,SAAU,oBAAoD,EAClE,UACA,GAAG,OAAM,GACU;AACnB,QAAM,EAAC,KAAK,QAAAC,SAAQ,QAAAC,QAAM,IAAI;AAE9B,iBAAe,2BAA2BC,UAAgB;AACxD,UAAM,MAAM,IAAI,IAAIA,SAAQ,GAAG;AAE/B,QAAI,IAAI,aAAaD,QAAO,KAAK,uBAAuB;AACtD,MAAAD,QAAO,MAAM,yBAAyB;QACpC,MAAM,mBAAmBE,QAAO;MACjC,CAAA;AACD,YAAM,gBAAgB,EAAC,QAAAD,QAAmB,GAAGC,QAAO;IACtD;EACF;AAEA,iBAAe,2BAA2BA,UAAgB;AACxD,UAAM,MAAM,IAAI,IAAIA,SAAQ,GAAG;AAE/B,QAAI,IAAI,aAAaD,QAAO,KAAK,gBAAgB;AAC/C,YAAM,cAAc,IAAI,aAAa,IAAI,YAAY;AAErD,MAAAD,QAAO,MAAM,8BAA8B;QACzC,MAAM,mBAAmBE,QAAO;QAChC;MACD,CAAA;AACD,YAAM,gBAAgB,EAAC,QAAAD,QAAmB,GAAGC,UAAS,EAAC,KAAK,YAAW,CAAC;IAC1E;EACF;AAMA,WAAS,cACPA,UACA,SACA,cACA,cAAyB;AAEzB,QAAI,UAA4B;MAC9B,OAAO,sBACL,SACA,QACA,aAAa,kBAAkBA,QAAO,CAAC;MAEzC,SAAS;QACP,SAAS,sBAAsB,QAAQA,UAAS,OAAO;QACvD,OAAO,oBAAoB,QAAQA,UAAS,OAAO;QACnD,SAAS,sBAAsB,QAAQA,UAAS,OAAO;QACvD,QAAQ,qBAAqB,QAAQA,UAAS,OAAO;QACrD,mBAAmB,yBAAyB,QAAQA,UAAS,OAAO;QACpE,yBAAyB,+BACvB,QACAA,UACA,OAAO;MAEV;MAED;MACA,MAAM,yBAAyB,QAAQA,QAAO;;AAGhD,cAAU,oBAAoB,SAASA,UAAS,SAAS,YAAY;AACrE,cAAU,kBAAkB,OAAO;AAEnC,WAAO;EACT;AAEA,WAAS,oBACP,SACAA,UACA,SACA,cAAyB;AAEzB,QAAID,QAAO,eAAe;AACxB,aAAO;QACL,GAAG;QACH;QACA,UAAU,gBAAgB,QAAQC,UAAS,QAAQ,IAAI;;IAE3D;AACA,WAAO;EACT;AAEA,WAAS,kBAAkB,SAAyB;AAClD,WAAO;MACL,GAAG;MACH,QAAQ,iBAAiB,QAAQ,QAAQ,SAAS,QAAQ,KAAK;;EAEnE;AAEA,SAAO,eAAe,kBAAkBA,UAAgB;AACtD,QAAI;AACF,0BAAoB,QAAQA,QAAO;AACnC,8BAAwB,QAAQA,QAAO;AACvC,YAAM,2BAA2BA,QAAO;AACxC,YAAM,2BAA2BA,QAAO;AACxC,YAAM,SAAS,uBAAuBA,QAAO;AAI7C,UAAI,CAAC,sBAAsBA,QAAO,GAAG;AACnC,kCAA0B,QAAQA,QAAO;AACzC,cAAM,8BAA8B,QAAQA,QAAO;AACnD,cAAM,wCAAwC,QAAQA,QAAO;MAC/D;AAEA,MAAAF,QAAO,KAAK,gCAAgC;QAC1C,MAAM,mBAAmBE,QAAO;MACjC,CAAA;AAED,YAAM,EAAC,SAAS,MAAM,WAAW,aAAY,IAC3C,MAAM,uBAAuB,QAAQA,QAAO;AAE9C,MAAAF,QAAO,MAAM,gCAAgC,EAAC,MAAM,UAAS,CAAC;AAC9D,YAAM,kBAAkB,YACpB,MAAMC,QAAO,eAAgB,YAAY,SAAS,IAClD;AAEJ,YAAM,UAAU,MAAM,SAAS,aAAaC,UAAS;QACnD,SAAS;QACT;QACA;MACD,CAAA;AAED,aAAO,cAAcA,UAAS,SAAS,UAAU,OAAO;IAC1D,SAAS,iBAAiB;AACxB,UAAI,2BAA2B,UAAU;AACvC,QAAAF,QAAO,MAAM,oCAAoC;UAC/C,MAAM,mBAAmBE,QAAO;QACjC,CAAA;AACD,iCAAyB,QAAQA,QAAO,EAAE,eAAe;MAC3D;AAEA,YAAM;IACR;EACF;AACF;AAEA,eAAe,uBACb,QACAA,UAAgB;AAEhB,QAAM,EAAC,KAAK,QAAAD,SAAQ,QAAAD,QAAM,IAAI;AAE9B,QAAM,qBAAqB,sBAAsBE,QAAO;AACxD,QAAM,0BAA0B,4BAA4BA,QAAO;AACnE,QAAM,eAAgB,sBAAsB;AAE5C,EAAAF,QAAO,MAAM,4CAA4C;IACvD,MAAM,mBAAmBE,QAAO;IAChC,cAAc,KAAK,UAAU;MAC3B,QAAQ;MACR,QAAQ;KACT;EACF,CAAA;AAED,MAAID,QAAO,eAAe;AACxB,UAAM,UAAU,MAAM,qBAAqB,QAAQC,UAAS,YAAY;AACxE,UAAM,OAAO,IAAI,IAAI,QAAQ,IAAI;AACjC,UAAMC,QAAO,KAAK;AAElB,IAAAH,QAAO,MAAM,0CAA0C,EAAC,MAAAG,OAAM,QAAO,CAAC;AACtE,UAAMC,aAAYH,QAAO,kBACrB,IAAI,QAAQ,gBAAgBE,OAAM,QAAQ,GAAG,IAC7C,IAAI,QAAQ,aAAaA,KAAI;AAEjC,WAAO,EAAC,MAAAA,OAAM,SAAS,WAAAC,YAAW,aAAY;EAChD;AAEA,QAAM,MAAM,IAAI,IAAIF,SAAQ,GAAG;AAC/B,QAAM,OAAO,IAAI,aAAa,IAAI,MAAM;AAExC,QAAM,YAAY,MAAM,IAAI,QAAQ,aAAa;IAC/C,UAAUD,QAAO;IACjB,YAAYC;EACb,CAAA;AAED,SAAO,EAAC,MAAM,WAAW,SAAS,QAAW,aAAY;AAC3D;A;;;;;SClOgB,yBAAyB,EACvC,SAAAG,UACA,QAAO,GACkB;AACzB,SAAO,eAAe,kBAAkB,EACtC,OACA,QACA,QAAO,GACR;AACC,QAAI,iBAAiB,sBAAsB,MAAM;AAC/C,aAAO,OAAO,MACZ,sCAAsC,MAAM,OAAO,IACnD,EAAC,MAAM,QAAQ,KAAI,CAAC;AAEtB,YAAM;IACR;AAEA,WAAO,OAAO,MACZ,4CAA4C,MAAM,OAAO,IACzD;MACE,MAAM,QAAQ;MACd,MAAM,MAAM,SAAS;MACrB,YAAY,MAAM,SAAS;MAC3B,MAAM,KAAK,UAAU,MAAM,SAAS,IAAI;IACzC,CAAA;AAGH,QAAI,SAAS;AACX,YAAM,QAAQ,EAAC,SAAAA,UAAS,SAAS,MAAK,CAAC;IACzC;AAGA,UAAM,IAAI,SAAS,KAAK,UAAU,MAAM,SAAS,IAAI,GAAG;MACtD,QAAQ,MAAM,SAAS;MACvB,SAAS;QACP,gBAAgB,MAAM,SAAS,QAAS,cAAc;MACvD;IACF,CAAA;EACH;AACF;;;AC1CO,eAAe,2BACpB,MACA,EAAC,KAAK,QAAAC,SAAQ,QAAAC,QAAM,GAAc;AAElC,MAAID,QAAO,iBAAiB,gBAAgB,cAAc;AACxD,IAAAC,QAAO,MAAM,4DAA4D;MACvE;IACD,CAAA;AACD,WAAO,IAAI,QAAQ,iBAAiB,IAAI;EAC1C,OAAO;AACL,IAAAA,QAAO,MAAM,gDAAgD,EAAC,KAAI,CAAC;AACnE,UAAM,mBAAmB,IAAI,QAAQ,aAAa,IAAI;AACtD,UAAM,UAAU,MAAMD,QAAO,eAAgB,YAAY,gBAAgB;AAEzE,WAAO;EACT;AACF;;;ACLM,SAAU,2BACd,QAAmB;AAEnB,QAAM,EAAC,KAAK,QAAAE,QAAM,IAAI;AAEtB,SAAO,eAAe,aACpBC,UAAgB;AAEhB,QAAIA,SAAQ,WAAW,QAAQ;AAC7B,MAAAD,QAAO,MACL,8EACA,EAAC,KAAKC,SAAQ,KAAK,QAAQA,SAAQ,OAAM,CAAC;AAE5C,YAAM,IAAI,SAAS,QAAW;QAC5B,QAAQ;QACR,YAAY;MACb,CAAA;IACH;AAEA,UAAM,UAAU,MAAMA,SAAQ,KAAI;AAElC,UAAMC,SAAQ,MAAM,IAAI,SAAS,SAAS;MACxC;MACA,YAAYD;IACb,CAAA;AAED,QAAI,CAACC,OAAM,OAAO;AAChB,UAAIA,OAAM,WAAW,6BAA6B,aAAa;AAC7D,QAAAF,QAAO,MAAM,kCAAkCE,MAAK;AACpD,cAAM,IAAI,SAAS,QAAW;UAC5B,QAAQ;UACR,YAAY;QACb,CAAA;MACH,OAAO;AACL,QAAAF,QAAO,MAAM,6BAA6BE,MAAK;AAC/C,cAAM,IAAI,SAAS,QAAW,EAAC,QAAQ,KAAK,YAAY,cAAa,CAAC;MACxE;IACF;AACA,UAAM,UAAU,MAAM,2BAA2BA,OAAM,QAAQ,MAAM;AACrE,UAAM,iBAAuD;MAC3D,YAAYA,OAAM;MAClB,MAAMA,OAAM;MACZ,OAAOA,OAAM;MACb,WAAWA,OAAM;MACjB,SAAS,KAAK,MAAM,OAAO;MAC3B,UAAUA,OAAM,YAAY;MAC5B,SAAS;MACT,OAAO;;AAGT,QAAI,CAAC,SAAS;AACZ,aAAO;IACT;AAEA,UAAM,QAAQ,mBAAmB;MAC/B;MACA;MACA,mBAAmB,yBAAyB,EAAC,SAAAD,SAAO,CAAC;IACtD,CAAA;AAED,WAAO;MACL,GAAG;MACH;MACA;;EAEJ;AACF;;;ACvEM,SAAU,eAAeE,SAAyB;AACtD,QAAM,cAAc,EAAC,SAAS,cAAa;AAE3C,QAAM,kBAAgD,CACpD,SACA,UAAU,CAAA,MACPA,QAAO,QAAQ,SAAS,EAAC,GAAG,aAAa,GAAG,QAAO,CAAC;AAEzD,WAASC,YAAWC,kBAA6C;AAC/D,WAAO,SAAU,SAAiB,SAAe;AAC/C,UAAI,QAAQ,+BAA+B,SAAS,IAAI,GAAG;AACzD,cAAM,IAAI,uBACR,qCAAqC,OAAO,EAAE;MAElD;AAEA,aAAOA,iBAAgB,iBAAiB,OAAO,KAAK,OAAO,EAAE;IAC/D;EACF;AAEA,SAAO;IACL,GAAGF;IACH,KAAK,CAAC,UAAU,SAAS,UAAU,CAAA,MACjCA,QAAO,IAAI,UAAU,SAAS,EAAC,GAAG,aAAa,GAAG,QAAO,CAAC;IAC5D,OAAO,CAAC,SAAS,UAAU,CAAA,MACzBA,QAAO,MAAM,SAAS,EAAC,GAAG,aAAa,GAAG,QAAO,CAAC;IACpD,MAAM,CAAC,SAAS,UAAU,CAAA,MACxBA,QAAO,KAAK,SAAS,EAAC,GAAG,aAAa,GAAG,QAAO,CAAC;IACnD,SAAS;IACT,OAAO,CAAC,SAAS,UAAU,CAAA,MACzBA,QAAO,MAAM,SAAS,EAAC,GAAG,aAAa,GAAG,QAAO,CAAC;IACpD,YAAYC,YAAW,eAAe;;AAE1C;A;;;;;;ACrCM,SAAU,aAAa,QAAmB;AAC9C,QAAM,EAAC,KAAK,QAAAE,SAAQ,QAAAC,QAAM,IAAI;AAE9B,SAAO,eAAe,MAAMC,UAAgB;AAC1C,UAAM,MAAM,IAAI,IAAIA,SAAQ,GAAG;AAC/B,UAAM,YAAY,IAAI,aAAa,IAAI,MAAM;AAE7C,QAAIA,SAAQ,WAAW,SAAS,CAAC,WAAW;AAC1C,aAAO,CAAA;IACT;AAEA,UAAM,OACJ,cAAe,MAAMA,SAAQ,SAAQ,GAAI,IAAI,MAAM;AAErD,QAAI,CAAC,MAAM;AACT,MAAAD,QAAO,MAAM,0BAA0B,EAAC,KAAI,CAAC;AAC7C,aAAO,EAAC,MAAM,eAAe,YAAW;IAC1C;AAEA,UAAM,sBAAsB,KACzB,QAAQ,gBAAgB,EAAE,EAC1B,QAAQ,OAAO,EAAE;AACpB,UAAM,kBACJ,6BAAM,QAAQ,UAAS,KACnB,GAAG,mBAAmB,mBACtB;AACN,UAAM,gBAAgB,IAAI,MAAM,aAAa,cAAc;AAE3D,QAAI,CAAC,eAAe;AAClB,MAAAA,QAAO,MAAM,0BAA0B,EAAC,KAAI,CAAC;AAC7C,aAAO,EAAC,MAAM,eAAe,YAAW;IAC1C;AAEA,UAAM,WAAW,GAAGD,QAAO,MAAM,GAAGA,QAAO,KAAK,IAAI,SAAS,aAAa;AAE1E,UAAM,YAAY,IAAI,MAAM,wBAAwB,aAAa;AACjE,UAAM,cAAc,WAAW,SAAS,4BAA4BA,QAAO,MAAM;AAEjF,UAAM,gBACJA,QAAO,iBAAiBA,QAAO,OAAO;AACxC,UAAM,cAAc,gBAAgB,cAAc;AAElD,IAAAC,QAAO,KAAK,gCAAgC,WAAW,IAAI;MACzD,MAAM;IACP,CAAA;AAED,UAAM,SAAS,WAAW;EAC5B;AACF;;;AClDM,IAAO,uBAAP,cAAoC,aAAY;AAAG;;;ACKnD,SAAU,mCAAmC,QAAmB;AACpE,SAAO,OAAO,SAAsD;AAClE,UAAM,UAAU,MAAM,2BAA2B,MAAM,MAAM;AAE7D,QAAI,CAAC,SAAS;AACZ,YAAM,IAAI,qBACR,qCAAqC,IAAI,8CAA8C;IAE3F;AAEA,WAAO;MACL;MACA,OAAO,mBAAmB,EAAC,QAAQ,QAAO,CAAC;;EAE/C;AACF;A;;;ACVM,SAAU,6BACd,QACA,aAAmB;AAEnB,SAAO,eAAe,sBACpBE,UACA,UAAU,CAAA,GAAE;AAEZ,UAAM,EAAC,QAAAC,QAAM,IAAI;AAEjB,UAAM,cAAc,QAAQ,eAAe,CAAA;AAE3C,wBAAoB,QAAQD,QAAO;AACnC,4BAAwB,QAAQA,UAAS,WAAW;AAEpD,UAAM,qBAAqB,sBAAsBA,QAAO;AAExD,IAAAC,QAAO,KAAK,kBAAkB,WAAW,YAAY;MACnD,MAAM,mBAAmBD,QAAO;IACjC,CAAA;AAED,QAAI,CAAC,oBAAoB;AACvB,MAAAC,QAAO,MAAM,2CAA2C;QACtD,MAAM,mBAAmBD,QAAO;MACjC,CAAA;AACD,YAAM,IAAI,SAAS,QAAW;QAC5B,QAAQ;QACR,YAAY;MACb,CAAA;IACH;AAEA,WAAO;MACL,cAAc,MAAM,qBAClB,QACAA,UACA,oBACA,EAAC,eAAe,OAAO,cAAc,MAAK,CAAC;MAE7C,MAAM,yBAAyB,QAAQA,UAAS,WAAW;;EAE/D;AACF;;;AChDM,SAAU,4BACd,QAAmB;AAEnB,SAAO,6BACL,QACA,UAAU;AAEd;;;SCNgB,wBAAwB,EACtC,QACA,QAAO,GAIR;AACC,QAAM,EAAC,IAAG,IAAI;AAEd,SAAO;IACL,SAAS,OAAO,OAAO,UAAU,CAAA,MAAM;AACrC,YAAM,SAAS,IAAI,IAAI,QAAQ,WAAW;QACxC;QACA,YAAY,QAAQ;MACrB,CAAA;AAED,YAAM,cAAc,MAAM,OAAO,QAAQ,OAAO;QAC9C,WAAW,mCAAS;QACpB,UAAS,mCAAS,SAAQ,QAAQ,QAAQ,IAAI;QAC9C,SAAS,mCAAS;MACnB,CAAA;AAED,aAAO,IAAI,SAAS,KAAK,UAAU,WAAW,CAAC;IACjD;;AAEJ;;;ACrBM,SAAU,4BACd,QAAmB;AAEnB,QAAM,EAAC,KAAK,QAAAE,SAAQ,QAAAC,QAAM,IAAI;AAE9B,SAAO,eAAe,aACpBC,UAAgB;AAEhB,UAAM,MAAM,IAAI,IAAIA,SAAQ,GAAG;AAC/B,UAAM,OAAO,IAAI,aAAa,IAAI,MAAM;AACxC,IAAAD,QAAO,KAAK,oCAAoC,EAAC,KAAI,CAAC;AAEtD,QAAI,CAAE,MAAM,qBAAqB,QAAQ,GAAG,GAAI;AAC9C,MAAAA,QAAO,KAAK,2CAA2C,EAAC,KAAI,CAAC;AAC7D,YAAM,IAAI,SAAS,QAAW;QAC5B,QAAQ;QACR,YAAY;MACb,CAAA;IACH;AAEA,UAAM,YAAY,IAAI,QAAQ,aAAa,IAAI;AAC/C,UAAM,UAAU,MAAMD,QAAO,eAAgB,YAAY,SAAS;AAElE,QAAI,CAAC,SAAS;AACZ,MAAAC,QAAO,MAAM,2DAA2D;QACtE;QACA,GAAG,OAAO,YAAY,IAAI,aAAa,QAAO,CAAE;MACjD,CAAA;AAED,YAAME,WAA2B;QAC/B;QACA,SAAS;QACT,OAAO;QACP,YAAY;;AAGd,aAAOA;IACT;AAEA,UAAM,UAAsC;MAC1C;MACA;MACA,OAAO,mBAAmB,EAAC,QAAQ,QAAO,CAAC;MAC3C,YAAY,wBAAwB,EAAC,QAAQ,QAAO,CAAC;;AAGvD,WAAO;EACT;AACF;AAEA,IAAM,SAAiC,CAAC,MAAM,mBAAkB;AAC9D,QAAM,gBAAgB,kBAAkB,IAAI;AAE5C,MAAI,OAAO,mBAAmB,UAAU;AACtC,WAAO,IAAI,SAAS,eAAe;MACjC,QAAQ,kBAAkB;MAC1B,SAAS;QACP,gBAAgB;MACjB;IACF,CAAA;EACH;AAEA,QAAM,EAAC,QAAQ,GAAG,aAAY,IAAI,kBAAkB,CAAA;AACpD,QAAM,eACJ,WAAW,QAAQ,qBAAqB,aAAa,KAAK;AAE5D,QAAM,UAAU,IAAI,QAAQ,aAAa,OAAO;AAChD,UAAQ,IAAI,gBAAgB,oBAAoB;AAEhD,SAAO,IAAI,SAAS,cAAc;IAChC,GAAG;IACH;EACD,CAAA;AACH;AAEA,eAAe,qBACb,QACA,KAAQ;AAER,QAAM,EAAC,KAAK,QAAAF,QAAM,IAAI;AAEtB,MAAI;AACF,QAAI,eAAe,IAAI,gBAAgB,IAAI,MAAM;AACjD,QAAI,CAAC,aAAa,IAAI,OAAO,GAAG;AAC9B,mBAAa,OAAO,OAAO;IAC7B;AAEA,QAAI,UAAU,MAAM,IAAI,MAAM,aAC5B,OAAO,YAAY,aAAa,QAAO,CAAE,GACzC,EAAC,UAAU,WAAU,CAAC;AAGxB,QAAI,CAAC,SAAS;AACZ,YAAM,YAAY,IAAI,SACnB,QAAQ,OAAO,EAAE,EACjB,QAAQ,OAAO,EAAE,EACjB,WAAW,KAAK,GAAG;AACtB,YAAM,OAAO,YAAY,SAAS;AAElC,qBAAe,IAAI,gBACjB,UAAU,IAAI,IAAI,aAAa,SAAQ,EAAG,QAAQ,OAAO,EAAE,CAAC,EAAE;AAGhE,gBAAU,MAAM,IAAI,MAAM,aACxB,OAAO,YAAY,aAAa,QAAO,CAAE,GACzC,EAAC,UAAU,WAAU,CAAC;AAGxB,UAAI,CAAC,SAAS;AACZ,cAAMG,gBAAe,IAAI,gBACvB,UAAU,IAAI,WAAW,IAAI,OAAO,QAAQ,OAAO,EAAE,CAAC,EAAE;AAG1D,kBAAU,MAAM,IAAI,MAAM,aACxB,OAAO,YAAYA,cAAa,QAAO,CAAE,GACzC,EAAC,UAAU,WAAU,CAAC;MAE1B;IACF;AAEA,WAAO;EACT,SAAS,OAAO;AACd,UAAM,OAAO,IAAI,aAAa,IAAI,MAAM;AACxC,IAAAH,QAAO,KAAK,MAAM,SAAS,EAAC,KAAI,CAAC;AACjC,UAAM,IAAI,SAAS,QAAW,EAAC,QAAQ,KAAK,YAAY,cAAa,CAAC;EACxE;AACF;AAEA,SAAS,kBAAkB,MAAY;AACrC,SACE,KAEG,WACC,+CACA,oBAAoB,EAGrB,WAAW,0CAA0C,kBAAkB;AAE9E;;;AChJM,SAAU,mCACd,QAAmB;AAEnB,SAAO,6BACL,QACA,kBAAkB;AAEtB;;;ACPM,SAAU,uBAAuB,QAAmB;AACxD,SAAO,6BAA6B,QAAQ,KAAK;AACnD;;;ACCM,SAAU,0BAA0B,QAAmB;AAC3D,QAAM,uBAAuB,4BAA4B,MAAM;AAC/D,QAAM,uBAAuB,4BAA4B,MAAM;AAC/D,QAAM,8BACJ,mCAAmC,MAAM;AAC3C,QAAM,kBAAkB,uBAAuB,MAAM;AAErD,QAAM,UAA8B;IAClC,UAAU;IACV,UAAU;IACV,iBAAiB;IACjB,KAAK;;AAGP,SAAO;AACT;;;ACbM,SAAU,wCACd,QAAmB;AAEnB,SAAO,OAAO,SAA2D;AACvE,UAAM,UAAU,MAAM,2BAA2B,MAAM,MAAM;AAE7D,QAAI,CAAC,SAAS;AACZ,YAAM,IAAI,qBACR,qCAAqC,IAAI,mDAAmD;IAEhG;AAEA,WAAO;MACL;MACA,YAAY,wBAAwB,EAAC,QAAQ,QAAO,CAAC;;EAEzD;AACF;A;;;;;ACpBO,eAAe,qBACpB,QACA,SACAI,UACA,cAAmC;AAEnC,QAAM,EAAC,QAAAC,SAAQ,QAAAC,QAAM,IAAI;AACzB,MAAID,QAAO,MAAM,WAAW;AAC1B,IAAAC,QAAO,KAAK,0BAA0B,EAAC,MAAM,QAAQ,KAAI,CAAC;AAE1D,UAAM,QAAQ,sBACZ,SACA,QACA,aAAa,kBAAkBF,QAAO,CAAC;AAGzC,UAAMC,QAAO,MAAM,UAAU;MAC3B;MACA;IACD,CAAA;EACH;AACF;;;ICEa,6BAAoB;EAW/B,YAAmB,EAAC,KAAK,QAAAE,SAAQ,QAAAC,QAAM,GAAc;AAR3C;AAKA;AACA;AAGR,SAAK,MAAM;AACX,SAAK,SAASD;AACd,SAAK,SAASC;EAChB;EAEO,MAAM,uBAAuBC,UAAgB;AAClD,UAAM,EAAC,KAAK,QAAAF,QAAM,IAAI;AAEtB,UAAM,MAAM,IAAI,IAAIE,SAAQ,GAAG;AAC/B,UAAM,gBAAgB,IAAI,aAAaF,QAAO,KAAK;AACnD,UAAM,wBAAwB,IAAI,aAAaA,QAAO,KAAK;AAE3D,QAAI,iBAAiB,uBAAuB;AAC1C,YAAM,OAAO,IAAI,MAAM,aAAa,IAAI,aAAa,IAAI,MAAM,CAAE;AACjE,UAAI,CAAC;AAAM,cAAM,IAAI,SAAS,yBAAyB,EAAC,QAAQ,IAAG,CAAC;AAEpE,UAAI,eAAe;AACjB,cAAM,MAAM,KAAK,uBAAuBE,UAAS,IAAI;MACvD,OAAO;AACL,cAAM,MAAM,KAAK,0BAA0BA,UAAS,IAAI;MAC1D;IACF;AAEA,QAAI,CAAC,sBAAsBA,QAAO,GAAG;AAInC,YAAM,KAAK,sBAAsBA,QAAO;IAC1C;EACF;EAEO,MAAM,aACXA,UACA,gBAA8B;AAE9B,UAAM,EAAC,KAAK,QAAAF,SAAQ,QAAAC,QAAM,IAAI;AAE9B,UAAM,EAAC,MAAM,QAAO,IAAI;AAExB,QAAI,CAAC,SAAS;AACZ,MAAAA,QAAO,MAAM,0CAA0C,EAAC,KAAI,CAAC;AAC7D,YAAM,mBAAmB,EAAC,QAAAD,SAAgB,IAAG,GAAGE,UAAS,IAAI;IAC/D,WAAW,CAAC,QAAQ,SAASF,QAAO,MAAM,GAAG;AAC3C,MAAAC,QAAO,MACL,6DACA,EAAC,KAAI,CAAC;AAER,YAAM,mBAAmB,EAAC,QAAAD,SAAgB,IAAG,GAAGE,UAAS,IAAI;IAC/D;AAEA,IAAAD,QAAO,MAAM,yBAAyB,EAAC,KAAI,CAAC;AAE5C,WAAO;EACT;EAEO,kBAAkBC,UAAgB;AACvC,UAAM,EAAC,KAAK,QAAAF,SAAQ,QAAAC,QAAM,IAAI;AAC9B,WAAO,yBAAyB;MAC9B,SAAAC;MACA,SAAS,OAAO,EAAC,SAAS,MAAK,MAAqB;AAClD,YAAI,MAAM,SAAS,SAAS,KAAK;AAC/B,gBAAM,MAAM,mBACV,EAAC,KAAK,QAAAF,QAAc,GACpBE,UACA,QAAQ,IAAI;QAEhB;MACF;IACD,CAAA;EACH;EAEQ,MAAM,sBAAsBA,UAAgB;AAClD,UAAM,EAAC,KAAK,QAAAF,SAAQ,QAAAC,QAAM,IAAI;AAE9B,8BAA0B,EAAC,KAAK,QAAAD,SAAQ,QAAAC,QAAM,GAAGC,QAAO;AAExD,UAAM,MAAM,IAAI,IAAIA,SAAQ,GAAG;AAC/B,QAAI,OAAO,IAAI,aAAa,IAAI,MAAM;AAGtC,IAAAD,QAAO,MAAM,qCAAqC,EAAC,KAAI,CAAC;AAExD,QAAI,CAAE,MAAM,KAAK,kBAAkBC,QAAO,GAAI;AAC5C,MAAAD,QAAO,KAAK,mDAAmD;AAC/D,YAAM,IAAI,SAAS,QAAW;QAC5B,QAAQ;QACR,YAAY;MACb,CAAA;IACH;AAEA,UAAM,iBAAiB,MAAM,KAAK,kBAAkBC,QAAO;AAC3D,UAAM,aAAa,IAAI,aAAa,IAAI,UAAU,MAAM;AAExD,QAAI,CAAC,gBAAgB;AACnB,MAAAD,QAAO,KAAK,uDAAuD;QACjE;MACD,CAAA;AACD,UAAI,YAAY;AACd,+BAAuB,EAAC,KAAK,QAAAD,QAAc,GAAGE,UAAS,IAAK;MAC9D,OAAO;AACL,cAAM,MAAM,UAAU,EAAC,KAAK,QAAAF,QAAc,GAAGE,UAAS,OAAO,IAAK;MACpE;IACF;AAEA,WAAO,QAAQ,eAAe;AAE9B,QAAIF,QAAO,iBAAiB,CAAC,YAAY;AACvC,UAAI;AACF,QAAAC,QAAO,MAAM,sDAAsD;UACjE;QACD,CAAA;AACD,cAAM,KAAK,YAAY,cAAc;AAErC,QAAAA,QAAO,MAAM,iDAAiD,EAAC,KAAI,CAAC;MACtE,SAAS,OAAO;AACd,cAAM,KAAK,4BAA4B,OAAOC,UAAS,IAAI;MAC7D;IACF;EACF;EAEQ,MAAM,uBACZA,UACA,MAAY;AAEZ,UAAM,EAAC,KAAK,QAAAF,SAAQ,QAAAC,QAAM,IAAI;AAE9B,IAAAA,QAAO,KAAK,gCAAgC,EAAC,KAAI,CAAC;AAGlD,QACED,QAAO,iBACPE,SAAQ,QAAQ,IAAI,gBAAgB,MAAM,UAC1C;AACA,MAAAD,QAAO,MAAM,mDAAmD,EAAC,KAAI,CAAC;AACtE,YAAM,uBAAuB,EAAC,KAAK,QAAAD,QAAc,GAAGE,UAAS,IAAI;IACnE,OAAO;AACL,YAAM,MAAM,UAAU,EAAC,KAAK,QAAAF,QAAc,GAAGE,UAAS,OAAO,IAAI;IACnE;EACF;EAEQ,MAAM,0BACZA,UACA,MAAY;AAEZ,UAAM,EAAC,KAAK,QAAAF,SAAQ,QAAAC,QAAM,IAAI;AAE9B,IAAAA,QAAO,KAAK,mCAAmC,EAAC,KAAI,CAAC;AAErD,QAAI;AACF,YAAM,EAAC,SAAS,SAAS,gBAAe,IAAI,MAAM,IAAI,KAAK,SAAS;QAClE,YAAYC;MACb,CAAA;AAED,YAAMF,QAAO,eAAgB,aAAa,OAAO;AAEjD,UAAIA,QAAO,mBAAmB,CAAC,QAAQ,UAAU;AAC/C,QAAAC,QAAO,KAAK,sDAAsD;UAChE;QACD,CAAA;AACD,cAAM,UAAU,EAAC,KAAK,QAAAD,SAAQ,QAAAC,QAAM,GAAGC,UAAS,MAAM,IAAI;MAC5D;AAEA,MAAAD,QAAO,MAAM,wDAAwD;QACnE,MAAM,QAAQ;QACd,UAAU,QAAQ;MACnB,CAAA;AAED,YAAM,qBAAqB,EAAC,KAAK,QAAAD,SAAQ,QAAAC,QAAM,GAAG,SAASC,UAAS,IAAI;AAExE,YAAM,MAAM,2BACVA,UACA,EAAC,KAAK,QAAAF,SAAQ,QAAAC,QAAM,GACpB,eAAe;IAEnB,SAAS,OAAO;AACd,UAAI,iBAAiB;AAAU,cAAM;AAErC,YAAM,MAAM,KAAK,mBAAmB,OAAOC,UAAS,IAAI;IAC1D;EACF;EAEQ,MAAM,kBACZA,UAAgB;AAEhB,UAAM,YAAY,MAAM,KAAK,oBAAoBA,QAAO;AACxD,WAAO,KAAK,OAAO,eAAgB,YAAY,SAAU;EAC3D;EAEQ,MAAM,kBAAkBA,UAAgB;AAC9C,WAAO,QAAQ,MAAM,KAAK,oBAAoBA,QAAO,CAAC;EACxD;EAEQ,MAAM,oBACZA,UAAgB;AAEhB,UAAM,EAAC,IAAG,IAAI;AACd,UAAM,MAAM,IAAI,IAAIA,SAAQ,GAAG;AAC/B,UAAM,OAAO,IAAI,aAAa,IAAI,MAAM;AAExC,WAAO,OACH,IAAI,QAAQ,aAAa,IAAI,IAC7B,IAAI,QAAQ,aAAa,EAAC,UAAU,OAAO,YAAYA,SAAO,CAAC;EACrE;EAEQ,MAAM,YAAY,SAAgB;AACxC,UAAM,EAAC,IAAG,IAAI;AAEd,UAAM,SAAS,IAAI,IAAI,QAAQ,QAAQ;MACrC;IACD,CAAA;AAED,UAAM,OAAO,QAAQ;;;;;;KAMpB;EACH;EAEQ,MAAM,mBACZ,OACAA,UACA,MAAY;AAEZ,UAAM,EAAC,QAAAD,QAAM,IAAI;AACjB,IAAAA,QAAO,MAAM,+BAA+B,EAAC,MAAM,OAAO,MAAM,QAAO,CAAC;AAExE,QAAI,iBAAiB,gBAAgB;AACnC,aAAO,KAAK,uBAAuBC,UAAS,IAAI;IAClD;AAEA,QACE,iBAAiB,oBACjB,iBAAiB,mBACjB;AACA,aAAO,IAAI,SAAS,QAAW;QAC7B,QAAQ;QACR,YAAY;MACb,CAAA;IACH;AAEA,WAAO,IAAI,SAAS,QAAW;MAC7B,QAAQ;MACR,YAAY;IACb,CAAA;EACH;EAEQ,MAAM,4BACZ,OACAA,UACA,MAAY;AAEZ,UAAM,EAAC,KAAK,QAAAD,SAAQ,QAAAD,QAAM,IAAI;AAC9B,QAAI,iBAAiB,mBAAmB;AACtC,UAAI,MAAM,SAAS,SAAS,KAAK;AAC/B,QAAAC,QAAO,KAAK,yDAAyD;UACnE;QACD,CAAA;AACD,cAAM,MAAM,UAAU,EAAC,KAAK,QAAAD,QAAc,GAAGE,UAAS,OAAO,IAAI;MACnE,OAAO;AACL,cAAM,UAAU,KAAK,UAAU,MAAM,SAAS,MAAM,MAAM,CAAC;AAC3D,QAAAD,QAAO,MAAM,+CAA+C,OAAO,IAAI;UACrE;QACD,CAAA;AAED,cAAM,IAAI,SAAS,QAAW;UAC5B,QAAQ,MAAM,SAAS;UACvB,YAAY,MAAM,SAAS;QAC5B,CAAA;MACH;IACF,WAAW,iBAAiB,mBAAmB;AAC7C,YAAM,UAAkC,EAAC,KAAI;AAC7C,UAAI,MAAM,UAAU;AAClB,gBAAQ,WAAW,KAAK,UAAU,MAAM,IAAI;MAC9C;AAEA,MAAAA,QAAO,MACL,+CAA+C,MAAM,OAAO,IAC5D,OAAO;AAGT,YAAM,IAAI,SAAS,QAAW;QAC5B,QAAQ;QACR,YAAY;MACb,CAAA;IACH;EACF;AACD;A;;;IClTY,8BAAqB;EAWhC,YAAmB,EAAC,KAAK,QAAAE,SAAQ,QAAAC,QAAM,GAAgC;AAR7D;AAKA;AACA;AAGR,SAAK,MAAM;AACX,SAAK,SAASD;AACd,SAAK,SAASC;EAChB;EAEO,MAAM,uBAAuB,UAAiB;EAAkB;EAEhE,MAAM,aACXC,UACA,gBAA8B;AAE9B,UAAM,EAAC,KAAK,QAAAF,SAAQ,QAAAC,QAAM,IAAI;AAC9B,UAAM,EAAC,MAAM,SAAS,aAAY,IAAI;AAEtC,QAAI,CAAC;AAAc,YAAM,IAAI,gBAAe;AAE5C,QAAI,CAAC,WAAW,CAAC,QAAQ,SAAS,MAAS,GAAG;AAC5C,MAAAA,QAAO,KAAK,0BAA0B,EAAC,KAAI,CAAC;AAC5C,MAAAA,QAAO,KAAK,mCAAmC,EAAC,KAAI,CAAC;AACrD,YAAM,EAAC,SAAS,eAAc,IAAI,MAAM,KAAK,cAAc;QACzD,SAAAC;QACA;QACA;QACA,oBAAoB,mBAAmB;MACxC,CAAA;AAED,YAAMF,QAAO,eAAgB,aAAa,cAAc;AAExD,UAAI,aAAa;AAEjB,UAAIA,QAAO,iBAAiB;AAC1B,QAAAC,QAAO,KAAK,kCAAkC,EAAC,KAAI,CAAC;AACpD,cAAM,EAAC,SAAS,cAAa,IAAI,MAAM,KAAK,cAAc;UACxD,SAAAC;UACA;UACA;UACA,oBAAoB,mBAAmB;QACxC,CAAA;AAED,cAAMF,QAAO,eAAgB,aAAa,aAAa;AACvD,qBAAa;MACf;AAEA,MAAAC,QAAO,MAAM,uDAAuD;QAClE,MAAM,WAAW;QACjB,UAAU,WAAW;MACtB,CAAA;AAED,UAAI;AACF,cAAM,KAAK,oBACT,EAAC,KAAK,QAAAD,SAAQ,QAAAC,QAAM,GACpB,YACAC,UACA,YAAY;MAEhB,SAAS,iBAAiB;AACxB,YAAI,2BAA2B,UAAU;AACvC,gBAAM;QACR;AAEA,cAAM,IAAI,SAAS,QAAW;UAC5B,QAAQ;UACR,YAAY;QACb,CAAA;MACH;AAEA,aAAO;IACT;AAEA,WAAO;EACT;EAEO,kBAAkBA,UAAgB;AACvC,UAAM,EAAC,KAAK,QAAAF,SAAQ,QAAAC,QAAM,IAAI;AAC9B,WAAO,yBAAyB;MAC9B,SAAAC;MACA,SAAS,OAAO,EAAC,SAAS,MAAK,MAAqB;AAClD,YAAI,MAAM,SAAS,SAAS,KAAK;AAC/B,UAAAD,QAAO,MAAM,sCAAsC;YACjD,MAAM,mBAAmBC,QAAO;UACjC,CAAA;AACD,gBAAM,sBAAsB,EAAC,QAAAF,SAAa,QAAAC,QAAM,GAAG,OAAO;AAE1D,uCAA6B;YAC3B,QAAQ,EAAC,QAAAD,SAAQ,KAAK,QAAAC,QAAM;YAC5B,SAAAC;UACD,CAAA;QACH;MACF;IACD,CAAA;EACH;EAEQ,MAAM,cAAc,EAC1B,SAAAA,UACA,MACA,cACA,mBAAkB,GAMnB;;AACC,UAAM,EAAC,KAAK,QAAAF,SAAQ,QAAAC,QAAM,IAAI;AAE9B,QAAI;AACF,aAAO,MAAM,IAAI,KAAK,cAAc;QAClC;QACA;QACA;MACD,CAAA;IACH,SAAS,OAAO;AACd,UACE,iBAAiB,mBAChB,iBAAiB,qBAChB,MAAM,SAAS,SAAS,SACxB,WAAM,SAAS,SAAf,mBAAqB,WAAU,yBACjC;AACA,cAAM,6BAA6B;UACjC,QAAQ,EAAC,KAAK,QAAAD,SAAQ,QAAAC,QAAM;UAC5B,SAAAC;UACA,cAAc;QACf,CAAA;MACH;AAEA,YAAM,IAAI,SAAS,QAAW;QAC5B,QAAQ;QACR,YAAY;MACb,CAAA;IACH;EACF;EAEQ,MAAM,oBACZ,QACA,SACAA,UACA,cAAoB;AAEpB,UAAM,EAAC,QAAAF,QAAM,IAAI;AACjB,UAAMA,QAAO,yBAAyB,cAAc;MAClD,iBAAiB,MAAK;AACpB,eAAO,qBAAqB,QAAQ,SAASE,UAAS,IAAI;MAC5D;MACA,YAAY;IACb,CAAA;EACH;AACD;A;;;IC3KY,2BAAkB;EAW7B,YAAmB,EAAC,KAAK,QAAAC,SAAQ,QAAAC,QAAM,GAAgC;AAR7D;AAKA;AACA;AAGR,SAAK,MAAM;AACX,SAAK,SAASD;AACd,SAAK,SAASC;EAChB;EAEO,MAAM,uBAAuBC,UAAgB;AAClD,SAAK,OAAO,MAAM,kDAAkD;MAClE,MAAM,mBAAmBA,QAAO;IACjC,CAAA;EACH;EAEO,MAAM,aACX,UACA,gBAA8B;AAE9B,UAAM,EAAC,KAAI,IAAI;AAEf,SAAK,OAAO,MACV,yEACA,EAAC,KAAI,CAAC;AAER,UAAM,UAAU,KAAK,IAAI,QAAQ,iBAAiB,IAAI;AAEtD,WAAO;EACT;EAEO,kBAAkBA,UAAgB;AACvC,WAAO,yBAAyB;MAC9B,SAAAA;MACA,SAAS,OAAO,EAAC,MAAK,MAAqB;AACzC,YAAI,MAAM,SAAS,SAAS,KAAK;AAC/B,eAAK,OAAO,KACV,oPAAoP;AAEtP,gBAAM,IAAI,aACR,8CAA8C;QAElD;MACF;IACD,CAAA;EACH;AACD;;;AC3DD,IAAM,oBAAoB;IAEb,iCAAwB;EAGnC,cAAA;AAFU;AAGR,SAAK,cAAc,oBAAI,IAAG;EAC5B;EAEA,MAAM,cAAc,EAClB,iBACA,WAAU,GACoB;AAC9B,QAAI;AACF,UAAI,KAAK,kBAAkB,UAAU,GAAG;AACtC,cAAM,gBAAe;MACvB;IACF;AACE,WAAK,sBAAqB;IAC5B;AAEA,WAAO,QAAQ,QAAO;EACxB;EAEQ,kBAAkB,YAAkB;AAC1C,QAAI,CAAC,KAAK,YAAY,IAAI,UAAU,GAAG;AACrC,WAAK,YAAY,IAAI,YAAY,KAAK,IAAG,CAAE;AAC3C,aAAO;IACT;AACA,WAAO;EACT;EAEQ,MAAM,wBAAqB;AACjC,SAAK,YAAY,QAAQ,CAAC,MAAM,YAAY,QAAO;AACjD,UAAI,KAAK,IAAG,IAAK,OAAO,mBAAmB;AACzC,YAAI,OAAO,UAAU;MACvB;IACF,CAAC;EACH;AACD;;;ACvCK,SAAU,wBAAwB,QAAmB;AACzD,QAAM,EAAC,KAAK,QAAAC,SAAQ,QAAAC,QAAM,IAAI;AAE9B,SAAO,eAAe,aAAaC,UAAgB;AACjD,IAAAD,QAAO,KAAK,6BAA6B;AAEzC,QAAIC,SAAQ,WAAW,QAAQ;AAC7B,MAAAD,QAAO,MACL,yEACA,EAAC,KAAKC,SAAQ,KAAK,QAAQA,SAAQ,OAAM,CAAC;AAE5C,YAAM,IAAI,SAAS,QAAW;QAC5B,QAAQ;QACR,YAAY;MACb,CAAA;IACH;AAEA,UAAM,UAAU,MAAMA,SAAQ,KAAI;AAClC,UAAM,SAAS,MAAM,IAAI,KAAK,SAAS;MACrC;MACA,YAAYA;IACb,CAAA;AAED,QAAI,CAAC,OAAO,OAAO;AACjB,MAAAD,QAAO,MAAM,oCAAoC,EAAC,QAAQ,OAAO,OAAM,CAAC;AAExE,YAAM,IAAI,SAAS,QAAW;QAC5B,QAAQ;QACR,YAAY;MACb,CAAA;IACH;AAEA,UAAM,UAAU,KAAK,MAAM,OAAO;AAElC,IAAAA,QAAO,MAAM,yDAAyD;MACpE,MAAM,QAAQ;IACf,CAAA;AAED,UAAM,YAAY,IAAI,QAAQ,aAAa,QAAQ,cAAc;AACjE,UAAM,UAAU,MAAMD,QAAO,eAAgB,YAAY,SAAS;AAElE,QAAI,CAAC,SAAS;AACZ,MAAAC,QAAO,KAAK,uCAAuC;QACjD,MAAM,QAAQ;MACf,CAAA;AACD,YAAM,IAAI,SAAS,QAAW;QAC5B,QAAQ;QACR,YAAY;MACb,CAAA;IACH;AAEA,IAAAA,QAAO,MAAM,wCAAwC,EAAC,MAAM,QAAQ,KAAI,CAAC;AAEzE,WAAO;MACL;MACA;MACA,OAAO,mBAAmB,EAAC,QAAQ,QAAO,CAAC;;EAE/C;AACF;A;;;ACrDM,SAAU,sCACd,QAAmB;AAEnB,QAAM,EAAC,KAAK,QAAAE,QAAM,IAAI;AAEtB,SAAO,eAAe,aACpBC,UAAgB;AAEhB,IAAAD,QAAO,KAAK,4CAA4C;AAExD,QAAIC,SAAQ,WAAW,QAAQ;AAC7B,MAAAD,QAAO,MACL,wFACA,EAAC,KAAKC,SAAQ,KAAK,QAAQA,SAAQ,OAAM,CAAC;AAE5C,YAAM,IAAI,SAAS,QAAW;QAC5B,QAAQ;QACR,YAAY;MACb,CAAA;IACH;AAEA,UAAM,UAAU,MAAMA,SAAQ,KAAI;AAClC,UAAM,SAAS,MAAM,IAAI,mBAAmB,SAAS;MACnD;MACA,YAAYA;IACb,CAAA;AAED,QAAI,CAAC,OAAO,OAAO;AACjB,MAAAD,QAAO,MAAM,mDAAmD;QAC9D,QAAQ,OAAO;MAChB,CAAA;AAED,YAAM,IAAI,SAAS,QAAW;QAC5B,QAAQ;QACR,YAAY;MACb,CAAA;IACH;AAEA,UAAM,UAAU,KAAK,MAAM,OAAO;AAClC,UAAM,OAAOC,SAAQ,QAAQ,IAAI,cAAc,MAAM,KAAK;AAE1D,IAAAD,QAAO,MACL,wEACA;MACE;IACD,CAAA;AAGH,UAAM,UAAU,MAAM,2BAA2B,MAAM,MAAM;AAE7D,QAAI,CAAC,SAAS;AACZ,MAAAA,QAAO,KAAK,sDAAsD;QAChE;MACD,CAAA;AACD,YAAM,IAAI,SAAS,QAAW;QAC5B,QAAQ;QACR,YAAY;MACb,CAAA;IACH;AAEA,IAAAA,QAAO,MAAM,uDAAuD;MAClE;IACD,CAAA;AAED,WAAO;MACL;MACA;MACA,OAAO,mBAAmB,EAAC,QAAQ,QAAO,CAAC;;EAE/C;AACF;;;AC3CM,SAAUE,wBACdC,SACAC,SAAyB;AAEzB,QAAM,UAAU,CAAC,MAAc,YAC7BA,QAAO,KAAK,eAAe,IAAI;;IAAsB,OAAO;CAAI;AAElE,MAAI,CAACD,QAAO,OAAO,kCAAkC;AACnD,YACE,oCACA,gMACuG;EAE3G;AACF;;;ACKM,SAAU,WAId,WAA2B;AAC3B,QAAM,MAAM,UAAU,SAAS;AAC/B,QAAME,UAAS,aAAsB,WAAW,IAAI,MAAM;AAC1D,QAAMC,UAAS,eAAe,IAAI,MAAM;AAExC,MAAI,UAAU,UAAU;AACtB,QAAI,SAAS,YAAY,UAAU,QAAQ;EAC7C;AAEA,QAAM,SAAsB,EAAC,KAAK,QAAAD,SAAQ,QAAAC,QAAM;AAEhD,MAAI;AACJ,MAAID,QAAO,iBAAiB,gBAAgB,cAAc;AACxD,eAAW,IAAI,mBAAmB,MAAM;EAC1C,WACEA,QAAO,OAAO,oCACdA,QAAO,eACP;AACA,eAAW,IAAI,sBAAsB,MAAM;EAC7C,OAAO;AACL,eAAW,IAAI,qBAAqB,MAAM;EAC5C;AAEA,QAAM,eAAe,oBAA4B;IAC/C,GAAG;IACH;EACD,CAAA;AAED,QAAM,UAG0B;IAC9B,gBAAgBA,QAAO;IACvB,4BAA4B,kCAAkC,MAAM;IACpE,kBAAkB,wBAAwB,MAAM;IAChD,cAAc;MACZ,OAAO;MACP,MAAM,wBAAwB,MAAM;MACpC,QAAQ,0BAA0B,MAAM;MACxC,oBAAoB,sCAAsC,MAAM;MAChE,SAAS,2BAAmC,MAAM;IACnD;IACD,iBAAiB;MACf,OAAO,mCAAmC,MAAM;MAChD,YAAY,wCAAwC,MAAM;IAC3D;;AAGH,MACE,cAAc,SAAS,SAAS,KAChC,oBAAoB,SAAS,SAAS,GACtC;AACA,YAAQ,QAAQ,aAAa,MAAM;EACrC;AAEA,EAAAE,wBAAuBF,SAAQC,OAAM;AAErC,SAAO;AACT;AAEA,SAAS,cACP,UACAD,SAAc;AAEd,SAAOA,QAAO,iBAAiB,gBAAgB;AACjD;AAEA,SAAS,oBACP,UACAA,SAAc;AAEd,SAAOA,QAAO,iBAAiB,gBAAgB;AACjD;AAIM,SAAU,UAAU,WAAuB;AAC/C,MAAI;AACJ,MAAI;AACF,aAAS,IAAI,IAAI,UAAU,MAAM;EACnC,SAAS,OAAO;AACd,UAAM,UACJ,UAAU,WAAW,KACjB;+LAEA,iCAAiC,UAAU,MAAM;AACvD,UAAM,IAAI,aAAa,OAAO;EAChC;AAGA,MAAI,OAAO,aAAa,eAAe,CAAC,OAAO,QAAQ,QAAQ,IAAI,MAAM;AACvE,WAAO,OAAO,QAAQ,IAAI;EAC5B;AAEA,YAAU,SAAS,OAAO;AAE1B,MAAI,kBAAkB,0BAA0B,6BAA6B;AAC7E,MAAI,UAAU,iBAAiB;AAC7B,sBAAkB,GAAG,UAAU,eAAe,MAAM,eAAe;EACrE;AAEA,SAAO,WAAW;IAChB,GAAG;IACH,UAAU,OAAO;IACjB,YAAY,OAAO,SAAS,QAAQ,KAAK,EAAE;IAC3C;IACA,eAAe,UAAU,iBAAiB;IAC1C,YAAY,UAAU;IACtB,kBAAkB,UAAU,iBAAiB,gBAAgB;IAC7D,SAAS,UAAU;IACnB,QAAQ;MACN,gCAAgC;IACjC;IACD,yBAAyB;EAC1B,CAAA;AACH;AAEA,SAAS,aACP,WACA,WAAoB;AAEpB,MACE,CAAC,UAAU,kBACX,UAAU,iBAAiB,gBAAgB,cAC3C;AACA,UAAM,IAAI,aACR,qJAAqJ;EAEzJ;AAEA,QAAM,iBAAiB,UAAU,kBAAkB;AACnD,YAAU,eAAe,UAAU,gBAAgB,gBAAgB;AAEnE,SAAO;IACL,GAAG;IACH,GAAG;IACH,SAAS,UAAU;IACnB,QAAQ,UAAU;IAClB,0BAA0B,IAAI,yBAAwB;IACtD,iBAAiB,UAAU,iBAAiB,gBAAgB;IAC5D,iBAAiB,UAAU,mBAAmB;IAC9C,OAAO,UAAU,SAAS,CAAA;IAC1B,gBAAgB,UAAU;IAC1B,QAAQ,UAAU,UAAU,CAAA;IAC5B,MAAM;MACJ,MAAM;MACN,cAAc,GAAG,cAAc;MAC/B,uBAAuB,GAAG,cAAc;MACxC,gBAAgB,GAAG,cAAc;MACjC,WAAW,GAAG,cAAc;IAC7B;IACD,cAAc,UAAU;;AAE5B;;;ACnNA,yBAAyB,MAAK;AAC5B,SAAO;AACT,CAAC;",
  "names": ["request", "LogSeverity", "ApiVersion", "ShopifyHeader", "ClientType", "BillingInterval", "BillingReplacementBehavior", "StatusCode", "Method", "config", "config", "config", "RestClient", "config", "logger", "config", "logger", "createLogger", "config", "ShopifyErrors.HttpRequestError", "ShopifyErrors.GraphqlQueryError", "ShopifyErrors.HttpMaxRetriesError", "ShopifyErrors.HttpThrottlingError", "ShopifyErrors.HttpInternalError", "ShopifyErrors.HttpResponseError", "config", "ShopifyErrors.MissingRequiredArgument", "isInteger", "value", "INTEGER_REGEX", "test", "isNumber", "NUMBER_REGEX", "isSafeNumber", "config", "Number", "isSafeInteger", "parseInt", "num", "parseFloat", "parsed", "String", "valueDigits", "extractSignificantDigits", "parsedDigits", "approx", "requiredDigits", "length", "startsWith", "substring", "UnsafeNumberReason", "getUnsafeNumberReason", "undefined", "truncate_integer", "isFinite", "overflow", "underflow", "truncate_float", "extractSignificantDigits", "value", "start", "end", "getSignificantDigitRange", "digits", "substring", "dot", "indexOf", "lastIndexOf", "length", "LosslessNumber", "constructor", "value", "isLosslessNumber", "isNumber", "Error", "valueOf", "unsafeReason", "getUnsafeNumberReason", "undefined", "UnsafeNumberReason", "truncate_float", "Number", "parseFloat", "isInteger", "BigInt", "toString", "parseLosslessNumber", "value", "LosslessNumber", "revive", "json", "reviver", "reviveValue", "context", "key", "value", "Array", "isArray", "call", "reviveArray", "isLosslessNumber", "reviveObject", "object", "Object", "keys", "undefined", "array", "i", "length", "String", "parse", "text", "reviver", "parseNumber", "arguments", "length", "undefined", "parseLosslessNumber", "i", "value", "parseValue", "expectValue", "expectEndOfInput", "revive", "parseObject", "charCodeAt", "codeOpeningBrace", "skipWhitespace", "object", "initial", "codeClosingBrace", "eatComma", "start", "key", "parseString", "throwObjectKeyExpected", "eatColon", "throwObjectValueExpected", "Object", "prototype", "hasOwnProperty", "call", "isDeepEqual", "throwDuplicateKey", "throwObjectKeyOrEndExpected", "parseArray", "codeOpeningBracket", "array", "codeClosingBracket", "expectArrayItem", "push", "throwArrayItemOrEndExpected", "parseNumeric", "parseKeyword", "name", "slice", "isWhitespace", "codeDoubleQuote", "result", "codeBackslash", "char", "escapeChar", "escapeCharacters", "isHex", "String", "fromCharCode", "Number", "parseInt", "throwInvalidUnicodeCharacter", "throwInvalidEscapeCharacter", "isValidStringCharacter", "throwInvalidCharacter", "expectEndOfString", "codeMinus", "expectDigit", "codeZero", "isNonZeroDigit", "isDigit", "codeDot", "codeLowercaseE", "codeUppercaseE", "codePlus", "codeComma", "SyntaxError", "gotAt", "codeColon", "numSoFar", "pos", "chars", "got", "code", "codeSpace", "codeNewline", "codeTab", "codeReturn", "codeNine", "codeUppercaseA", "codeUppercaseF", "codeLowercaseA", "codeLowercaseF", "codeOne", "a", "b", "Array", "isArray", "every", "item", "index", "isObject", "keys", "Set", "f", "n", "r", "t", "config", "ShopifyErrors.MissingRequiredArgument", "ShopifyErrors.InvalidRequestError", "link", "request", "config", "ShopifyErrors.MissingRequiredArgument", "config", "ShopifyErrors.InvalidSession", "GraphqlClient", "ShopifyErrors.MissingRequiredArgument", "config", "ShopifyErrors.SafeCompareError", "HmacValidationType", "config", "ShopifyErrors.InvalidHmacError", "request", "log", "config", "DataType", "config", "log", "nonce", "config", "ShopifyErrors.InvalidJwtError", "config", "getCurrentSessionId", "request", "log", "ShopifyErrors.MissingJwtTokenError", "config", "request", "log", "config", "callback", "ShopifyErrors.BotActivityDetected", "ShopifyErrors.CookieNotFound", "ShopifyErrors.InvalidOAuthError", "ShopifyErrors.PrivateAppError", "config", "request", "ShopifyErrors.MissingRequiredArgument", "ShopifyErrors.InvalidRequestError", "RequestedTokenType", "config", "config", "config", "config", "config", "config", "DeliveryMethod", "WebhookOperation", "config", "addHandlers", "getTopicsAdded", "getHandlers", "log", "config", "register", "log", "GraphqlClient", "config", "request", "log", "process", "config", "ShopifyErrors.InvalidWebhookError", "log", "ShopifyErrors.MissingWebhookCallbackError", "config", "process", "config", "check", "GraphqlClient", "config", "GraphqlClient", "billingConfig", "config", "GraphqlClient", "config", "GraphqlClient", "config", "createUsageRecord", "GraphqlClient", "subscriptions", "config", "updateUsageCappedAmount", "GraphqlClient", "config", "validateFactory", "config", "config", "validateFactory", "validateFactory", "config", "config", "validateFactory", "config", "_jsx", "logger", "request", "logger", "config", "config", "request", "logger", "config", "request", "request", "logger", "request", "logger", "request", "request", "request", "config", "request", "config", "request", "config", "isEmbeddedRequest", "logger", "config", "request", "logger", "request", "logger", "request", "config", "logger", "isEmbeddedRequest", "params", "request", "logger", "request", "logger", "request", "createUsageRecord", "logger", "request", "updateUsageCappedAmount", "logger", "request", "request", "logger", "config", "SESSION_TOKEN_PARAM", "request", "logger", "config", "request", "config", "request", "request", "config", "logger", "redirect", "remixRedirect", "request", "config", "logger", "remixRedirect", "config", "logger", "admin", "logger", "logger", "logger", "config", "request", "shop", "sessionId", "request", "config", "logger", "logger", "request", "check", "logger", "deprecated", "warningFunction", "config", "logger", "request", "request", "logger", "config", "logger", "request", "context", "searchParams", "request", "config", "logger", "config", "logger", "request", "config", "logger", "request", "config", "logger", "request", "config", "logger", "request", "logger", "request", "logDisabledFutureFlags", "config", "logger", "config", "logger", "logDisabledFutureFlags"]
}
