{
  "version": 3,
  "sources": ["../../rest/base.ts"],
  "sourcesContent": ["import {RestResourceError} from '../lib/error';\nimport {Session} from '../lib/session/session';\nimport {PageInfo, RestRequestReturn} from '../lib/clients/admin/types';\nimport {DataType} from '../lib/clients/types';\nimport {RestClient} from '../lib/clients/admin/rest/client';\nimport {ApiVersion} from '../lib/types';\nimport {ConfigInterface} from '../lib/base-types';\nimport {Headers} from '../runtime/http';\n\nimport {IdSet, Body, ResourcePath, ParamSet, ResourceNames} from './types';\n\ninterface BaseFindArgs {\n  session: Session;\n  params?: ParamSet;\n  urlIds: IdSet;\n  requireIds?: boolean;\n}\n\ninterface BaseConstructorArgs {\n  session: Session;\n  fromData?: Body | null;\n}\n\ninterface SaveArgs {\n  update?: boolean;\n}\n\ninterface RequestArgs extends BaseFindArgs {\n  http_method: string;\n  operation: string;\n  body?: Body | null;\n  entity?: Base | null;\n}\n\ninterface GetPathArgs {\n  http_method: string;\n  operation: string;\n  urlIds: IdSet;\n  entity?: Base | null;\n}\n\ninterface SetClassPropertiesArgs {\n  Client: typeof RestClient;\n  config: ConfigInterface;\n}\n\nexport interface FindAllResponse<T = Base> {\n  data: T[];\n  headers: Headers;\n  pageInfo?: PageInfo;\n}\n\nexport class Base {\n  // For instance attributes\n  [key: string]: any;\n\n  public static Client: typeof RestClient;\n  public static config: ConfigInterface;\n\n  public static apiVersion: string;\n  protected static resourceNames: ResourceNames[] = [];\n\n  protected static primaryKey = 'id';\n  protected static customPrefix: string | null = null;\n  protected static readOnlyAttributes: string[] = [];\n\n  protected static hasOne: Record<string, typeof Base> = {};\n  protected static hasMany: Record<string, typeof Base> = {};\n\n  protected static paths: ResourcePath[] = [];\n\n  public static setClassProperties({Client, config}: SetClassPropertiesArgs) {\n    this.Client = Client;\n    this.config = config;\n  }\n\n  protected static async baseFind<T extends Base = Base>({\n    session,\n    urlIds,\n    params,\n    requireIds = false,\n  }: BaseFindArgs): Promise<FindAllResponse<T>> {\n    if (requireIds) {\n      const hasIds = Object.entries(urlIds).some(([_key, value]) => value);\n\n      if (!hasIds) {\n        throw new RestResourceError(\n          'No IDs given for request, cannot find path',\n        );\n      }\n    }\n\n    const response = await this.request<T>({\n      http_method: 'get',\n      operation: 'get',\n      session,\n      urlIds,\n      params,\n    });\n\n    return {\n      data: this.createInstancesFromResponse<T>(session, response.body as Body),\n      headers: response.headers,\n      pageInfo: response.pageInfo,\n    };\n  }\n\n  protected static async request<T = unknown>({\n    session,\n    http_method,\n    operation,\n    urlIds,\n    params,\n    body,\n    entity,\n  }: RequestArgs): Promise<RestRequestReturn<T>> {\n    const client = new this.Client({\n      session,\n      apiVersion: this.apiVersion as ApiVersion,\n    });\n\n    const path = this.getPath({http_method, operation, urlIds, entity});\n\n    const cleanParams: Record<string, string | number> = {};\n    if (params) {\n      for (const key in params) {\n        if (params[key] !== null) {\n          cleanParams[key] = params[key];\n        }\n      }\n    }\n\n    switch (http_method) {\n      case 'get':\n        return client.get<T>({path, query: cleanParams});\n      case 'post':\n        return client.post<T>({\n          path,\n          query: cleanParams,\n          data: body!,\n          type: DataType.JSON,\n        });\n      case 'put':\n        return client.put<T>({\n          path,\n          query: cleanParams,\n          data: body!,\n          type: DataType.JSON,\n        });\n      case 'delete':\n        return client.delete<T>({path, query: cleanParams});\n      default:\n        throw new Error(`Unrecognized HTTP method \"${http_method}\"`);\n    }\n  }\n\n  protected static getJsonBodyName(): string {\n    return this.name.replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase();\n  }\n\n  protected static getPath({\n    http_method,\n    operation,\n    urlIds,\n    entity,\n  }: GetPathArgs): string {\n    let match: string | null = null;\n    let specificity = -1;\n\n    const potentialPaths: ResourcePath[] = [];\n    this.paths.forEach((path: ResourcePath) => {\n      if (\n        http_method !== path.http_method ||\n        operation !== path.operation ||\n        path.ids.length <= specificity\n      ) {\n        return;\n      }\n\n      potentialPaths.push(path);\n\n      let pathUrlIds: IdSet = {...urlIds};\n      path.ids.forEach((id) => {\n        if (!pathUrlIds[id] && entity && entity[id]) {\n          pathUrlIds[id] = entity[id];\n        }\n      });\n\n      pathUrlIds = Object.entries(pathUrlIds).reduce(\n        (acc: IdSet, [key, value]: [string, string | number | null]) => {\n          if (value) {\n            acc[key] = value;\n          }\n          return acc;\n        },\n        {},\n      );\n\n      // If we weren't given all of the path's required ids, we can't use it\n      const diff = path.ids.reduce(\n        (acc: string[], id: string) => (pathUrlIds[id] ? acc : acc.concat(id)),\n        [],\n      );\n      if (diff.length > 0) {\n        return;\n      }\n\n      specificity = path.ids.length;\n      match = path.path.replace(\n        /(<([^>]+)>)/g,\n        (_m1, _m2, id) => `${pathUrlIds[id]}`,\n      );\n    });\n\n    if (!match) {\n      const pathOptions = potentialPaths.map((path) => path.path);\n\n      throw new RestResourceError(\n        `Could not find a path for request. If you are trying to make a request to one of the following paths, ensure all relevant IDs are set. :\\n - ${pathOptions.join(\n          '\\n - ',\n        )}`,\n      );\n    }\n\n    if (this.customPrefix) {\n      return `${this.customPrefix}/${match}`;\n    } else {\n      return match;\n    }\n  }\n\n  protected static createInstancesFromResponse<T extends Base = Base>(\n    session: Session,\n    data: Body,\n  ): T[] {\n    let instances: T[] = [];\n    this.resourceNames.forEach((resourceName) => {\n      const singular = resourceName.singular;\n      const plural = resourceName.plural;\n      if (data[plural] || Array.isArray(data[singular])) {\n        instances = instances.concat(\n          (data[plural] || data[singular]).reduce(\n            (acc: T[], entry: Body) =>\n              acc.concat(this.createInstance<T>(session, entry)),\n            [],\n          ),\n        );\n      } else if (data[singular]) {\n        instances.push(this.createInstance<T>(session, data[singular]));\n      }\n    });\n\n    return instances;\n  }\n\n  protected static createInstance<T extends Base = Base>(\n    session: Session,\n    data: Body,\n    prevInstance?: T,\n  ): T {\n    const instance: T = prevInstance\n      ? prevInstance\n      : new (this as any)({session});\n\n    if (data) {\n      instance.setData(data);\n    }\n\n    return instance;\n  }\n\n  #session: Session;\n\n  get session(): Session {\n    return this.#session;\n  }\n\n  constructor({session, fromData}: BaseConstructorArgs) {\n    this.#session = session;\n\n    if (fromData) {\n      this.setData(fromData);\n    }\n  }\n\n  public async save({update = false}: SaveArgs = {}): Promise<void> {\n    const {primaryKey, resourceNames} = this.resource();\n    const method = this[primaryKey] ? 'put' : 'post';\n\n    const data = this.serialize(true);\n\n    const response = await this.resource().request({\n      http_method: method,\n      operation: method,\n      session: this.session,\n      urlIds: {},\n      body: {[this.resource().getJsonBodyName()]: data},\n      entity: this,\n    });\n\n    const flattenResourceNames: string[] = resourceNames.reduce<string[]>(\n      (acc, obj) => {\n        return acc.concat(Object.values(obj));\n      },\n      [],\n    );\n\n    const matchResourceName = Object.keys(response.body as Body).filter(\n      (key: string) => flattenResourceNames.includes(key),\n    );\n\n    const body: Body | undefined = (response.body as Body)[\n      matchResourceName[0]\n    ];\n\n    if (update && body) {\n      this.setData(body);\n    }\n  }\n\n  public async saveAndUpdate(): Promise<void> {\n    await this.save({update: true});\n  }\n\n  public async delete(): Promise<void> {\n    await this.resource().request({\n      http_method: 'delete',\n      operation: 'delete',\n      session: this.session,\n      urlIds: {},\n      entity: this,\n    });\n  }\n\n  public serialize(saving = false): Body {\n    const {hasMany, hasOne, readOnlyAttributes} = this.resource();\n\n    return Object.entries(this).reduce((acc: Body, [attribute, value]) => {\n      if (\n        ['#session'].includes(attribute) ||\n        (saving && readOnlyAttributes.includes(attribute))\n      ) {\n        return acc;\n      }\n\n      if (attribute in hasMany && value) {\n        acc[attribute] = value.reduce((attrAcc: Body, entry: Base) => {\n          return attrAcc.concat(this.serializeSubAttribute(entry, saving));\n        }, []);\n      } else if (attribute in hasOne && value) {\n        acc[attribute] = this.serializeSubAttribute(value, saving);\n      } else {\n        acc[attribute] = value;\n      }\n\n      return acc;\n    }, {});\n  }\n\n  public toJSON(): Body {\n    return this.serialize();\n  }\n\n  public request<T = unknown>(args: RequestArgs) {\n    return this.resource().request<T>(args);\n  }\n\n  protected setData(data: Body): void {\n    const {hasMany, hasOne} = this.resource();\n\n    Object.entries(data).forEach(([attribute, val]) => {\n      if (attribute in hasMany) {\n        const HasManyResource: typeof Base = hasMany[attribute];\n        this[attribute] = [];\n        val.forEach((entry: Body) => {\n          const obj = new HasManyResource({session: this.session});\n          if (entry) {\n            obj.setData(entry);\n          }\n\n          this[attribute].push(obj);\n        });\n      } else if (attribute in hasOne) {\n        const HasOneResource: typeof Base = hasOne[attribute];\n        const obj = new HasOneResource({session: this.session});\n        if (val) {\n          obj.setData(val);\n        }\n        this[attribute] = obj;\n      } else {\n        this[attribute] = val;\n      }\n    });\n  }\n\n  protected resource(): typeof Base {\n    return this.constructor as unknown as typeof Base;\n  }\n\n  private serializeSubAttribute(attribute: Base, saving: boolean): Body {\n    return attribute.serialize\n      ? attribute.serialize(saving)\n      : this.resource()\n          .createInstance(this.session, attribute)\n          .serialize(saving);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
